Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> classes functions vars statements
Rule 2     vars -> var vars
Rule 3     vars -> empty
Rule 4     var -> $ attr init ;
Rule 5     attr -> ID : type
Rule 6     init -> = exp
Rule 7     init -> = NEW constructor_call
Rule 8     init -> empty
Rule 9     type -> INT_TYPE
Rule 10    type -> FLOAT_TYPE
Rule 11    type -> STRING_TYPE
Rule 12    type -> BOOLEAN_TYPE
Rule 13    type -> STACK
Rule 14    type -> ID check_class
Rule 15    return_type -> VOID
Rule 16    return_type -> type
Rule 17    classes -> class classes
Rule 18    classes -> empty
Rule 19    class -> @ ID inheritance scope_class class_block
Rule 20    inheritance -> < ID check_class >
Rule 21    inheritance -> empty
Rule 22    class_block -> { vars constructor functions }
Rule 23    constructor -> ~ ID params scope_constructor func_block
Rule 24    constructor -> empty
Rule 25    functions -> function functions
Rule 26    functions -> empty
Rule 27    function -> # ID neg_lookup : return_type params scope_function func_block
Rule 28    params -> ( attrs )
Rule 29    attrs -> attr attrs_alt
Rule 30    attrs -> empty
Rule 31    attrs_alt -> , attr attrs_alt
Rule 32    attrs_alt -> empty
Rule 33    func_block -> { vars statements }
Rule 34    statements -> statement
Rule 35    statements -> empty
Rule 36    statement -> if_block
Rule 37    statement -> while_block
Rule 38    statement -> for_block
Rule 39    statement -> print_stmt
Rule 40    statement -> expr
Rule 41    statement -> return
Rule 42    assign -> prop = exp
Rule 43    constructor_call -> ID ( args )
Rule 44    prop -> THIS . ID
Rule 45    prop -> ID . ID
Rule 46    prop -> ID
Rule 47    if_block -> IF ( exp ) block
Rule 48    if_block -> IF ( exp ) block ELSE block
Rule 49    while_block -> WHILE ( exp ) block
Rule 50    for_block -> FOR number FOR_TO number SKIP number block
Rule 51    print_stmt -> PRINT ( exp ) ;
Rule 52    return -> RETURN exp ;
Rule 53    return -> RETURN ;
Rule 54    block -> { statements }
Rule 55    number -> FLOAT
Rule 56    number -> INT
Rule 57    expr -> exp ;
Rule 58    exp -> read
Rule 59    exp -> logic_exp
Rule 60    exp -> assign
Rule 61    exp -> STRING
Rule 62    read -> READ ( string )
Rule 63    string -> ID check_string
Rule 64    string -> STRING
Rule 65    math_exp -> term math_exp_alt
Rule 66    math_exp_alt -> + term math_exp_alt
Rule 67    math_exp_alt -> - term math_exp_alt
Rule 68    math_exp_alt -> empty
Rule 69    term -> factor term_alt
Rule 70    term_alt -> * factor term_alt
Rule 71    term_alt -> / factor term_alt
Rule 72    term_alt -> empty
Rule 73    factor -> ID check_number
Rule 74    factor -> number
Rule 75    factor -> call
Rule 76    factor -> ( math_exp )
Rule 77    logic_exp -> log_a logic_exp_alt
Rule 78    logic_exp_alt -> OR log_a logic_exp_alt
Rule 79    logic_exp_alt -> empty
Rule 80    log_a -> log_b log_a_alt
Rule 81    log_a_alt -> AND log_b log_a_alt
Rule 82    log_a_alt -> empty
Rule 83    log_b -> ( logic_exp )
Rule 84    log_b -> bool
Rule 85    log_b -> comparison
Rule 86    bool -> TRUE
Rule 87    bool -> FALSE
Rule 88    comparison -> math_exp comparison_op math_exp
Rule 89    comparison -> math_exp
Rule 90    comparison_op -> <
Rule 91    comparison_op -> >
Rule 92    comparison_op -> EQ
Rule 93    comparison_op -> NE
Rule 94    call -> prop ( args )
Rule 95    call -> stack_call
Rule 96    args -> exp args_aux
Rule 97    args -> empty
Rule 98    args_aux -> , exp args_aux
Rule 99    args_aux -> empty
Rule 100   stack_call -> ID . stack_method
Rule 101   stack_method -> POP ( )
Rule 102   stack_method -> PUSH ( ID check_variable )
Rule 103   stack_method -> PEEK ( )
Rule 104   empty -> <empty>
Rule 105   scope_class -> empty
Rule 106   scope_function -> empty
Rule 107   scope_constructor -> empty
Rule 108   check_variable -> empty
Rule 109   check_class -> empty
Rule 110   check_string -> empty
Rule 111   check_number -> empty
Rule 112   neg_lookup -> empty

Terminals, with rules where they appear

#                    : 27
$                    : 4
(                    : 28 43 47 48 49 51 62 76 83 94 101 102 103
)                    : 28 43 47 48 49 51 62 76 83 94 101 102 103
*                    : 70
+                    : 66
,                    : 31 98
-                    : 67
.                    : 44 45 100
/                    : 71
:                    : 5 27
;                    : 4 51 52 53 57
<                    : 20 90
=                    : 6 7 42
>                    : 20 91
@                    : 19
AND                  : 81
BOOLEAN_TYPE         : 12
ELSE                 : 48
EQ                   : 92
FALSE                : 87
FLOAT                : 55
FLOAT_TYPE           : 10
FOR                  : 50
FOR_TO               : 50
ID                   : 5 14 19 20 23 27 43 44 45 45 46 63 73 100 102
IF                   : 47 48
INT                  : 56
INT_TYPE             : 9
NE                   : 93
NEW                  : 7
OR                   : 78
PEEK                 : 103
POP                  : 101
PRINT                : 51
PUSH                 : 102
READ                 : 62
RETURN               : 52 53
SKIP                 : 50
STACK                : 13
STRING               : 61 64
STRING_TYPE          : 11
THIS                 : 44
TRUE                 : 86
VOID                 : 15
WHILE                : 49
error                : 
{                    : 22 33 54
}                    : 22 33 54
~                    : 23

Nonterminals, with rules where they appear

args                 : 43 94
args_aux             : 96 98
assign               : 60
attr                 : 4 29 31
attrs                : 28
attrs_alt            : 29 31
block                : 47 48 48 49 50
bool                 : 84
call                 : 75
check_class          : 14 20
check_number         : 73
check_string         : 63
check_variable       : 102
class                : 17
class_block          : 19
classes              : 1 17
comparison           : 85
comparison_op        : 88
constructor          : 22
constructor_call     : 7
empty                : 3 8 18 21 24 26 30 32 35 68 72 79 82 97 99 105 106 107 108 109 110 111 112
exp                  : 6 42 47 48 49 51 52 57 96 98
expr                 : 40
factor               : 69 70 71
for_block            : 38
func_block           : 23 27
function             : 25
functions            : 1 22 25
if_block             : 36
inheritance          : 19
init                 : 4
log_a                : 77 78
log_a_alt            : 80 81
log_b                : 80 81
logic_exp            : 59 83
logic_exp_alt        : 77 78
math_exp             : 76 88 88 89
math_exp_alt         : 65 66 67
neg_lookup           : 27
number               : 50 50 50 74
params               : 23 27
print_stmt           : 39
program              : 0
prop                 : 42 94
read                 : 58
return               : 41
return_type          : 27
scope_class          : 19
scope_constructor    : 23
scope_function       : 27
stack_call           : 95
stack_method         : 100
statement            : 34
statements           : 1 33 54
string               : 62
term                 : 65 66 67
term_alt             : 69 70 71
type                 : 5 16
var                  : 2
vars                 : 1 2 22 33
while_block          : 37

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . classes functions vars statements
    (17) classes -> . class classes
    (18) classes -> . empty
    (19) class -> . @ ID inheritance scope_class class_block
    (104) empty -> .

    @               shift and go to state 2
    #               reduce using rule 104 (empty -> .)
    $               reduce using rule 104 (empty -> .)
    IF              reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    PRINT           reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    STRING          reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    THIS            reduce using rule 104 (empty -> .)
    ID              reduce using rule 104 (empty -> .)
    (               reduce using rule 104 (empty -> .)
    TRUE            reduce using rule 104 (empty -> .)
    FALSE           reduce using rule 104 (empty -> .)
    FLOAT           reduce using rule 104 (empty -> .)
    INT             reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    program                        shift and go to state 1
    classes                        shift and go to state 3
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (19) class -> @ . ID inheritance scope_class class_block

    ID              shift and go to state 6


state 3

    (1) program -> classes . functions vars statements
    (25) functions -> . function functions
    (26) functions -> . empty
    (27) function -> . # ID neg_lookup : return_type params scope_function func_block
    (104) empty -> .

    #               shift and go to state 9
    $               reduce using rule 104 (empty -> .)
    IF              reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    PRINT           reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    STRING          reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    THIS            reduce using rule 104 (empty -> .)
    ID              reduce using rule 104 (empty -> .)
    (               reduce using rule 104 (empty -> .)
    TRUE            reduce using rule 104 (empty -> .)
    FALSE           reduce using rule 104 (empty -> .)
    FLOAT           reduce using rule 104 (empty -> .)
    INT             reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 8
    empty                          shift and go to state 10

state 4

    (17) classes -> class . classes
    (17) classes -> . class classes
    (18) classes -> . empty
    (19) class -> . @ ID inheritance scope_class class_block
    (104) empty -> .

    @               shift and go to state 2
    #               reduce using rule 104 (empty -> .)
    $               reduce using rule 104 (empty -> .)
    IF              reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    PRINT           reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    STRING          reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    THIS            reduce using rule 104 (empty -> .)
    ID              reduce using rule 104 (empty -> .)
    (               reduce using rule 104 (empty -> .)
    TRUE            reduce using rule 104 (empty -> .)
    FALSE           reduce using rule 104 (empty -> .)
    FLOAT           reduce using rule 104 (empty -> .)
    INT             reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    classes                        shift and go to state 11
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 5

    (18) classes -> empty .

    #               reduce using rule 18 (classes -> empty .)
    $               reduce using rule 18 (classes -> empty .)
    IF              reduce using rule 18 (classes -> empty .)
    WHILE           reduce using rule 18 (classes -> empty .)
    FOR             reduce using rule 18 (classes -> empty .)
    PRINT           reduce using rule 18 (classes -> empty .)
    RETURN          reduce using rule 18 (classes -> empty .)
    STRING          reduce using rule 18 (classes -> empty .)
    READ            reduce using rule 18 (classes -> empty .)
    THIS            reduce using rule 18 (classes -> empty .)
    ID              reduce using rule 18 (classes -> empty .)
    (               reduce using rule 18 (classes -> empty .)
    TRUE            reduce using rule 18 (classes -> empty .)
    FALSE           reduce using rule 18 (classes -> empty .)
    FLOAT           reduce using rule 18 (classes -> empty .)
    INT             reduce using rule 18 (classes -> empty .)
    $end            reduce using rule 18 (classes -> empty .)


state 6

    (19) class -> @ ID . inheritance scope_class class_block
    (20) inheritance -> . < ID check_class >
    (21) inheritance -> . empty
    (104) empty -> .

    <               shift and go to state 13
    {               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 14
    inheritance                    shift and go to state 12

state 7

    (25) functions -> function . functions
    (25) functions -> . function functions
    (26) functions -> . empty
    (27) function -> . # ID neg_lookup : return_type params scope_function func_block
    (104) empty -> .

    #               shift and go to state 9
    $               reduce using rule 104 (empty -> .)
    IF              reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    PRINT           reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    STRING          reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    THIS            reduce using rule 104 (empty -> .)
    ID              reduce using rule 104 (empty -> .)
    (               reduce using rule 104 (empty -> .)
    TRUE            reduce using rule 104 (empty -> .)
    FALSE           reduce using rule 104 (empty -> .)
    FLOAT           reduce using rule 104 (empty -> .)
    INT             reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)
    }               reduce using rule 104 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 15
    empty                          shift and go to state 10

state 8

    (1) program -> classes functions . vars statements
    (2) vars -> . var vars
    (3) vars -> . empty
    (4) var -> . $ attr init ;
    (104) empty -> .

    $               shift and go to state 16
    IF              reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    PRINT           reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    STRING          reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    THIS            reduce using rule 104 (empty -> .)
    ID              reduce using rule 104 (empty -> .)
    (               reduce using rule 104 (empty -> .)
    TRUE            reduce using rule 104 (empty -> .)
    FALSE           reduce using rule 104 (empty -> .)
    FLOAT           reduce using rule 104 (empty -> .)
    INT             reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    vars                           shift and go to state 17
    var                            shift and go to state 18
    empty                          shift and go to state 19

state 9

    (27) function -> # . ID neg_lookup : return_type params scope_function func_block

    ID              shift and go to state 20


state 10

    (26) functions -> empty .

    $               reduce using rule 26 (functions -> empty .)
    IF              reduce using rule 26 (functions -> empty .)
    WHILE           reduce using rule 26 (functions -> empty .)
    FOR             reduce using rule 26 (functions -> empty .)
    PRINT           reduce using rule 26 (functions -> empty .)
    RETURN          reduce using rule 26 (functions -> empty .)
    STRING          reduce using rule 26 (functions -> empty .)
    READ            reduce using rule 26 (functions -> empty .)
    THIS            reduce using rule 26 (functions -> empty .)
    ID              reduce using rule 26 (functions -> empty .)
    (               reduce using rule 26 (functions -> empty .)
    TRUE            reduce using rule 26 (functions -> empty .)
    FALSE           reduce using rule 26 (functions -> empty .)
    FLOAT           reduce using rule 26 (functions -> empty .)
    INT             reduce using rule 26 (functions -> empty .)
    $end            reduce using rule 26 (functions -> empty .)
    }               reduce using rule 26 (functions -> empty .)


state 11

    (17) classes -> class classes .

    #               reduce using rule 17 (classes -> class classes .)
    $               reduce using rule 17 (classes -> class classes .)
    IF              reduce using rule 17 (classes -> class classes .)
    WHILE           reduce using rule 17 (classes -> class classes .)
    FOR             reduce using rule 17 (classes -> class classes .)
    PRINT           reduce using rule 17 (classes -> class classes .)
    RETURN          reduce using rule 17 (classes -> class classes .)
    STRING          reduce using rule 17 (classes -> class classes .)
    READ            reduce using rule 17 (classes -> class classes .)
    THIS            reduce using rule 17 (classes -> class classes .)
    ID              reduce using rule 17 (classes -> class classes .)
    (               reduce using rule 17 (classes -> class classes .)
    TRUE            reduce using rule 17 (classes -> class classes .)
    FALSE           reduce using rule 17 (classes -> class classes .)
    FLOAT           reduce using rule 17 (classes -> class classes .)
    INT             reduce using rule 17 (classes -> class classes .)
    $end            reduce using rule 17 (classes -> class classes .)


state 12

    (19) class -> @ ID inheritance . scope_class class_block
    (105) scope_class -> . empty
    (104) empty -> .

    {               reduce using rule 104 (empty -> .)

    scope_class                    shift and go to state 21
    empty                          shift and go to state 22

state 13

    (20) inheritance -> < . ID check_class >

    ID              shift and go to state 23


state 14

    (21) inheritance -> empty .

    {               reduce using rule 21 (inheritance -> empty .)


state 15

    (25) functions -> function functions .

    $               reduce using rule 25 (functions -> function functions .)
    IF              reduce using rule 25 (functions -> function functions .)
    WHILE           reduce using rule 25 (functions -> function functions .)
    FOR             reduce using rule 25 (functions -> function functions .)
    PRINT           reduce using rule 25 (functions -> function functions .)
    RETURN          reduce using rule 25 (functions -> function functions .)
    STRING          reduce using rule 25 (functions -> function functions .)
    READ            reduce using rule 25 (functions -> function functions .)
    THIS            reduce using rule 25 (functions -> function functions .)
    ID              reduce using rule 25 (functions -> function functions .)
    (               reduce using rule 25 (functions -> function functions .)
    TRUE            reduce using rule 25 (functions -> function functions .)
    FALSE           reduce using rule 25 (functions -> function functions .)
    FLOAT           reduce using rule 25 (functions -> function functions .)
    INT             reduce using rule 25 (functions -> function functions .)
    $end            reduce using rule 25 (functions -> function functions .)
    }               reduce using rule 25 (functions -> function functions .)


state 16

    (4) var -> $ . attr init ;
    (5) attr -> . ID : type

    ID              shift and go to state 24

    attr                           shift and go to state 25

state 17

    (1) program -> classes functions vars . statements
    (34) statements -> . statement
    (35) statements -> . empty
    (36) statement -> . if_block
    (37) statement -> . while_block
    (38) statement -> . for_block
    (39) statement -> . print_stmt
    (40) statement -> . expr
    (41) statement -> . return
    (104) empty -> .
    (47) if_block -> . IF ( exp ) block
    (48) if_block -> . IF ( exp ) block ELSE block
    (49) while_block -> . WHILE ( exp ) block
    (50) for_block -> . FOR number FOR_TO number SKIP number block
    (51) print_stmt -> . PRINT ( exp ) ;
    (57) expr -> . exp ;
    (52) return -> . RETURN exp ;
    (53) return -> . RETURN ;
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    $end            reduce using rule 104 (empty -> .)
    IF              shift and go to state 54
    WHILE           shift and go to state 31
    FOR             shift and go to state 49
    PRINT           shift and go to state 33
    RETURN          shift and go to state 34
    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    for_block                      shift and go to state 26
    statements                     shift and go to state 28
    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    read                           shift and go to state 40
    bool                           shift and go to state 41
    statement                      shift and go to state 42
    factor                         shift and go to state 43
    call                           shift and go to state 44
    math_exp                       shift and go to state 52
    empty                          shift and go to state 45
    logic_exp                      shift and go to state 46
    return                         shift and go to state 47
    print_stmt                     shift and go to state 50
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    expr                           shift and go to state 58
    if_block                       shift and go to state 59
    while_block                    shift and go to state 61
    exp                            shift and go to state 62
    assign                         shift and go to state 63

state 18

    (2) vars -> var . vars
    (2) vars -> . var vars
    (3) vars -> . empty
    (4) var -> . $ attr init ;
    (104) empty -> .

    $               shift and go to state 16
    IF              reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    PRINT           reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    STRING          reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    THIS            reduce using rule 104 (empty -> .)
    ID              reduce using rule 104 (empty -> .)
    (               reduce using rule 104 (empty -> .)
    TRUE            reduce using rule 104 (empty -> .)
    FALSE           reduce using rule 104 (empty -> .)
    FLOAT           reduce using rule 104 (empty -> .)
    INT             reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)
    ~               reduce using rule 104 (empty -> .)
    #               reduce using rule 104 (empty -> .)
    }               reduce using rule 104 (empty -> .)

    var                            shift and go to state 18
    empty                          shift and go to state 19
    vars                           shift and go to state 64

state 19

    (3) vars -> empty .

    ~               reduce using rule 3 (vars -> empty .)
    #               reduce using rule 3 (vars -> empty .)
    }               reduce using rule 3 (vars -> empty .)
    IF              reduce using rule 3 (vars -> empty .)
    WHILE           reduce using rule 3 (vars -> empty .)
    FOR             reduce using rule 3 (vars -> empty .)
    PRINT           reduce using rule 3 (vars -> empty .)
    RETURN          reduce using rule 3 (vars -> empty .)
    STRING          reduce using rule 3 (vars -> empty .)
    READ            reduce using rule 3 (vars -> empty .)
    THIS            reduce using rule 3 (vars -> empty .)
    ID              reduce using rule 3 (vars -> empty .)
    (               reduce using rule 3 (vars -> empty .)
    TRUE            reduce using rule 3 (vars -> empty .)
    FALSE           reduce using rule 3 (vars -> empty .)
    FLOAT           reduce using rule 3 (vars -> empty .)
    INT             reduce using rule 3 (vars -> empty .)
    $end            reduce using rule 3 (vars -> empty .)


state 20

    (27) function -> # ID . neg_lookup : return_type params scope_function func_block
    (112) neg_lookup -> . empty
    (104) empty -> .

    :               reduce using rule 104 (empty -> .)

    neg_lookup                     shift and go to state 65
    empty                          shift and go to state 66

state 21

    (19) class -> @ ID inheritance scope_class . class_block
    (22) class_block -> . { vars constructor functions }

    {               shift and go to state 68

    class_block                    shift and go to state 67

state 22

    (105) scope_class -> empty .

    {               reduce using rule 105 (scope_class -> empty .)


state 23

    (20) inheritance -> < ID . check_class >
    (109) check_class -> . empty
    (104) empty -> .

    >               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 69
    check_class                    shift and go to state 70

state 24

    (5) attr -> ID . : type

    :               shift and go to state 71


state 25

    (4) var -> $ attr . init ;
    (6) init -> . = exp
    (7) init -> . = NEW constructor_call
    (8) init -> . empty
    (104) empty -> .

    =               shift and go to state 73
    ;               reduce using rule 104 (empty -> .)

    init                           shift and go to state 72
    empty                          shift and go to state 74

state 26

    (38) statement -> for_block .

    }               reduce using rule 38 (statement -> for_block .)
    $end            reduce using rule 38 (statement -> for_block .)


state 27

    (55) number -> FLOAT .

    *               reduce using rule 55 (number -> FLOAT .)
    /               reduce using rule 55 (number -> FLOAT .)
    +               reduce using rule 55 (number -> FLOAT .)
    -               reduce using rule 55 (number -> FLOAT .)
    <               reduce using rule 55 (number -> FLOAT .)
    >               reduce using rule 55 (number -> FLOAT .)
    EQ              reduce using rule 55 (number -> FLOAT .)
    NE              reduce using rule 55 (number -> FLOAT .)
    AND             reduce using rule 55 (number -> FLOAT .)
    OR              reduce using rule 55 (number -> FLOAT .)
    ,               reduce using rule 55 (number -> FLOAT .)
    )               reduce using rule 55 (number -> FLOAT .)
    ;               reduce using rule 55 (number -> FLOAT .)
    {               reduce using rule 55 (number -> FLOAT .)
    SKIP            reduce using rule 55 (number -> FLOAT .)
    FOR_TO          reduce using rule 55 (number -> FLOAT .)


state 28

    (1) program -> classes functions vars statements .

    $end            reduce using rule 1 (program -> classes functions vars statements .)


state 29

    (62) read -> READ . ( string )

    (               shift and go to state 75


state 30

    (74) factor -> number .

    *               reduce using rule 74 (factor -> number .)
    /               reduce using rule 74 (factor -> number .)
    +               reduce using rule 74 (factor -> number .)
    -               reduce using rule 74 (factor -> number .)
    <               reduce using rule 74 (factor -> number .)
    >               reduce using rule 74 (factor -> number .)
    EQ              reduce using rule 74 (factor -> number .)
    NE              reduce using rule 74 (factor -> number .)
    AND             reduce using rule 74 (factor -> number .)
    OR              reduce using rule 74 (factor -> number .)
    ;               reduce using rule 74 (factor -> number .)
    )               reduce using rule 74 (factor -> number .)
    ,               reduce using rule 74 (factor -> number .)


state 31

    (49) while_block -> WHILE . ( exp ) block

    (               shift and go to state 76


state 32

    (95) call -> stack_call .

    *               reduce using rule 95 (call -> stack_call .)
    /               reduce using rule 95 (call -> stack_call .)
    +               reduce using rule 95 (call -> stack_call .)
    -               reduce using rule 95 (call -> stack_call .)
    <               reduce using rule 95 (call -> stack_call .)
    >               reduce using rule 95 (call -> stack_call .)
    EQ              reduce using rule 95 (call -> stack_call .)
    NE              reduce using rule 95 (call -> stack_call .)
    AND             reduce using rule 95 (call -> stack_call .)
    OR              reduce using rule 95 (call -> stack_call .)
    ,               reduce using rule 95 (call -> stack_call .)
    )               reduce using rule 95 (call -> stack_call .)
    ;               reduce using rule 95 (call -> stack_call .)


state 33

    (51) print_stmt -> PRINT . ( exp ) ;

    (               shift and go to state 77


state 34

    (52) return -> RETURN . exp ;
    (53) return -> RETURN . ;
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    ;               shift and go to state 78
    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    logic_exp                      shift and go to state 46
    read                           shift and go to state 40
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    exp                            shift and go to state 79
    assign                         shift and go to state 63

state 35

    (86) bool -> TRUE .

    AND             reduce using rule 86 (bool -> TRUE .)
    OR              reduce using rule 86 (bool -> TRUE .)
    )               reduce using rule 86 (bool -> TRUE .)
    ,               reduce using rule 86 (bool -> TRUE .)
    ;               reduce using rule 86 (bool -> TRUE .)


state 36

    (80) log_a -> log_b . log_a_alt
    (81) log_a_alt -> . AND log_b log_a_alt
    (82) log_a_alt -> . empty
    (104) empty -> .

    AND             shift and go to state 80
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 81
    log_a_alt                      shift and go to state 82

state 37

    (77) logic_exp -> log_a . logic_exp_alt
    (78) logic_exp_alt -> . OR log_a logic_exp_alt
    (79) logic_exp_alt -> . empty
    (104) empty -> .

    OR              shift and go to state 85
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    logic_exp_alt                  shift and go to state 83
    empty                          shift and go to state 84

state 38

    (83) log_b -> ( . logic_exp )
    (76) factor -> ( . math_exp )
    (77) logic_exp -> . log_a logic_exp_alt
    (65) math_exp -> . term math_exp_alt
    (80) log_a -> . log_b log_a_alt
    (69) term -> . factor term_alt
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (100) stack_call -> . ID . stack_method

    (               shift and go to state 38
    ID              shift and go to state 89
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60
    THIS            shift and go to state 57

    log_b                          shift and go to state 36
    comparison                     shift and go to state 55
    term                           shift and go to state 51
    log_a                          shift and go to state 37
    number                         shift and go to state 30
    prop                           shift and go to state 86
    stack_call                     shift and go to state 32
    bool                           shift and go to state 41
    math_exp                       shift and go to state 87
    factor                         shift and go to state 43
    call                           shift and go to state 44
    logic_exp                      shift and go to state 88

state 39

    (42) assign -> prop . = exp
    (94) call -> prop . ( args )

    =               shift and go to state 91
    (               shift and go to state 90


state 40

    (58) exp -> read .

    ;               reduce using rule 58 (exp -> read .)
    )               reduce using rule 58 (exp -> read .)
    ,               reduce using rule 58 (exp -> read .)


state 41

    (84) log_b -> bool .

    AND             reduce using rule 84 (log_b -> bool .)
    OR              reduce using rule 84 (log_b -> bool .)
    ,               reduce using rule 84 (log_b -> bool .)
    )               reduce using rule 84 (log_b -> bool .)
    ;               reduce using rule 84 (log_b -> bool .)


state 42

    (34) statements -> statement .

    }               reduce using rule 34 (statements -> statement .)
    $end            reduce using rule 34 (statements -> statement .)


state 43

    (69) term -> factor . term_alt
    (70) term_alt -> . * factor term_alt
    (71) term_alt -> . / factor term_alt
    (72) term_alt -> . empty
    (104) empty -> .

    *               shift and go to state 93
    /               shift and go to state 94
    +               reduce using rule 104 (empty -> .)
    -               reduce using rule 104 (empty -> .)
    <               reduce using rule 104 (empty -> .)
    >               reduce using rule 104 (empty -> .)
    EQ              reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 92
    term_alt                       shift and go to state 95

state 44

    (75) factor -> call .

    *               reduce using rule 75 (factor -> call .)
    /               reduce using rule 75 (factor -> call .)
    +               reduce using rule 75 (factor -> call .)
    -               reduce using rule 75 (factor -> call .)
    <               reduce using rule 75 (factor -> call .)
    >               reduce using rule 75 (factor -> call .)
    EQ              reduce using rule 75 (factor -> call .)
    NE              reduce using rule 75 (factor -> call .)
    AND             reduce using rule 75 (factor -> call .)
    OR              reduce using rule 75 (factor -> call .)
    ;               reduce using rule 75 (factor -> call .)
    )               reduce using rule 75 (factor -> call .)
    ,               reduce using rule 75 (factor -> call .)


state 45

    (35) statements -> empty .

    }               reduce using rule 35 (statements -> empty .)
    $end            reduce using rule 35 (statements -> empty .)


state 46

    (59) exp -> logic_exp .

    ;               reduce using rule 59 (exp -> logic_exp .)
    )               reduce using rule 59 (exp -> logic_exp .)
    ,               reduce using rule 59 (exp -> logic_exp .)


state 47

    (41) statement -> return .

    }               reduce using rule 41 (statement -> return .)
    $end            reduce using rule 41 (statement -> return .)


state 48

    (61) exp -> STRING .

    ;               reduce using rule 61 (exp -> STRING .)
    )               reduce using rule 61 (exp -> STRING .)
    ,               reduce using rule 61 (exp -> STRING .)


state 49

    (50) for_block -> FOR . number FOR_TO number SKIP number block
    (55) number -> . FLOAT
    (56) number -> . INT

    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 96

state 50

    (39) statement -> print_stmt .

    }               reduce using rule 39 (statement -> print_stmt .)
    $end            reduce using rule 39 (statement -> print_stmt .)


state 51

    (65) math_exp -> term . math_exp_alt
    (66) math_exp_alt -> . + term math_exp_alt
    (67) math_exp_alt -> . - term math_exp_alt
    (68) math_exp_alt -> . empty
    (104) empty -> .

    +               shift and go to state 100
    -               shift and go to state 97
    <               reduce using rule 104 (empty -> .)
    >               reduce using rule 104 (empty -> .)
    EQ              reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    math_exp_alt                   shift and go to state 98
    empty                          shift and go to state 99

state 52

    (88) comparison -> math_exp . comparison_op math_exp
    (89) comparison -> math_exp .
    (90) comparison_op -> . <
    (91) comparison_op -> . >
    (92) comparison_op -> . EQ
    (93) comparison_op -> . NE

    AND             reduce using rule 89 (comparison -> math_exp .)
    OR              reduce using rule 89 (comparison -> math_exp .)
    ;               reduce using rule 89 (comparison -> math_exp .)
    )               reduce using rule 89 (comparison -> math_exp .)
    ,               reduce using rule 89 (comparison -> math_exp .)
    <               shift and go to state 104
    >               shift and go to state 105
    EQ              shift and go to state 103
    NE              shift and go to state 102

    comparison_op                  shift and go to state 101

state 53

    (45) prop -> ID . . ID
    (46) prop -> ID .
    (73) factor -> ID . check_number
    (100) stack_call -> ID . . stack_method
    (111) check_number -> . empty
    (104) empty -> .

    .               shift and go to state 108
    =               reduce using rule 46 (prop -> ID .)
    (               reduce using rule 46 (prop -> ID .)
    *               reduce using rule 104 (empty -> .)
    /               reduce using rule 104 (empty -> .)
    +               reduce using rule 104 (empty -> .)
    -               reduce using rule 104 (empty -> .)
    <               reduce using rule 104 (empty -> .)
    >               reduce using rule 104 (empty -> .)
    EQ              reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    check_number                   shift and go to state 106
    empty                          shift and go to state 107

state 54

    (47) if_block -> IF . ( exp ) block
    (48) if_block -> IF . ( exp ) block ELSE block

    (               shift and go to state 109


state 55

    (85) log_b -> comparison .

    AND             reduce using rule 85 (log_b -> comparison .)
    OR              reduce using rule 85 (log_b -> comparison .)
    ,               reduce using rule 85 (log_b -> comparison .)
    )               reduce using rule 85 (log_b -> comparison .)
    ;               reduce using rule 85 (log_b -> comparison .)


state 56

    (87) bool -> FALSE .

    AND             reduce using rule 87 (bool -> FALSE .)
    OR              reduce using rule 87 (bool -> FALSE .)
    )               reduce using rule 87 (bool -> FALSE .)
    ,               reduce using rule 87 (bool -> FALSE .)
    ;               reduce using rule 87 (bool -> FALSE .)


state 57

    (44) prop -> THIS . . ID

    .               shift and go to state 110


state 58

    (40) statement -> expr .

    }               reduce using rule 40 (statement -> expr .)
    $end            reduce using rule 40 (statement -> expr .)


state 59

    (36) statement -> if_block .

    }               reduce using rule 36 (statement -> if_block .)
    $end            reduce using rule 36 (statement -> if_block .)


state 60

    (56) number -> INT .

    *               reduce using rule 56 (number -> INT .)
    /               reduce using rule 56 (number -> INT .)
    +               reduce using rule 56 (number -> INT .)
    -               reduce using rule 56 (number -> INT .)
    <               reduce using rule 56 (number -> INT .)
    >               reduce using rule 56 (number -> INT .)
    EQ              reduce using rule 56 (number -> INT .)
    NE              reduce using rule 56 (number -> INT .)
    AND             reduce using rule 56 (number -> INT .)
    OR              reduce using rule 56 (number -> INT .)
    ,               reduce using rule 56 (number -> INT .)
    )               reduce using rule 56 (number -> INT .)
    ;               reduce using rule 56 (number -> INT .)
    {               reduce using rule 56 (number -> INT .)
    SKIP            reduce using rule 56 (number -> INT .)
    FOR_TO          reduce using rule 56 (number -> INT .)


state 61

    (37) statement -> while_block .

    }               reduce using rule 37 (statement -> while_block .)
    $end            reduce using rule 37 (statement -> while_block .)


state 62

    (57) expr -> exp . ;

    ;               shift and go to state 111


state 63

    (60) exp -> assign .

    ;               reduce using rule 60 (exp -> assign .)
    )               reduce using rule 60 (exp -> assign .)
    ,               reduce using rule 60 (exp -> assign .)


state 64

    (2) vars -> var vars .

    ~               reduce using rule 2 (vars -> var vars .)
    #               reduce using rule 2 (vars -> var vars .)
    }               reduce using rule 2 (vars -> var vars .)
    IF              reduce using rule 2 (vars -> var vars .)
    WHILE           reduce using rule 2 (vars -> var vars .)
    FOR             reduce using rule 2 (vars -> var vars .)
    PRINT           reduce using rule 2 (vars -> var vars .)
    RETURN          reduce using rule 2 (vars -> var vars .)
    STRING          reduce using rule 2 (vars -> var vars .)
    READ            reduce using rule 2 (vars -> var vars .)
    THIS            reduce using rule 2 (vars -> var vars .)
    ID              reduce using rule 2 (vars -> var vars .)
    (               reduce using rule 2 (vars -> var vars .)
    TRUE            reduce using rule 2 (vars -> var vars .)
    FALSE           reduce using rule 2 (vars -> var vars .)
    FLOAT           reduce using rule 2 (vars -> var vars .)
    INT             reduce using rule 2 (vars -> var vars .)
    $end            reduce using rule 2 (vars -> var vars .)


state 65

    (27) function -> # ID neg_lookup . : return_type params scope_function func_block

    :               shift and go to state 112


state 66

    (112) neg_lookup -> empty .

    :               reduce using rule 112 (neg_lookup -> empty .)


state 67

    (19) class -> @ ID inheritance scope_class class_block .

    @               reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    #               reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    $               reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    IF              reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    WHILE           reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    FOR             reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    PRINT           reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    RETURN          reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    STRING          reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    READ            reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    THIS            reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    ID              reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    (               reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    TRUE            reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    FALSE           reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    FLOAT           reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    INT             reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    $end            reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)


state 68

    (22) class_block -> { . vars constructor functions }
    (2) vars -> . var vars
    (3) vars -> . empty
    (4) var -> . $ attr init ;
    (104) empty -> .

    $               shift and go to state 16
    ~               reduce using rule 104 (empty -> .)
    #               reduce using rule 104 (empty -> .)
    }               reduce using rule 104 (empty -> .)

    vars                           shift and go to state 113
    var                            shift and go to state 18
    empty                          shift and go to state 19

state 69

    (109) check_class -> empty .

    =               reduce using rule 109 (check_class -> empty .)
    ;               reduce using rule 109 (check_class -> empty .)
    ,               reduce using rule 109 (check_class -> empty .)
    )               reduce using rule 109 (check_class -> empty .)
    (               reduce using rule 109 (check_class -> empty .)
    >               reduce using rule 109 (check_class -> empty .)


state 70

    (20) inheritance -> < ID check_class . >

    >               shift and go to state 114


state 71

    (5) attr -> ID : . type
    (9) type -> . INT_TYPE
    (10) type -> . FLOAT_TYPE
    (11) type -> . STRING_TYPE
    (12) type -> . BOOLEAN_TYPE
    (13) type -> . STACK
    (14) type -> . ID check_class

    INT_TYPE        shift and go to state 119
    FLOAT_TYPE      shift and go to state 115
    STRING_TYPE     shift and go to state 117
    BOOLEAN_TYPE    shift and go to state 116
    STACK           shift and go to state 118
    ID              shift and go to state 121

    type                           shift and go to state 120

state 72

    (4) var -> $ attr init . ;

    ;               shift and go to state 122


state 73

    (6) init -> = . exp
    (7) init -> = . NEW constructor_call
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    NEW             shift and go to state 123
    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    logic_exp                      shift and go to state 46
    read                           shift and go to state 40
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    exp                            shift and go to state 124
    assign                         shift and go to state 63

state 74

    (8) init -> empty .

    ;               reduce using rule 8 (init -> empty .)


state 75

    (62) read -> READ ( . string )
    (63) string -> . ID check_string
    (64) string -> . STRING

    ID              shift and go to state 126
    STRING          shift and go to state 127

    string                         shift and go to state 125

state 76

    (49) while_block -> WHILE ( . exp ) block
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    logic_exp                      shift and go to state 46
    read                           shift and go to state 40
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    exp                            shift and go to state 128
    assign                         shift and go to state 63

state 77

    (51) print_stmt -> PRINT ( . exp ) ;
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    logic_exp                      shift and go to state 46
    read                           shift and go to state 40
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    exp                            shift and go to state 129
    assign                         shift and go to state 63

state 78

    (53) return -> RETURN ; .

    $end            reduce using rule 53 (return -> RETURN ; .)
    }               reduce using rule 53 (return -> RETURN ; .)


state 79

    (52) return -> RETURN exp . ;

    ;               shift and go to state 130


state 80

    (81) log_a_alt -> AND . log_b log_a_alt
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (100) stack_call -> . ID . stack_method

    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    ID              shift and go to state 89
    FLOAT           shift and go to state 27
    INT             shift and go to state 60
    THIS            shift and go to state 57

    log_b                          shift and go to state 131
    comparison                     shift and go to state 55
    term                           shift and go to state 51
    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    prop                           shift and go to state 86

state 81

    (82) log_a_alt -> empty .

    OR              reduce using rule 82 (log_a_alt -> empty .)
    ;               reduce using rule 82 (log_a_alt -> empty .)
    )               reduce using rule 82 (log_a_alt -> empty .)
    ,               reduce using rule 82 (log_a_alt -> empty .)


state 82

    (80) log_a -> log_b log_a_alt .

    OR              reduce using rule 80 (log_a -> log_b log_a_alt .)
    )               reduce using rule 80 (log_a -> log_b log_a_alt .)
    ;               reduce using rule 80 (log_a -> log_b log_a_alt .)
    ,               reduce using rule 80 (log_a -> log_b log_a_alt .)


state 83

    (77) logic_exp -> log_a logic_exp_alt .

    ;               reduce using rule 77 (logic_exp -> log_a logic_exp_alt .)
    ,               reduce using rule 77 (logic_exp -> log_a logic_exp_alt .)
    )               reduce using rule 77 (logic_exp -> log_a logic_exp_alt .)


state 84

    (79) logic_exp_alt -> empty .

    ;               reduce using rule 79 (logic_exp_alt -> empty .)
    )               reduce using rule 79 (logic_exp_alt -> empty .)
    ,               reduce using rule 79 (logic_exp_alt -> empty .)


state 85

    (78) logic_exp_alt -> OR . log_a logic_exp_alt
    (80) log_a -> . log_b log_a_alt
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (100) stack_call -> . ID . stack_method

    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    ID              shift and go to state 89
    FLOAT           shift and go to state 27
    INT             shift and go to state 60
    THIS            shift and go to state 57

    log_b                          shift and go to state 36
    comparison                     shift and go to state 55
    log_a                          shift and go to state 132
    term                           shift and go to state 51
    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    prop                           shift and go to state 86

state 86

    (94) call -> prop . ( args )

    (               shift and go to state 90


state 87

    (76) factor -> ( math_exp . )
    (88) comparison -> math_exp . comparison_op math_exp
    (89) comparison -> math_exp .
    (90) comparison_op -> . <
    (91) comparison_op -> . >
    (92) comparison_op -> . EQ
    (93) comparison_op -> . NE

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 133
    AND             reduce using rule 89 (comparison -> math_exp .)
    OR              reduce using rule 89 (comparison -> math_exp .)
    <               shift and go to state 104
    >               shift and go to state 105
    EQ              shift and go to state 103
    NE              shift and go to state 102

  ! )               [ reduce using rule 89 (comparison -> math_exp .) ]

    comparison_op                  shift and go to state 101

state 88

    (83) log_b -> ( logic_exp . )

    )               shift and go to state 134


state 89

    (73) factor -> ID . check_number
    (45) prop -> ID . . ID
    (46) prop -> ID .
    (100) stack_call -> ID . . stack_method
    (111) check_number -> . empty
    (104) empty -> .

    .               shift and go to state 108
    (               reduce using rule 46 (prop -> ID .)
    *               reduce using rule 104 (empty -> .)
    /               reduce using rule 104 (empty -> .)
    +               reduce using rule 104 (empty -> .)
    -               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    <               reduce using rule 104 (empty -> .)
    >               reduce using rule 104 (empty -> .)
    EQ              reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    check_number                   shift and go to state 106
    empty                          shift and go to state 107

state 90

    (94) call -> prop ( . args )
    (96) args -> . exp args_aux
    (97) args -> . empty
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (104) empty -> .
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    STRING          shift and go to state 48
    )               reduce using rule 104 (empty -> .)
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    empty                          shift and go to state 135
    logic_exp                      shift and go to state 46
    read                           shift and go to state 40
    args                           shift and go to state 136
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    exp                            shift and go to state 137
    assign                         shift and go to state 63

state 91

    (42) assign -> prop = . exp
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    logic_exp                      shift and go to state 46
    read                           shift and go to state 40
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    exp                            shift and go to state 138
    assign                         shift and go to state 63

state 92

    (72) term_alt -> empty .

    +               reduce using rule 72 (term_alt -> empty .)
    -               reduce using rule 72 (term_alt -> empty .)
    <               reduce using rule 72 (term_alt -> empty .)
    >               reduce using rule 72 (term_alt -> empty .)
    EQ              reduce using rule 72 (term_alt -> empty .)
    NE              reduce using rule 72 (term_alt -> empty .)
    AND             reduce using rule 72 (term_alt -> empty .)
    OR              reduce using rule 72 (term_alt -> empty .)
    ;               reduce using rule 72 (term_alt -> empty .)
    )               reduce using rule 72 (term_alt -> empty .)
    ,               reduce using rule 72 (term_alt -> empty .)


state 93

    (70) term_alt -> * . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (100) stack_call -> . ID . stack_method

    ID              shift and go to state 89
    (               shift and go to state 139
    FLOAT           shift and go to state 27
    INT             shift and go to state 60
    THIS            shift and go to state 57

    number                         shift and go to state 30
    prop                           shift and go to state 86
    call                           shift and go to state 44
    factor                         shift and go to state 140
    stack_call                     shift and go to state 32

state 94

    (71) term_alt -> / . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (100) stack_call -> . ID . stack_method

    ID              shift and go to state 89
    (               shift and go to state 139
    FLOAT           shift and go to state 27
    INT             shift and go to state 60
    THIS            shift and go to state 57

    number                         shift and go to state 30
    prop                           shift and go to state 86
    call                           shift and go to state 44
    factor                         shift and go to state 141
    stack_call                     shift and go to state 32

state 95

    (69) term -> factor term_alt .

    +               reduce using rule 69 (term -> factor term_alt .)
    -               reduce using rule 69 (term -> factor term_alt .)
    <               reduce using rule 69 (term -> factor term_alt .)
    >               reduce using rule 69 (term -> factor term_alt .)
    EQ              reduce using rule 69 (term -> factor term_alt .)
    NE              reduce using rule 69 (term -> factor term_alt .)
    AND             reduce using rule 69 (term -> factor term_alt .)
    OR              reduce using rule 69 (term -> factor term_alt .)
    ;               reduce using rule 69 (term -> factor term_alt .)
    )               reduce using rule 69 (term -> factor term_alt .)
    ,               reduce using rule 69 (term -> factor term_alt .)


state 96

    (50) for_block -> FOR number . FOR_TO number SKIP number block

    FOR_TO          shift and go to state 142


state 97

    (67) math_exp_alt -> - . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (100) stack_call -> . ID . stack_method

    ID              shift and go to state 89
    (               shift and go to state 139
    FLOAT           shift and go to state 27
    INT             shift and go to state 60
    THIS            shift and go to state 57

    term                           shift and go to state 143
    number                         shift and go to state 30
    prop                           shift and go to state 86
    call                           shift and go to state 44
    factor                         shift and go to state 43
    stack_call                     shift and go to state 32

state 98

    (65) math_exp -> term math_exp_alt .

    <               reduce using rule 65 (math_exp -> term math_exp_alt .)
    >               reduce using rule 65 (math_exp -> term math_exp_alt .)
    EQ              reduce using rule 65 (math_exp -> term math_exp_alt .)
    NE              reduce using rule 65 (math_exp -> term math_exp_alt .)
    AND             reduce using rule 65 (math_exp -> term math_exp_alt .)
    OR              reduce using rule 65 (math_exp -> term math_exp_alt .)
    ;               reduce using rule 65 (math_exp -> term math_exp_alt .)
    )               reduce using rule 65 (math_exp -> term math_exp_alt .)
    ,               reduce using rule 65 (math_exp -> term math_exp_alt .)


state 99

    (68) math_exp_alt -> empty .

    <               reduce using rule 68 (math_exp_alt -> empty .)
    >               reduce using rule 68 (math_exp_alt -> empty .)
    EQ              reduce using rule 68 (math_exp_alt -> empty .)
    NE              reduce using rule 68 (math_exp_alt -> empty .)
    AND             reduce using rule 68 (math_exp_alt -> empty .)
    OR              reduce using rule 68 (math_exp_alt -> empty .)
    ;               reduce using rule 68 (math_exp_alt -> empty .)
    )               reduce using rule 68 (math_exp_alt -> empty .)
    ,               reduce using rule 68 (math_exp_alt -> empty .)


state 100

    (66) math_exp_alt -> + . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (100) stack_call -> . ID . stack_method

    ID              shift and go to state 89
    (               shift and go to state 139
    FLOAT           shift and go to state 27
    INT             shift and go to state 60
    THIS            shift and go to state 57

    term                           shift and go to state 144
    number                         shift and go to state 30
    prop                           shift and go to state 86
    call                           shift and go to state 44
    factor                         shift and go to state 43
    stack_call                     shift and go to state 32

state 101

    (88) comparison -> math_exp comparison_op . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (100) stack_call -> . ID . stack_method

    ID              shift and go to state 89
    (               shift and go to state 139
    FLOAT           shift and go to state 27
    INT             shift and go to state 60
    THIS            shift and go to state 57

    term                           shift and go to state 51
    number                         shift and go to state 30
    call                           shift and go to state 44
    math_exp                       shift and go to state 145
    factor                         shift and go to state 43
    stack_call                     shift and go to state 32
    prop                           shift and go to state 86

state 102

    (93) comparison_op -> NE .

    ID              reduce using rule 93 (comparison_op -> NE .)
    (               reduce using rule 93 (comparison_op -> NE .)
    FLOAT           reduce using rule 93 (comparison_op -> NE .)
    INT             reduce using rule 93 (comparison_op -> NE .)
    THIS            reduce using rule 93 (comparison_op -> NE .)


state 103

    (92) comparison_op -> EQ .

    ID              reduce using rule 92 (comparison_op -> EQ .)
    (               reduce using rule 92 (comparison_op -> EQ .)
    FLOAT           reduce using rule 92 (comparison_op -> EQ .)
    INT             reduce using rule 92 (comparison_op -> EQ .)
    THIS            reduce using rule 92 (comparison_op -> EQ .)


state 104

    (90) comparison_op -> < .

    ID              reduce using rule 90 (comparison_op -> < .)
    (               reduce using rule 90 (comparison_op -> < .)
    FLOAT           reduce using rule 90 (comparison_op -> < .)
    INT             reduce using rule 90 (comparison_op -> < .)
    THIS            reduce using rule 90 (comparison_op -> < .)


state 105

    (91) comparison_op -> > .

    ID              reduce using rule 91 (comparison_op -> > .)
    (               reduce using rule 91 (comparison_op -> > .)
    FLOAT           reduce using rule 91 (comparison_op -> > .)
    INT             reduce using rule 91 (comparison_op -> > .)
    THIS            reduce using rule 91 (comparison_op -> > .)


state 106

    (73) factor -> ID check_number .

    *               reduce using rule 73 (factor -> ID check_number .)
    /               reduce using rule 73 (factor -> ID check_number .)
    +               reduce using rule 73 (factor -> ID check_number .)
    -               reduce using rule 73 (factor -> ID check_number .)
    <               reduce using rule 73 (factor -> ID check_number .)
    >               reduce using rule 73 (factor -> ID check_number .)
    EQ              reduce using rule 73 (factor -> ID check_number .)
    NE              reduce using rule 73 (factor -> ID check_number .)
    AND             reduce using rule 73 (factor -> ID check_number .)
    OR              reduce using rule 73 (factor -> ID check_number .)
    ;               reduce using rule 73 (factor -> ID check_number .)
    )               reduce using rule 73 (factor -> ID check_number .)
    ,               reduce using rule 73 (factor -> ID check_number .)


state 107

    (111) check_number -> empty .

    *               reduce using rule 111 (check_number -> empty .)
    /               reduce using rule 111 (check_number -> empty .)
    +               reduce using rule 111 (check_number -> empty .)
    -               reduce using rule 111 (check_number -> empty .)
    )               reduce using rule 111 (check_number -> empty .)
    <               reduce using rule 111 (check_number -> empty .)
    >               reduce using rule 111 (check_number -> empty .)
    EQ              reduce using rule 111 (check_number -> empty .)
    NE              reduce using rule 111 (check_number -> empty .)
    AND             reduce using rule 111 (check_number -> empty .)
    OR              reduce using rule 111 (check_number -> empty .)
    ;               reduce using rule 111 (check_number -> empty .)
    ,               reduce using rule 111 (check_number -> empty .)


state 108

    (45) prop -> ID . . ID
    (100) stack_call -> ID . . stack_method
    (101) stack_method -> . POP ( )
    (102) stack_method -> . PUSH ( ID check_variable )
    (103) stack_method -> . PEEK ( )

    ID              shift and go to state 150
    POP             shift and go to state 148
    PUSH            shift and go to state 149
    PEEK            shift and go to state 146

    stack_method                   shift and go to state 147

state 109

    (47) if_block -> IF ( . exp ) block
    (48) if_block -> IF ( . exp ) block ELSE block
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    logic_exp                      shift and go to state 46
    read                           shift and go to state 40
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    exp                            shift and go to state 151
    assign                         shift and go to state 63

state 110

    (44) prop -> THIS . . ID

    ID              shift and go to state 152


state 111

    (57) expr -> exp ; .

    }               reduce using rule 57 (expr -> exp ; .)
    $end            reduce using rule 57 (expr -> exp ; .)


state 112

    (27) function -> # ID neg_lookup : . return_type params scope_function func_block
    (15) return_type -> . VOID
    (16) return_type -> . type
    (9) type -> . INT_TYPE
    (10) type -> . FLOAT_TYPE
    (11) type -> . STRING_TYPE
    (12) type -> . BOOLEAN_TYPE
    (13) type -> . STACK
    (14) type -> . ID check_class

    VOID            shift and go to state 153
    INT_TYPE        shift and go to state 119
    FLOAT_TYPE      shift and go to state 115
    STRING_TYPE     shift and go to state 117
    BOOLEAN_TYPE    shift and go to state 116
    STACK           shift and go to state 118
    ID              shift and go to state 121

    return_type                    shift and go to state 154
    type                           shift and go to state 155

state 113

    (22) class_block -> { vars . constructor functions }
    (23) constructor -> . ~ ID params scope_constructor func_block
    (24) constructor -> . empty
    (104) empty -> .

    ~               shift and go to state 158
    #               reduce using rule 104 (empty -> .)
    }               reduce using rule 104 (empty -> .)

    constructor                    shift and go to state 156
    empty                          shift and go to state 157

state 114

    (20) inheritance -> < ID check_class > .

    {               reduce using rule 20 (inheritance -> < ID check_class > .)


state 115

    (10) type -> FLOAT_TYPE .

    (               reduce using rule 10 (type -> FLOAT_TYPE .)
    =               reduce using rule 10 (type -> FLOAT_TYPE .)
    ;               reduce using rule 10 (type -> FLOAT_TYPE .)
    ,               reduce using rule 10 (type -> FLOAT_TYPE .)
    )               reduce using rule 10 (type -> FLOAT_TYPE .)


state 116

    (12) type -> BOOLEAN_TYPE .

    (               reduce using rule 12 (type -> BOOLEAN_TYPE .)
    =               reduce using rule 12 (type -> BOOLEAN_TYPE .)
    ;               reduce using rule 12 (type -> BOOLEAN_TYPE .)
    ,               reduce using rule 12 (type -> BOOLEAN_TYPE .)
    )               reduce using rule 12 (type -> BOOLEAN_TYPE .)


state 117

    (11) type -> STRING_TYPE .

    (               reduce using rule 11 (type -> STRING_TYPE .)
    =               reduce using rule 11 (type -> STRING_TYPE .)
    ;               reduce using rule 11 (type -> STRING_TYPE .)
    ,               reduce using rule 11 (type -> STRING_TYPE .)
    )               reduce using rule 11 (type -> STRING_TYPE .)


state 118

    (13) type -> STACK .

    (               reduce using rule 13 (type -> STACK .)
    =               reduce using rule 13 (type -> STACK .)
    ;               reduce using rule 13 (type -> STACK .)
    ,               reduce using rule 13 (type -> STACK .)
    )               reduce using rule 13 (type -> STACK .)


state 119

    (9) type -> INT_TYPE .

    (               reduce using rule 9 (type -> INT_TYPE .)
    =               reduce using rule 9 (type -> INT_TYPE .)
    ;               reduce using rule 9 (type -> INT_TYPE .)
    ,               reduce using rule 9 (type -> INT_TYPE .)
    )               reduce using rule 9 (type -> INT_TYPE .)


state 120

    (5) attr -> ID : type .

    =               reduce using rule 5 (attr -> ID : type .)
    ;               reduce using rule 5 (attr -> ID : type .)
    ,               reduce using rule 5 (attr -> ID : type .)
    )               reduce using rule 5 (attr -> ID : type .)


state 121

    (14) type -> ID . check_class
    (109) check_class -> . empty
    (104) empty -> .

    =               reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    (               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 69
    check_class                    shift and go to state 159

state 122

    (4) var -> $ attr init ; .

    $               reduce using rule 4 (var -> $ attr init ; .)
    ~               reduce using rule 4 (var -> $ attr init ; .)
    #               reduce using rule 4 (var -> $ attr init ; .)
    }               reduce using rule 4 (var -> $ attr init ; .)
    IF              reduce using rule 4 (var -> $ attr init ; .)
    WHILE           reduce using rule 4 (var -> $ attr init ; .)
    FOR             reduce using rule 4 (var -> $ attr init ; .)
    PRINT           reduce using rule 4 (var -> $ attr init ; .)
    RETURN          reduce using rule 4 (var -> $ attr init ; .)
    STRING          reduce using rule 4 (var -> $ attr init ; .)
    READ            reduce using rule 4 (var -> $ attr init ; .)
    THIS            reduce using rule 4 (var -> $ attr init ; .)
    ID              reduce using rule 4 (var -> $ attr init ; .)
    (               reduce using rule 4 (var -> $ attr init ; .)
    TRUE            reduce using rule 4 (var -> $ attr init ; .)
    FALSE           reduce using rule 4 (var -> $ attr init ; .)
    FLOAT           reduce using rule 4 (var -> $ attr init ; .)
    INT             reduce using rule 4 (var -> $ attr init ; .)
    $end            reduce using rule 4 (var -> $ attr init ; .)


state 123

    (7) init -> = NEW . constructor_call
    (43) constructor_call -> . ID ( args )

    ID              shift and go to state 161

    constructor_call               shift and go to state 160

state 124

    (6) init -> = exp .

    ;               reduce using rule 6 (init -> = exp .)


state 125

    (62) read -> READ ( string . )

    )               shift and go to state 162


state 126

    (63) string -> ID . check_string
    (110) check_string -> . empty
    (104) empty -> .

    )               reduce using rule 104 (empty -> .)

    check_string                   shift and go to state 163
    empty                          shift and go to state 164

state 127

    (64) string -> STRING .

    )               reduce using rule 64 (string -> STRING .)


state 128

    (49) while_block -> WHILE ( exp . ) block

    )               shift and go to state 165


state 129

    (51) print_stmt -> PRINT ( exp . ) ;

    )               shift and go to state 166


state 130

    (52) return -> RETURN exp ; .

    $end            reduce using rule 52 (return -> RETURN exp ; .)
    }               reduce using rule 52 (return -> RETURN exp ; .)


state 131

    (81) log_a_alt -> AND log_b . log_a_alt
    (81) log_a_alt -> . AND log_b log_a_alt
    (82) log_a_alt -> . empty
    (104) empty -> .

    AND             shift and go to state 80
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 81
    log_a_alt                      shift and go to state 167

state 132

    (78) logic_exp_alt -> OR log_a . logic_exp_alt
    (78) logic_exp_alt -> . OR log_a logic_exp_alt
    (79) logic_exp_alt -> . empty
    (104) empty -> .

    OR              shift and go to state 85
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    logic_exp_alt                  shift and go to state 168
    empty                          shift and go to state 84

state 133

    (76) factor -> ( math_exp ) .

    *               reduce using rule 76 (factor -> ( math_exp ) .)
    /               reduce using rule 76 (factor -> ( math_exp ) .)
    +               reduce using rule 76 (factor -> ( math_exp ) .)
    -               reduce using rule 76 (factor -> ( math_exp ) .)
    <               reduce using rule 76 (factor -> ( math_exp ) .)
    >               reduce using rule 76 (factor -> ( math_exp ) .)
    EQ              reduce using rule 76 (factor -> ( math_exp ) .)
    NE              reduce using rule 76 (factor -> ( math_exp ) .)
    AND             reduce using rule 76 (factor -> ( math_exp ) .)
    OR              reduce using rule 76 (factor -> ( math_exp ) .)
    ;               reduce using rule 76 (factor -> ( math_exp ) .)
    )               reduce using rule 76 (factor -> ( math_exp ) .)
    ,               reduce using rule 76 (factor -> ( math_exp ) .)


state 134

    (83) log_b -> ( logic_exp ) .

    AND             reduce using rule 83 (log_b -> ( logic_exp ) .)
    OR              reduce using rule 83 (log_b -> ( logic_exp ) .)
    ,               reduce using rule 83 (log_b -> ( logic_exp ) .)
    )               reduce using rule 83 (log_b -> ( logic_exp ) .)
    ;               reduce using rule 83 (log_b -> ( logic_exp ) .)


state 135

    (97) args -> empty .

    )               reduce using rule 97 (args -> empty .)


state 136

    (94) call -> prop ( args . )

    )               shift and go to state 169


state 137

    (96) args -> exp . args_aux
    (98) args_aux -> . , exp args_aux
    (99) args_aux -> . empty
    (104) empty -> .

    ,               shift and go to state 172
    )               reduce using rule 104 (empty -> .)

    args_aux                       shift and go to state 170
    empty                          shift and go to state 171

state 138

    (42) assign -> prop = exp .

    ;               reduce using rule 42 (assign -> prop = exp .)
    )               reduce using rule 42 (assign -> prop = exp .)
    ,               reduce using rule 42 (assign -> prop = exp .)


state 139

    (76) factor -> ( . math_exp )
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (100) stack_call -> . ID . stack_method

    ID              shift and go to state 89
    (               shift and go to state 139
    FLOAT           shift and go to state 27
    INT             shift and go to state 60
    THIS            shift and go to state 57

    term                           shift and go to state 51
    number                         shift and go to state 30
    prop                           shift and go to state 86
    call                           shift and go to state 44
    math_exp                       shift and go to state 173
    factor                         shift and go to state 43
    stack_call                     shift and go to state 32

state 140

    (70) term_alt -> * factor . term_alt
    (70) term_alt -> . * factor term_alt
    (71) term_alt -> . / factor term_alt
    (72) term_alt -> . empty
    (104) empty -> .

    *               shift and go to state 93
    /               shift and go to state 94
    +               reduce using rule 104 (empty -> .)
    -               reduce using rule 104 (empty -> .)
    <               reduce using rule 104 (empty -> .)
    >               reduce using rule 104 (empty -> .)
    EQ              reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 92
    term_alt                       shift and go to state 174

state 141

    (71) term_alt -> / factor . term_alt
    (70) term_alt -> . * factor term_alt
    (71) term_alt -> . / factor term_alt
    (72) term_alt -> . empty
    (104) empty -> .

    *               shift and go to state 93
    /               shift and go to state 94
    +               reduce using rule 104 (empty -> .)
    -               reduce using rule 104 (empty -> .)
    <               reduce using rule 104 (empty -> .)
    >               reduce using rule 104 (empty -> .)
    EQ              reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 92
    term_alt                       shift and go to state 175

state 142

    (50) for_block -> FOR number FOR_TO . number SKIP number block
    (55) number -> . FLOAT
    (56) number -> . INT

    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 176

state 143

    (67) math_exp_alt -> - term . math_exp_alt
    (66) math_exp_alt -> . + term math_exp_alt
    (67) math_exp_alt -> . - term math_exp_alt
    (68) math_exp_alt -> . empty
    (104) empty -> .

    +               shift and go to state 100
    -               shift and go to state 97
    <               reduce using rule 104 (empty -> .)
    >               reduce using rule 104 (empty -> .)
    EQ              reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    math_exp_alt                   shift and go to state 177
    empty                          shift and go to state 99

state 144

    (66) math_exp_alt -> + term . math_exp_alt
    (66) math_exp_alt -> . + term math_exp_alt
    (67) math_exp_alt -> . - term math_exp_alt
    (68) math_exp_alt -> . empty
    (104) empty -> .

    +               shift and go to state 100
    -               shift and go to state 97
    <               reduce using rule 104 (empty -> .)
    >               reduce using rule 104 (empty -> .)
    EQ              reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    ;               reduce using rule 104 (empty -> .)
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    math_exp_alt                   shift and go to state 178
    empty                          shift and go to state 99

state 145

    (88) comparison -> math_exp comparison_op math_exp .

    AND             reduce using rule 88 (comparison -> math_exp comparison_op math_exp .)
    OR              reduce using rule 88 (comparison -> math_exp comparison_op math_exp .)
    ;               reduce using rule 88 (comparison -> math_exp comparison_op math_exp .)
    )               reduce using rule 88 (comparison -> math_exp comparison_op math_exp .)
    ,               reduce using rule 88 (comparison -> math_exp comparison_op math_exp .)


state 146

    (103) stack_method -> PEEK . ( )

    (               shift and go to state 179


state 147

    (100) stack_call -> ID . stack_method .

    *               reduce using rule 100 (stack_call -> ID . stack_method .)
    /               reduce using rule 100 (stack_call -> ID . stack_method .)
    +               reduce using rule 100 (stack_call -> ID . stack_method .)
    -               reduce using rule 100 (stack_call -> ID . stack_method .)
    <               reduce using rule 100 (stack_call -> ID . stack_method .)
    >               reduce using rule 100 (stack_call -> ID . stack_method .)
    EQ              reduce using rule 100 (stack_call -> ID . stack_method .)
    NE              reduce using rule 100 (stack_call -> ID . stack_method .)
    AND             reduce using rule 100 (stack_call -> ID . stack_method .)
    OR              reduce using rule 100 (stack_call -> ID . stack_method .)
    ;               reduce using rule 100 (stack_call -> ID . stack_method .)
    )               reduce using rule 100 (stack_call -> ID . stack_method .)
    ,               reduce using rule 100 (stack_call -> ID . stack_method .)


state 148

    (101) stack_method -> POP . ( )

    (               shift and go to state 180


state 149

    (102) stack_method -> PUSH . ( ID check_variable )

    (               shift and go to state 181


state 150

    (45) prop -> ID . ID .

    (               reduce using rule 45 (prop -> ID . ID .)
    =               reduce using rule 45 (prop -> ID . ID .)


state 151

    (47) if_block -> IF ( exp . ) block
    (48) if_block -> IF ( exp . ) block ELSE block

    )               shift and go to state 182


state 152

    (44) prop -> THIS . ID .

    (               reduce using rule 44 (prop -> THIS . ID .)
    =               reduce using rule 44 (prop -> THIS . ID .)


state 153

    (15) return_type -> VOID .

    (               reduce using rule 15 (return_type -> VOID .)


state 154

    (27) function -> # ID neg_lookup : return_type . params scope_function func_block
    (28) params -> . ( attrs )

    (               shift and go to state 184

    params                         shift and go to state 183

state 155

    (16) return_type -> type .

    (               reduce using rule 16 (return_type -> type .)


state 156

    (22) class_block -> { vars constructor . functions }
    (25) functions -> . function functions
    (26) functions -> . empty
    (27) function -> . # ID neg_lookup : return_type params scope_function func_block
    (104) empty -> .

    #               shift and go to state 9
    }               reduce using rule 104 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 185
    empty                          shift and go to state 10

state 157

    (24) constructor -> empty .

    #               reduce using rule 24 (constructor -> empty .)
    }               reduce using rule 24 (constructor -> empty .)


state 158

    (23) constructor -> ~ . ID params scope_constructor func_block

    ID              shift and go to state 186


state 159

    (14) type -> ID check_class .

    (               reduce using rule 14 (type -> ID check_class .)
    =               reduce using rule 14 (type -> ID check_class .)
    ;               reduce using rule 14 (type -> ID check_class .)
    ,               reduce using rule 14 (type -> ID check_class .)
    )               reduce using rule 14 (type -> ID check_class .)


state 160

    (7) init -> = NEW constructor_call .

    ;               reduce using rule 7 (init -> = NEW constructor_call .)


state 161

    (43) constructor_call -> ID . ( args )

    (               shift and go to state 187


state 162

    (62) read -> READ ( string ) .

    ;               reduce using rule 62 (read -> READ ( string ) .)
    )               reduce using rule 62 (read -> READ ( string ) .)
    ,               reduce using rule 62 (read -> READ ( string ) .)


state 163

    (63) string -> ID check_string .

    )               reduce using rule 63 (string -> ID check_string .)


state 164

    (110) check_string -> empty .

    )               reduce using rule 110 (check_string -> empty .)


state 165

    (49) while_block -> WHILE ( exp ) . block
    (54) block -> . { statements }

    {               shift and go to state 188

    block                          shift and go to state 189

state 166

    (51) print_stmt -> PRINT ( exp ) . ;

    ;               shift and go to state 190


state 167

    (81) log_a_alt -> AND log_b log_a_alt .

    OR              reduce using rule 81 (log_a_alt -> AND log_b log_a_alt .)
    ;               reduce using rule 81 (log_a_alt -> AND log_b log_a_alt .)
    )               reduce using rule 81 (log_a_alt -> AND log_b log_a_alt .)
    ,               reduce using rule 81 (log_a_alt -> AND log_b log_a_alt .)


state 168

    (78) logic_exp_alt -> OR log_a logic_exp_alt .

    ;               reduce using rule 78 (logic_exp_alt -> OR log_a logic_exp_alt .)
    )               reduce using rule 78 (logic_exp_alt -> OR log_a logic_exp_alt .)
    ,               reduce using rule 78 (logic_exp_alt -> OR log_a logic_exp_alt .)


state 169

    (94) call -> prop ( args ) .

    *               reduce using rule 94 (call -> prop ( args ) .)
    /               reduce using rule 94 (call -> prop ( args ) .)
    +               reduce using rule 94 (call -> prop ( args ) .)
    -               reduce using rule 94 (call -> prop ( args ) .)
    <               reduce using rule 94 (call -> prop ( args ) .)
    >               reduce using rule 94 (call -> prop ( args ) .)
    EQ              reduce using rule 94 (call -> prop ( args ) .)
    NE              reduce using rule 94 (call -> prop ( args ) .)
    AND             reduce using rule 94 (call -> prop ( args ) .)
    OR              reduce using rule 94 (call -> prop ( args ) .)
    ,               reduce using rule 94 (call -> prop ( args ) .)
    )               reduce using rule 94 (call -> prop ( args ) .)
    ;               reduce using rule 94 (call -> prop ( args ) .)


state 170

    (96) args -> exp args_aux .

    )               reduce using rule 96 (args -> exp args_aux .)


state 171

    (99) args_aux -> empty .

    )               reduce using rule 99 (args_aux -> empty .)


state 172

    (98) args_aux -> , . exp args_aux
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    logic_exp                      shift and go to state 46
    read                           shift and go to state 40
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    exp                            shift and go to state 191
    assign                         shift and go to state 63

state 173

    (76) factor -> ( math_exp . )

    )               shift and go to state 133


state 174

    (70) term_alt -> * factor term_alt .

    +               reduce using rule 70 (term_alt -> * factor term_alt .)
    -               reduce using rule 70 (term_alt -> * factor term_alt .)
    <               reduce using rule 70 (term_alt -> * factor term_alt .)
    >               reduce using rule 70 (term_alt -> * factor term_alt .)
    EQ              reduce using rule 70 (term_alt -> * factor term_alt .)
    NE              reduce using rule 70 (term_alt -> * factor term_alt .)
    AND             reduce using rule 70 (term_alt -> * factor term_alt .)
    OR              reduce using rule 70 (term_alt -> * factor term_alt .)
    ;               reduce using rule 70 (term_alt -> * factor term_alt .)
    )               reduce using rule 70 (term_alt -> * factor term_alt .)
    ,               reduce using rule 70 (term_alt -> * factor term_alt .)


state 175

    (71) term_alt -> / factor term_alt .

    +               reduce using rule 71 (term_alt -> / factor term_alt .)
    -               reduce using rule 71 (term_alt -> / factor term_alt .)
    <               reduce using rule 71 (term_alt -> / factor term_alt .)
    >               reduce using rule 71 (term_alt -> / factor term_alt .)
    EQ              reduce using rule 71 (term_alt -> / factor term_alt .)
    NE              reduce using rule 71 (term_alt -> / factor term_alt .)
    AND             reduce using rule 71 (term_alt -> / factor term_alt .)
    OR              reduce using rule 71 (term_alt -> / factor term_alt .)
    ;               reduce using rule 71 (term_alt -> / factor term_alt .)
    )               reduce using rule 71 (term_alt -> / factor term_alt .)
    ,               reduce using rule 71 (term_alt -> / factor term_alt .)


state 176

    (50) for_block -> FOR number FOR_TO number . SKIP number block

    SKIP            shift and go to state 192


state 177

    (67) math_exp_alt -> - term math_exp_alt .

    <               reduce using rule 67 (math_exp_alt -> - term math_exp_alt .)
    >               reduce using rule 67 (math_exp_alt -> - term math_exp_alt .)
    EQ              reduce using rule 67 (math_exp_alt -> - term math_exp_alt .)
    NE              reduce using rule 67 (math_exp_alt -> - term math_exp_alt .)
    AND             reduce using rule 67 (math_exp_alt -> - term math_exp_alt .)
    OR              reduce using rule 67 (math_exp_alt -> - term math_exp_alt .)
    ;               reduce using rule 67 (math_exp_alt -> - term math_exp_alt .)
    )               reduce using rule 67 (math_exp_alt -> - term math_exp_alt .)
    ,               reduce using rule 67 (math_exp_alt -> - term math_exp_alt .)


state 178

    (66) math_exp_alt -> + term math_exp_alt .

    <               reduce using rule 66 (math_exp_alt -> + term math_exp_alt .)
    >               reduce using rule 66 (math_exp_alt -> + term math_exp_alt .)
    EQ              reduce using rule 66 (math_exp_alt -> + term math_exp_alt .)
    NE              reduce using rule 66 (math_exp_alt -> + term math_exp_alt .)
    AND             reduce using rule 66 (math_exp_alt -> + term math_exp_alt .)
    OR              reduce using rule 66 (math_exp_alt -> + term math_exp_alt .)
    ;               reduce using rule 66 (math_exp_alt -> + term math_exp_alt .)
    )               reduce using rule 66 (math_exp_alt -> + term math_exp_alt .)
    ,               reduce using rule 66 (math_exp_alt -> + term math_exp_alt .)


state 179

    (103) stack_method -> PEEK ( . )

    )               shift and go to state 193


state 180

    (101) stack_method -> POP ( . )

    )               shift and go to state 194


state 181

    (102) stack_method -> PUSH ( . ID check_variable )

    ID              shift and go to state 195


state 182

    (47) if_block -> IF ( exp ) . block
    (48) if_block -> IF ( exp ) . block ELSE block
    (54) block -> . { statements }

    {               shift and go to state 188

    block                          shift and go to state 196

state 183

    (27) function -> # ID neg_lookup : return_type params . scope_function func_block
    (106) scope_function -> . empty
    (104) empty -> .

    {               reduce using rule 104 (empty -> .)

    scope_function                 shift and go to state 197
    empty                          shift and go to state 198

state 184

    (28) params -> ( . attrs )
    (29) attrs -> . attr attrs_alt
    (30) attrs -> . empty
    (5) attr -> . ID : type
    (104) empty -> .

    ID              shift and go to state 24
    )               reduce using rule 104 (empty -> .)

    attrs                          shift and go to state 199
    empty                          shift and go to state 200
    attr                           shift and go to state 201

state 185

    (22) class_block -> { vars constructor functions . }

    }               shift and go to state 202


state 186

    (23) constructor -> ~ ID . params scope_constructor func_block
    (28) params -> . ( attrs )

    (               shift and go to state 184

    params                         shift and go to state 203

state 187

    (43) constructor_call -> ID ( . args )
    (96) args -> . exp args_aux
    (97) args -> . empty
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (104) empty -> .
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    STRING          shift and go to state 48
    )               reduce using rule 104 (empty -> .)
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    bool                           shift and go to state 41
    math_exp                       shift and go to state 52
    factor                         shift and go to state 43
    call                           shift and go to state 44
    empty                          shift and go to state 135
    logic_exp                      shift and go to state 46
    read                           shift and go to state 40
    args                           shift and go to state 204
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    exp                            shift and go to state 137
    assign                         shift and go to state 63

state 188

    (54) block -> { . statements }
    (34) statements -> . statement
    (35) statements -> . empty
    (36) statement -> . if_block
    (37) statement -> . while_block
    (38) statement -> . for_block
    (39) statement -> . print_stmt
    (40) statement -> . expr
    (41) statement -> . return
    (104) empty -> .
    (47) if_block -> . IF ( exp ) block
    (48) if_block -> . IF ( exp ) block ELSE block
    (49) while_block -> . WHILE ( exp ) block
    (50) for_block -> . FOR number FOR_TO number SKIP number block
    (51) print_stmt -> . PRINT ( exp ) ;
    (57) expr -> . exp ;
    (52) return -> . RETURN exp ;
    (53) return -> . RETURN ;
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    }               reduce using rule 104 (empty -> .)
    IF              shift and go to state 54
    WHILE           shift and go to state 31
    FOR             shift and go to state 49
    PRINT           shift and go to state 33
    RETURN          shift and go to state 34
    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    for_block                      shift and go to state 26
    statements                     shift and go to state 205
    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    read                           shift and go to state 40
    bool                           shift and go to state 41
    statement                      shift and go to state 42
    factor                         shift and go to state 43
    call                           shift and go to state 44
    math_exp                       shift and go to state 52
    empty                          shift and go to state 45
    logic_exp                      shift and go to state 46
    return                         shift and go to state 47
    print_stmt                     shift and go to state 50
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    expr                           shift and go to state 58
    if_block                       shift and go to state 59
    while_block                    shift and go to state 61
    exp                            shift and go to state 62
    assign                         shift and go to state 63

state 189

    (49) while_block -> WHILE ( exp ) block .

    $end            reduce using rule 49 (while_block -> WHILE ( exp ) block .)
    }               reduce using rule 49 (while_block -> WHILE ( exp ) block .)


state 190

    (51) print_stmt -> PRINT ( exp ) ; .

    }               reduce using rule 51 (print_stmt -> PRINT ( exp ) ; .)
    $end            reduce using rule 51 (print_stmt -> PRINT ( exp ) ; .)


state 191

    (98) args_aux -> , exp . args_aux
    (98) args_aux -> . , exp args_aux
    (99) args_aux -> . empty
    (104) empty -> .

    ,               shift and go to state 172
    )               reduce using rule 104 (empty -> .)

    args_aux                       shift and go to state 206
    empty                          shift and go to state 171

state 192

    (50) for_block -> FOR number FOR_TO number SKIP . number block
    (55) number -> . FLOAT
    (56) number -> . INT

    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    number                         shift and go to state 207

state 193

    (103) stack_method -> PEEK ( ) .

    *               reduce using rule 103 (stack_method -> PEEK ( ) .)
    /               reduce using rule 103 (stack_method -> PEEK ( ) .)
    +               reduce using rule 103 (stack_method -> PEEK ( ) .)
    -               reduce using rule 103 (stack_method -> PEEK ( ) .)
    <               reduce using rule 103 (stack_method -> PEEK ( ) .)
    >               reduce using rule 103 (stack_method -> PEEK ( ) .)
    EQ              reduce using rule 103 (stack_method -> PEEK ( ) .)
    NE              reduce using rule 103 (stack_method -> PEEK ( ) .)
    AND             reduce using rule 103 (stack_method -> PEEK ( ) .)
    OR              reduce using rule 103 (stack_method -> PEEK ( ) .)
    ;               reduce using rule 103 (stack_method -> PEEK ( ) .)
    )               reduce using rule 103 (stack_method -> PEEK ( ) .)
    ,               reduce using rule 103 (stack_method -> PEEK ( ) .)


state 194

    (101) stack_method -> POP ( ) .

    *               reduce using rule 101 (stack_method -> POP ( ) .)
    /               reduce using rule 101 (stack_method -> POP ( ) .)
    +               reduce using rule 101 (stack_method -> POP ( ) .)
    -               reduce using rule 101 (stack_method -> POP ( ) .)
    <               reduce using rule 101 (stack_method -> POP ( ) .)
    >               reduce using rule 101 (stack_method -> POP ( ) .)
    EQ              reduce using rule 101 (stack_method -> POP ( ) .)
    NE              reduce using rule 101 (stack_method -> POP ( ) .)
    AND             reduce using rule 101 (stack_method -> POP ( ) .)
    OR              reduce using rule 101 (stack_method -> POP ( ) .)
    ;               reduce using rule 101 (stack_method -> POP ( ) .)
    )               reduce using rule 101 (stack_method -> POP ( ) .)
    ,               reduce using rule 101 (stack_method -> POP ( ) .)


state 195

    (102) stack_method -> PUSH ( ID . check_variable )
    (108) check_variable -> . empty
    (104) empty -> .

    )               reduce using rule 104 (empty -> .)

    check_variable                 shift and go to state 208
    empty                          shift and go to state 209

state 196

    (47) if_block -> IF ( exp ) block .
    (48) if_block -> IF ( exp ) block . ELSE block

    }               reduce using rule 47 (if_block -> IF ( exp ) block .)
    $end            reduce using rule 47 (if_block -> IF ( exp ) block .)
    ELSE            shift and go to state 210


state 197

    (27) function -> # ID neg_lookup : return_type params scope_function . func_block
    (33) func_block -> . { vars statements }

    {               shift and go to state 212

    func_block                     shift and go to state 211

state 198

    (106) scope_function -> empty .

    {               reduce using rule 106 (scope_function -> empty .)


state 199

    (28) params -> ( attrs . )

    )               shift and go to state 213


state 200

    (30) attrs -> empty .

    )               reduce using rule 30 (attrs -> empty .)


state 201

    (29) attrs -> attr . attrs_alt
    (31) attrs_alt -> . , attr attrs_alt
    (32) attrs_alt -> . empty
    (104) empty -> .

    ,               shift and go to state 214
    )               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 215
    attrs_alt                      shift and go to state 216

state 202

    (22) class_block -> { vars constructor functions } .

    @               reduce using rule 22 (class_block -> { vars constructor functions } .)
    #               reduce using rule 22 (class_block -> { vars constructor functions } .)
    $               reduce using rule 22 (class_block -> { vars constructor functions } .)
    IF              reduce using rule 22 (class_block -> { vars constructor functions } .)
    WHILE           reduce using rule 22 (class_block -> { vars constructor functions } .)
    FOR             reduce using rule 22 (class_block -> { vars constructor functions } .)
    PRINT           reduce using rule 22 (class_block -> { vars constructor functions } .)
    RETURN          reduce using rule 22 (class_block -> { vars constructor functions } .)
    STRING          reduce using rule 22 (class_block -> { vars constructor functions } .)
    READ            reduce using rule 22 (class_block -> { vars constructor functions } .)
    THIS            reduce using rule 22 (class_block -> { vars constructor functions } .)
    ID              reduce using rule 22 (class_block -> { vars constructor functions } .)
    (               reduce using rule 22 (class_block -> { vars constructor functions } .)
    TRUE            reduce using rule 22 (class_block -> { vars constructor functions } .)
    FALSE           reduce using rule 22 (class_block -> { vars constructor functions } .)
    FLOAT           reduce using rule 22 (class_block -> { vars constructor functions } .)
    INT             reduce using rule 22 (class_block -> { vars constructor functions } .)
    $end            reduce using rule 22 (class_block -> { vars constructor functions } .)


state 203

    (23) constructor -> ~ ID params . scope_constructor func_block
    (107) scope_constructor -> . empty
    (104) empty -> .

    {               reduce using rule 104 (empty -> .)

    scope_constructor              shift and go to state 217
    empty                          shift and go to state 218

state 204

    (43) constructor_call -> ID ( args . )

    )               shift and go to state 219


state 205

    (54) block -> { statements . }

    }               shift and go to state 220


state 206

    (98) args_aux -> , exp args_aux .

    )               reduce using rule 98 (args_aux -> , exp args_aux .)


state 207

    (50) for_block -> FOR number FOR_TO number SKIP number . block
    (54) block -> . { statements }

    {               shift and go to state 188

    block                          shift and go to state 221

state 208

    (102) stack_method -> PUSH ( ID check_variable . )

    )               shift and go to state 222


state 209

    (108) check_variable -> empty .

    )               reduce using rule 108 (check_variable -> empty .)


state 210

    (48) if_block -> IF ( exp ) block ELSE . block
    (54) block -> . { statements }

    {               shift and go to state 188

    block                          shift and go to state 223

state 211

    (27) function -> # ID neg_lookup : return_type params scope_function func_block .

    #               reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $               reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    IF              reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    WHILE           reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FOR             reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    PRINT           reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    RETURN          reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    STRING          reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    READ            reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    THIS            reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    ID              reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    (               reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    TRUE            reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FALSE           reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FLOAT           reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    INT             reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $end            reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    }               reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)


state 212

    (33) func_block -> { . vars statements }
    (2) vars -> . var vars
    (3) vars -> . empty
    (4) var -> . $ attr init ;
    (104) empty -> .

    $               shift and go to state 16
    IF              reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    PRINT           reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    STRING          reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    THIS            reduce using rule 104 (empty -> .)
    ID              reduce using rule 104 (empty -> .)
    (               reduce using rule 104 (empty -> .)
    TRUE            reduce using rule 104 (empty -> .)
    FALSE           reduce using rule 104 (empty -> .)
    FLOAT           reduce using rule 104 (empty -> .)
    INT             reduce using rule 104 (empty -> .)
    }               reduce using rule 104 (empty -> .)

    vars                           shift and go to state 224
    var                            shift and go to state 18
    empty                          shift and go to state 19

state 213

    (28) params -> ( attrs ) .

    {               reduce using rule 28 (params -> ( attrs ) .)


state 214

    (31) attrs_alt -> , . attr attrs_alt
    (5) attr -> . ID : type

    ID              shift and go to state 24

    attr                           shift and go to state 225

state 215

    (32) attrs_alt -> empty .

    )               reduce using rule 32 (attrs_alt -> empty .)


state 216

    (29) attrs -> attr attrs_alt .

    )               reduce using rule 29 (attrs -> attr attrs_alt .)


state 217

    (23) constructor -> ~ ID params scope_constructor . func_block
    (33) func_block -> . { vars statements }

    {               shift and go to state 212

    func_block                     shift and go to state 226

state 218

    (107) scope_constructor -> empty .

    {               reduce using rule 107 (scope_constructor -> empty .)


state 219

    (43) constructor_call -> ID ( args ) .

    ;               reduce using rule 43 (constructor_call -> ID ( args ) .)


state 220

    (54) block -> { statements } .

    $end            reduce using rule 54 (block -> { statements } .)
    }               reduce using rule 54 (block -> { statements } .)
    ELSE            reduce using rule 54 (block -> { statements } .)


state 221

    (50) for_block -> FOR number FOR_TO number SKIP number block .

    }               reduce using rule 50 (for_block -> FOR number FOR_TO number SKIP number block .)
    $end            reduce using rule 50 (for_block -> FOR number FOR_TO number SKIP number block .)


state 222

    (102) stack_method -> PUSH ( ID check_variable ) .

    *               reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    /               reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    +               reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    -               reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    <               reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    >               reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    EQ              reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    NE              reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    AND             reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    OR              reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    ;               reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    )               reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)
    ,               reduce using rule 102 (stack_method -> PUSH ( ID check_variable ) .)


state 223

    (48) if_block -> IF ( exp ) block ELSE block .

    }               reduce using rule 48 (if_block -> IF ( exp ) block ELSE block .)
    $end            reduce using rule 48 (if_block -> IF ( exp ) block ELSE block .)


state 224

    (33) func_block -> { vars . statements }
    (34) statements -> . statement
    (35) statements -> . empty
    (36) statement -> . if_block
    (37) statement -> . while_block
    (38) statement -> . for_block
    (39) statement -> . print_stmt
    (40) statement -> . expr
    (41) statement -> . return
    (104) empty -> .
    (47) if_block -> . IF ( exp ) block
    (48) if_block -> . IF ( exp ) block ELSE block
    (49) while_block -> . WHILE ( exp ) block
    (50) for_block -> . FOR number FOR_TO number SKIP number block
    (51) print_stmt -> . PRINT ( exp ) ;
    (57) expr -> . exp ;
    (52) return -> . RETURN exp ;
    (53) return -> . RETURN ;
    (58) exp -> . read
    (59) exp -> . logic_exp
    (60) exp -> . assign
    (61) exp -> . STRING
    (62) read -> . READ ( string )
    (77) logic_exp -> . log_a logic_exp_alt
    (42) assign -> . prop = exp
    (80) log_a -> . log_b log_a_alt
    (44) prop -> . THIS . ID
    (45) prop -> . ID . ID
    (46) prop -> . ID
    (83) log_b -> . ( logic_exp )
    (84) log_b -> . bool
    (85) log_b -> . comparison
    (86) bool -> . TRUE
    (87) bool -> . FALSE
    (88) comparison -> . math_exp comparison_op math_exp
    (89) comparison -> . math_exp
    (65) math_exp -> . term math_exp_alt
    (69) term -> . factor term_alt
    (73) factor -> . ID check_number
    (74) factor -> . number
    (75) factor -> . call
    (76) factor -> . ( math_exp )
    (55) number -> . FLOAT
    (56) number -> . INT
    (94) call -> . prop ( args )
    (95) call -> . stack_call
    (100) stack_call -> . ID . stack_method

    }               reduce using rule 104 (empty -> .)
    IF              shift and go to state 54
    WHILE           shift and go to state 31
    FOR             shift and go to state 49
    PRINT           shift and go to state 33
    RETURN          shift and go to state 34
    STRING          shift and go to state 48
    READ            shift and go to state 29
    THIS            shift and go to state 57
    ID              shift and go to state 53
    (               shift and go to state 38
    TRUE            shift and go to state 35
    FALSE           shift and go to state 56
    FLOAT           shift and go to state 27
    INT             shift and go to state 60

    for_block                      shift and go to state 26
    statements                     shift and go to state 227
    number                         shift and go to state 30
    stack_call                     shift and go to state 32
    log_b                          shift and go to state 36
    log_a                          shift and go to state 37
    prop                           shift and go to state 39
    read                           shift and go to state 40
    bool                           shift and go to state 41
    statement                      shift and go to state 42
    factor                         shift and go to state 43
    call                           shift and go to state 44
    math_exp                       shift and go to state 52
    empty                          shift and go to state 45
    logic_exp                      shift and go to state 46
    return                         shift and go to state 47
    print_stmt                     shift and go to state 50
    term                           shift and go to state 51
    comparison                     shift and go to state 55
    expr                           shift and go to state 58
    if_block                       shift and go to state 59
    while_block                    shift and go to state 61
    exp                            shift and go to state 62
    assign                         shift and go to state 63

state 225

    (31) attrs_alt -> , attr . attrs_alt
    (31) attrs_alt -> . , attr attrs_alt
    (32) attrs_alt -> . empty
    (104) empty -> .

    ,               shift and go to state 214
    )               reduce using rule 104 (empty -> .)

    empty                          shift and go to state 215
    attrs_alt                      shift and go to state 228

state 226

    (23) constructor -> ~ ID params scope_constructor func_block .

    #               reduce using rule 23 (constructor -> ~ ID params scope_constructor func_block .)
    }               reduce using rule 23 (constructor -> ~ ID params scope_constructor func_block .)


state 227

    (33) func_block -> { vars statements . }

    }               shift and go to state 229


state 228

    (31) attrs_alt -> , attr attrs_alt .

    )               reduce using rule 31 (attrs_alt -> , attr attrs_alt .)


state 229

    (33) func_block -> { vars statements } .

    #               reduce using rule 33 (func_block -> { vars statements } .)
    $               reduce using rule 33 (func_block -> { vars statements } .)
    IF              reduce using rule 33 (func_block -> { vars statements } .)
    WHILE           reduce using rule 33 (func_block -> { vars statements } .)
    FOR             reduce using rule 33 (func_block -> { vars statements } .)
    PRINT           reduce using rule 33 (func_block -> { vars statements } .)
    RETURN          reduce using rule 33 (func_block -> { vars statements } .)
    STRING          reduce using rule 33 (func_block -> { vars statements } .)
    READ            reduce using rule 33 (func_block -> { vars statements } .)
    THIS            reduce using rule 33 (func_block -> { vars statements } .)
    ID              reduce using rule 33 (func_block -> { vars statements } .)
    (               reduce using rule 33 (func_block -> { vars statements } .)
    TRUE            reduce using rule 33 (func_block -> { vars statements } .)
    FALSE           reduce using rule 33 (func_block -> { vars statements } .)
    FLOAT           reduce using rule 33 (func_block -> { vars statements } .)
    INT             reduce using rule 33 (func_block -> { vars statements } .)
    $end            reduce using rule 33 (func_block -> { vars statements } .)
    }               reduce using rule 33 (func_block -> { vars statements } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ) in state 87 resolved as shift
