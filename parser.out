Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> classes functions fill_goto statements
Rule 2     fill_goto -> empty
Rule 3     classes -> class classes
Rule 4     classes -> empty
Rule 5     class -> @ ID inheritance params scope_class class_block
Rule 6     inheritance -> < ID check_class >
Rule 7     inheritance -> empty
Rule 8     params -> ( attrs )
Rule 9     attrs -> attr attrs_alt
Rule 10    attrs -> empty
Rule 11    attrs_alt -> , attr attrs_alt
Rule 12    attrs_alt -> empty
Rule 13    class_block -> { functions }
Rule 14    functions -> function functions
Rule 15    functions -> empty
Rule 16    function -> # ID neg_lookup : return_type params scope_function func_block
Rule 17    return_type -> VOID
Rule 18    return_type -> type
Rule 19    func_block -> { statements return }
Rule 20    return -> RETURN exp ;
Rule 21    return -> empty
Rule 22    statements -> statement statements
Rule 23    statements -> empty
Rule 24    statement -> declaration ;
Rule 25    statement -> print_stmt
Rule 26    statement -> if_block
Rule 27    statement -> while_block
Rule 28    statement -> expr
Rule 29    declaration -> $ attr
Rule 30    attr -> ID : type
Rule 31    attr -> ID : stack_type
Rule 32    type -> INT_TYPE
Rule 33    type -> FLOAT_TYPE
Rule 34    type -> STRING_TYPE
Rule 35    type -> BOOLEAN_TYPE
Rule 36    type -> ID check_class
Rule 37    stack_type -> STACK ( type )
Rule 38    print_stmt -> PRINT ( exp ) ;
Rule 39    expr -> exp ;
Rule 40    exp -> read
Rule 41    exp -> math_or
Rule 42    exp -> assign
Rule 43    exp -> string
Rule 44    exp -> new
Rule 45    exp -> stack_call
Rule 46    read -> READ ( )
Rule 47    assign -> var = exp
Rule 48    string -> STRING
Rule 49    var -> prop
Rule 50    var -> declaration
Rule 51    new -> NEW constructor_call
Rule 52    constructor_call -> ID ( args )
Rule 53    stack_call -> ID . stack_method
Rule 54    stack_method -> POP ( )
Rule 55    stack_method -> PUSH ( exp )
Rule 56    stack_method -> PEEK ( )
Rule 57    stack_method -> SIZE ( )
Rule 58    math_or -> math_and math_or_alt
Rule 59    math_or_alt -> OR math_and new_quad math_or_alt
Rule 60    math_or_alt -> empty
Rule 61    math_and -> math_comp math_and_alt
Rule 62    math_and_alt -> AND math_comp new_quad math_and_alt
Rule 63    math_and_alt -> empty
Rule 64    math_comp -> math_exp math_comp_alt
Rule 65    math_comp_alt -> comparison_op math_exp new_quad
Rule 66    math_comp_alt -> empty
Rule 67    comparison_op -> <
Rule 68    comparison_op -> >
Rule 69    comparison_op -> EQ
Rule 70    comparison_op -> NE
Rule 71    comparison_op -> LE
Rule 72    comparison_op -> GE
Rule 73    math_exp -> term math_exp_alt
Rule 74    math_exp_alt -> + term new_quad math_exp_alt
Rule 75    math_exp_alt -> - term new_quad math_exp_alt
Rule 76    math_exp_alt -> empty
Rule 77    term -> factor term_alt
Rule 78    term_alt -> * factor new_quad term_alt
Rule 79    term_alt -> / factor new_quad term_alt
Rule 80    term_alt -> empty
Rule 81    factor -> prop
Rule 82    factor -> number
Rule 83    factor -> call
Rule 84    factor -> ( math_or )
Rule 85    prop -> THIS . ID
Rule 86    prop -> ID . ID
Rule 87    prop -> ID
Rule 88    number -> FLOAT empty
Rule 89    number -> INT
Rule 90    call -> prop ( args )
Rule 91    args -> exp args_aux
Rule 92    args -> empty
Rule 93    args_aux -> , exp args_aux
Rule 94    args_aux -> empty
Rule 95    if_block -> IF ( exp exp_evaluation ) block
Rule 96    if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block
Rule 97    while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block
Rule 98    block -> { statements }
Rule 99    empty -> <empty>
Rule 100   new_quad -> empty
Rule 101   scope_class -> empty
Rule 102   scope_function -> empty
Rule 103   check_class -> empty
Rule 104   neg_lookup -> empty
Rule 105   exp_evaluation -> empty
Rule 106   after_if_block -> empty
Rule 107   leave_breadcrumb -> empty

Terminals, with rules where they appear

#                    : 16
$                    : 29
(                    : 8 37 38 46 52 54 55 56 57 84 90 95 96 97
)                    : 8 37 38 46 52 54 55 56 57 84 90 95 96 97
*                    : 78
+                    : 74
,                    : 11 93
-                    : 75
.                    : 53 85 86
/                    : 79
:                    : 16 30 31
;                    : 20 24 38 39
<                    : 6 67
=                    : 47
>                    : 6 68
@                    : 5
AND                  : 62
BOOLEAN_TYPE         : 35
ELSE                 : 96
EQ                   : 69
FLOAT                : 88
FLOAT_TYPE           : 33
GE                   : 72
ID                   : 5 6 16 30 31 36 52 53 85 86 86 87
IF                   : 95 96
INT                  : 89
INT_TYPE             : 32
LE                   : 71
NE                   : 70
NEW                  : 51
OR                   : 59
PEEK                 : 56
POP                  : 54
PRINT                : 38
PUSH                 : 55
READ                 : 46
RETURN               : 20
SIZE                 : 57
STACK                : 37
STRING               : 48
STRING_TYPE          : 34
THIS                 : 85
VOID                 : 17
WHILE                : 97
error                : 
{                    : 13 19 98
}                    : 13 19 98

Nonterminals, with rules where they appear

after_if_block       : 96
args                 : 52 90
args_aux             : 91 93
assign               : 42
attr                 : 9 11 29
attrs                : 8
attrs_alt            : 9 11
block                : 95 96 96 97
call                 : 83
check_class          : 6 36
class                : 3
class_block          : 5
classes              : 1 3
comparison_op        : 65
constructor_call     : 51
declaration          : 24 50
empty                : 2 4 7 10 12 15 21 23 60 63 66 76 80 88 92 94 100 101 102 103 104 105 106 107
exp                  : 20 38 39 47 55 91 93 95 96 97
exp_evaluation       : 95 96 97
expr                 : 28
factor               : 77 78 79
fill_goto            : 1
func_block           : 16
function             : 14
functions            : 1 13 14
if_block             : 26
inheritance          : 5
leave_breadcrumb     : 97
math_and             : 58 59
math_and_alt         : 61 62
math_comp            : 61 62
math_comp_alt        : 64
math_exp             : 64 65
math_exp_alt         : 73 74 75
math_or              : 41 84
math_or_alt          : 58 59
neg_lookup           : 16
new                  : 44
new_quad             : 59 62 65 74 75 78 79
number               : 82
params               : 5 16
print_stmt           : 25
program              : 0
prop                 : 49 81 90
read                 : 40
return               : 19
return_type          : 16
scope_class          : 5
scope_function       : 16
stack_call           : 45
stack_method         : 53
stack_type           : 31
statement            : 22
statements           : 1 19 22 98
string               : 43
term                 : 73 74 75
term_alt             : 77 78 79
type                 : 18 30 37
var                  : 47
while_block          : 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . classes functions fill_goto statements
    (3) classes -> . class classes
    (4) classes -> . empty
    (5) class -> . @ ID inheritance params scope_class class_block
    (99) empty -> .

    @               shift and go to state 2
    #               reduce using rule 99 (empty -> .)
    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)

    program                        shift and go to state 1
    classes                        shift and go to state 3
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (5) class -> @ . ID inheritance params scope_class class_block

    ID              shift and go to state 6


state 3

    (1) program -> classes . functions fill_goto statements
    (14) functions -> . function functions
    (15) functions -> . empty
    (16) function -> . # ID neg_lookup : return_type params scope_function func_block
    (99) empty -> .

    #               shift and go to state 9
    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 8
    empty                          shift and go to state 10

state 4

    (3) classes -> class . classes
    (3) classes -> . class classes
    (4) classes -> . empty
    (5) class -> . @ ID inheritance params scope_class class_block
    (99) empty -> .

    @               shift and go to state 2
    #               reduce using rule 99 (empty -> .)
    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)

    classes                        shift and go to state 11
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 5

    (4) classes -> empty .

    #               reduce using rule 4 (classes -> empty .)
    $               reduce using rule 4 (classes -> empty .)
    PRINT           reduce using rule 4 (classes -> empty .)
    IF              reduce using rule 4 (classes -> empty .)
    WHILE           reduce using rule 4 (classes -> empty .)
    READ            reduce using rule 4 (classes -> empty .)
    STRING          reduce using rule 4 (classes -> empty .)
    NEW             reduce using rule 4 (classes -> empty .)
    ID              reduce using rule 4 (classes -> empty .)
    THIS            reduce using rule 4 (classes -> empty .)
    (               reduce using rule 4 (classes -> empty .)
    FLOAT           reduce using rule 4 (classes -> empty .)
    INT             reduce using rule 4 (classes -> empty .)
    $end            reduce using rule 4 (classes -> empty .)


state 6

    (5) class -> @ ID . inheritance params scope_class class_block
    (6) inheritance -> . < ID check_class >
    (7) inheritance -> . empty
    (99) empty -> .

    <               shift and go to state 13
    (               reduce using rule 99 (empty -> .)

    inheritance                    shift and go to state 12
    empty                          shift and go to state 14

state 7

    (14) functions -> function . functions
    (14) functions -> . function functions
    (15) functions -> . empty
    (16) function -> . # ID neg_lookup : return_type params scope_function func_block
    (99) empty -> .

    #               shift and go to state 9
    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)
    }               reduce using rule 99 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 15
    empty                          shift and go to state 10

state 8

    (1) program -> classes functions . fill_goto statements
    (2) fill_goto -> . empty
    (99) empty -> .

    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)

    fill_goto                      shift and go to state 16
    empty                          shift and go to state 17

state 9

    (16) function -> # . ID neg_lookup : return_type params scope_function func_block

    ID              shift and go to state 18


state 10

    (15) functions -> empty .

    $               reduce using rule 15 (functions -> empty .)
    PRINT           reduce using rule 15 (functions -> empty .)
    IF              reduce using rule 15 (functions -> empty .)
    WHILE           reduce using rule 15 (functions -> empty .)
    READ            reduce using rule 15 (functions -> empty .)
    STRING          reduce using rule 15 (functions -> empty .)
    NEW             reduce using rule 15 (functions -> empty .)
    ID              reduce using rule 15 (functions -> empty .)
    THIS            reduce using rule 15 (functions -> empty .)
    (               reduce using rule 15 (functions -> empty .)
    FLOAT           reduce using rule 15 (functions -> empty .)
    INT             reduce using rule 15 (functions -> empty .)
    $end            reduce using rule 15 (functions -> empty .)
    }               reduce using rule 15 (functions -> empty .)


state 11

    (3) classes -> class classes .

    #               reduce using rule 3 (classes -> class classes .)
    $               reduce using rule 3 (classes -> class classes .)
    PRINT           reduce using rule 3 (classes -> class classes .)
    IF              reduce using rule 3 (classes -> class classes .)
    WHILE           reduce using rule 3 (classes -> class classes .)
    READ            reduce using rule 3 (classes -> class classes .)
    STRING          reduce using rule 3 (classes -> class classes .)
    NEW             reduce using rule 3 (classes -> class classes .)
    ID              reduce using rule 3 (classes -> class classes .)
    THIS            reduce using rule 3 (classes -> class classes .)
    (               reduce using rule 3 (classes -> class classes .)
    FLOAT           reduce using rule 3 (classes -> class classes .)
    INT             reduce using rule 3 (classes -> class classes .)
    $end            reduce using rule 3 (classes -> class classes .)


state 12

    (5) class -> @ ID inheritance . params scope_class class_block
    (8) params -> . ( attrs )

    (               shift and go to state 19

    params                         shift and go to state 20

state 13

    (6) inheritance -> < . ID check_class >

    ID              shift and go to state 21


state 14

    (7) inheritance -> empty .

    (               reduce using rule 7 (inheritance -> empty .)


state 15

    (14) functions -> function functions .

    $               reduce using rule 14 (functions -> function functions .)
    PRINT           reduce using rule 14 (functions -> function functions .)
    IF              reduce using rule 14 (functions -> function functions .)
    WHILE           reduce using rule 14 (functions -> function functions .)
    READ            reduce using rule 14 (functions -> function functions .)
    STRING          reduce using rule 14 (functions -> function functions .)
    NEW             reduce using rule 14 (functions -> function functions .)
    ID              reduce using rule 14 (functions -> function functions .)
    THIS            reduce using rule 14 (functions -> function functions .)
    (               reduce using rule 14 (functions -> function functions .)
    FLOAT           reduce using rule 14 (functions -> function functions .)
    INT             reduce using rule 14 (functions -> function functions .)
    $end            reduce using rule 14 (functions -> function functions .)
    }               reduce using rule 14 (functions -> function functions .)


state 16

    (1) program -> classes functions fill_goto . statements
    (22) statements -> . statement statements
    (23) statements -> . empty
    (24) statement -> . declaration ;
    (25) statement -> . print_stmt
    (26) statement -> . if_block
    (27) statement -> . while_block
    (28) statement -> . expr
    (99) empty -> .
    (29) declaration -> . $ attr
    (38) print_stmt -> . PRINT ( exp ) ;
    (95) if_block -> . IF ( exp exp_evaluation ) block
    (96) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (97) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (39) expr -> . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    $end            reduce using rule 99 (empty -> .)
    $               shift and go to state 34
    PRINT           shift and go to state 30
    IF              shift and go to state 49
    WHILE           shift and go to state 27
    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    statements                     shift and go to state 24
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    math_exp                       shift and go to state 33
    prop                           shift and go to state 32
    read                           shift and go to state 36
    call                           shift and go to state 37
    statement                      shift and go to state 38
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    empty                          shift and go to state 42
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    print_stmt                     shift and go to state 45
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 47
    term                           shift and go to state 50
    expr                           shift and go to state 51
    if_block                       shift and go to state 52
    while_block                    shift and go to state 54
    exp                            shift and go to state 55
    assign                         shift and go to state 57

state 17

    (2) fill_goto -> empty .

    $               reduce using rule 2 (fill_goto -> empty .)
    PRINT           reduce using rule 2 (fill_goto -> empty .)
    IF              reduce using rule 2 (fill_goto -> empty .)
    WHILE           reduce using rule 2 (fill_goto -> empty .)
    READ            reduce using rule 2 (fill_goto -> empty .)
    STRING          reduce using rule 2 (fill_goto -> empty .)
    NEW             reduce using rule 2 (fill_goto -> empty .)
    ID              reduce using rule 2 (fill_goto -> empty .)
    THIS            reduce using rule 2 (fill_goto -> empty .)
    (               reduce using rule 2 (fill_goto -> empty .)
    FLOAT           reduce using rule 2 (fill_goto -> empty .)
    INT             reduce using rule 2 (fill_goto -> empty .)
    $end            reduce using rule 2 (fill_goto -> empty .)


state 18

    (16) function -> # ID . neg_lookup : return_type params scope_function func_block
    (104) neg_lookup -> . empty
    (99) empty -> .

    :               reduce using rule 99 (empty -> .)

    neg_lookup                     shift and go to state 58
    empty                          shift and go to state 59

state 19

    (8) params -> ( . attrs )
    (9) attrs -> . attr attrs_alt
    (10) attrs -> . empty
    (30) attr -> . ID : type
    (31) attr -> . ID : stack_type
    (99) empty -> .

    ID              shift and go to state 61
    )               reduce using rule 99 (empty -> .)

    attrs                          shift and go to state 60
    attr                           shift and go to state 63
    empty                          shift and go to state 62

state 20

    (5) class -> @ ID inheritance params . scope_class class_block
    (101) scope_class -> . empty
    (99) empty -> .

    {               reduce using rule 99 (empty -> .)

    scope_class                    shift and go to state 64
    empty                          shift and go to state 65

state 21

    (6) inheritance -> < ID . check_class >
    (103) check_class -> . empty
    (99) empty -> .

    >               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 66
    check_class                    shift and go to state 67

state 22

    (41) exp -> math_or .

    ;               reduce using rule 41 (exp -> math_or .)
    ,               reduce using rule 41 (exp -> math_or .)
    )               reduce using rule 41 (exp -> math_or .)


state 23

    (88) number -> FLOAT . empty
    (99) empty -> .

    *               reduce using rule 99 (empty -> .)
    /               reduce using rule 99 (empty -> .)
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 68

state 24

    (1) program -> classes functions fill_goto statements .

    $end            reduce using rule 1 (program -> classes functions fill_goto statements .)


state 25

    (46) read -> READ . ( )

    (               shift and go to state 69


state 26

    (82) factor -> number .

    *               reduce using rule 82 (factor -> number .)
    /               reduce using rule 82 (factor -> number .)
    +               reduce using rule 82 (factor -> number .)
    -               reduce using rule 82 (factor -> number .)
    <               reduce using rule 82 (factor -> number .)
    >               reduce using rule 82 (factor -> number .)
    EQ              reduce using rule 82 (factor -> number .)
    NE              reduce using rule 82 (factor -> number .)
    LE              reduce using rule 82 (factor -> number .)
    GE              reduce using rule 82 (factor -> number .)
    AND             reduce using rule 82 (factor -> number .)
    OR              reduce using rule 82 (factor -> number .)
    ,               reduce using rule 82 (factor -> number .)
    )               reduce using rule 82 (factor -> number .)
    ;               reduce using rule 82 (factor -> number .)


state 27

    (97) while_block -> WHILE . ( leave_breadcrumb exp exp_evaluation ) block

    (               shift and go to state 70


state 28

    (48) string -> STRING .

    ,               reduce using rule 48 (string -> STRING .)
    )               reduce using rule 48 (string -> STRING .)
    ;               reduce using rule 48 (string -> STRING .)


state 29

    (51) new -> NEW . constructor_call
    (52) constructor_call -> . ID ( args )

    ID              shift and go to state 72

    constructor_call               shift and go to state 71

state 30

    (38) print_stmt -> PRINT . ( exp ) ;

    (               shift and go to state 73


state 31

    (45) exp -> stack_call .

    ;               reduce using rule 45 (exp -> stack_call .)
    ,               reduce using rule 45 (exp -> stack_call .)
    )               reduce using rule 45 (exp -> stack_call .)


state 32

    (49) var -> prop .
    (81) factor -> prop .
    (90) call -> prop . ( args )

    =               reduce using rule 49 (var -> prop .)
    *               reduce using rule 81 (factor -> prop .)
    /               reduce using rule 81 (factor -> prop .)
    +               reduce using rule 81 (factor -> prop .)
    -               reduce using rule 81 (factor -> prop .)
    <               reduce using rule 81 (factor -> prop .)
    >               reduce using rule 81 (factor -> prop .)
    EQ              reduce using rule 81 (factor -> prop .)
    NE              reduce using rule 81 (factor -> prop .)
    LE              reduce using rule 81 (factor -> prop .)
    GE              reduce using rule 81 (factor -> prop .)
    AND             reduce using rule 81 (factor -> prop .)
    OR              reduce using rule 81 (factor -> prop .)
    ,               reduce using rule 81 (factor -> prop .)
    )               reduce using rule 81 (factor -> prop .)
    ;               reduce using rule 81 (factor -> prop .)
    (               shift and go to state 74


state 33

    (64) math_comp -> math_exp . math_comp_alt
    (65) math_comp_alt -> . comparison_op math_exp new_quad
    (66) math_comp_alt -> . empty
    (67) comparison_op -> . <
    (68) comparison_op -> . >
    (69) comparison_op -> . EQ
    (70) comparison_op -> . NE
    (71) comparison_op -> . LE
    (72) comparison_op -> . GE
    (99) empty -> .

    <               shift and go to state 81
    >               shift and go to state 83
    EQ              shift and go to state 80
    NE              shift and go to state 77
    LE              shift and go to state 76
    GE              shift and go to state 79
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_comp_alt                  shift and go to state 78
    comparison_op                  shift and go to state 75
    empty                          shift and go to state 82

state 34

    (29) declaration -> $ . attr
    (30) attr -> . ID : type
    (31) attr -> . ID : stack_type

    ID              shift and go to state 61

    attr                           shift and go to state 84

state 35

    (84) factor -> ( . math_or )
    (58) math_or -> . math_and math_or_alt
    (61) math_and -> . math_comp math_and_alt
    (64) math_comp -> . math_exp math_comp_alt
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 35
    THIS            shift and go to state 53
    ID              shift and go to state 87
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 85
    term                           shift and go to state 50
    math_and                       shift and go to state 43
    math_comp                      shift and go to state 46
    number                         shift and go to state 26
    prop                           shift and go to state 86
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39

state 36

    (40) exp -> read .

    ;               reduce using rule 40 (exp -> read .)
    ,               reduce using rule 40 (exp -> read .)
    )               reduce using rule 40 (exp -> read .)


state 37

    (83) factor -> call .

    *               reduce using rule 83 (factor -> call .)
    /               reduce using rule 83 (factor -> call .)
    +               reduce using rule 83 (factor -> call .)
    -               reduce using rule 83 (factor -> call .)
    <               reduce using rule 83 (factor -> call .)
    >               reduce using rule 83 (factor -> call .)
    EQ              reduce using rule 83 (factor -> call .)
    NE              reduce using rule 83 (factor -> call .)
    LE              reduce using rule 83 (factor -> call .)
    GE              reduce using rule 83 (factor -> call .)
    AND             reduce using rule 83 (factor -> call .)
    OR              reduce using rule 83 (factor -> call .)
    ,               reduce using rule 83 (factor -> call .)
    )               reduce using rule 83 (factor -> call .)
    ;               reduce using rule 83 (factor -> call .)


state 38

    (22) statements -> statement . statements
    (22) statements -> . statement statements
    (23) statements -> . empty
    (24) statement -> . declaration ;
    (25) statement -> . print_stmt
    (26) statement -> . if_block
    (27) statement -> . while_block
    (28) statement -> . expr
    (99) empty -> .
    (29) declaration -> . $ attr
    (38) print_stmt -> . PRINT ( exp ) ;
    (95) if_block -> . IF ( exp exp_evaluation ) block
    (96) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (97) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (39) expr -> . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    $end            reduce using rule 99 (empty -> .)
    }               reduce using rule 99 (empty -> .)
    RETURN          reduce using rule 99 (empty -> .)
    $               shift and go to state 34
    PRINT           shift and go to state 30
    IF              shift and go to state 49
    WHILE           shift and go to state 27
    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    statements                     shift and go to state 88
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    string                         shift and go to state 44
    math_exp                       shift and go to state 33
    prop                           shift and go to state 32
    read                           shift and go to state 36
    call                           shift and go to state 37
    statement                      shift and go to state 38
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    empty                          shift and go to state 42
    math_and                       shift and go to state 43
    print_stmt                     shift and go to state 45
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 47
    term                           shift and go to state 50
    expr                           shift and go to state 51
    if_block                       shift and go to state 52
    while_block                    shift and go to state 54
    exp                            shift and go to state 55
    assign                         shift and go to state 57

state 39

    (77) term -> factor . term_alt
    (78) term_alt -> . * factor new_quad term_alt
    (79) term_alt -> . / factor new_quad term_alt
    (80) term_alt -> . empty
    (99) empty -> .

    *               shift and go to state 90
    /               shift and go to state 91
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 92
    term_alt                       shift and go to state 89

state 40

    (47) assign -> var . = exp

    =               shift and go to state 93


state 41

    (44) exp -> new .

    ;               reduce using rule 44 (exp -> new .)
    ,               reduce using rule 44 (exp -> new .)
    )               reduce using rule 44 (exp -> new .)


state 42

    (23) statements -> empty .

    RETURN          reduce using rule 23 (statements -> empty .)
    }               reduce using rule 23 (statements -> empty .)
    $end            reduce using rule 23 (statements -> empty .)


state 43

    (58) math_or -> math_and . math_or_alt
    (59) math_or_alt -> . OR math_and new_quad math_or_alt
    (60) math_or_alt -> . empty
    (99) empty -> .

    OR              shift and go to state 96
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_or_alt                    shift and go to state 94
    empty                          shift and go to state 95

state 44

    (43) exp -> string .

    ;               reduce using rule 43 (exp -> string .)
    ,               reduce using rule 43 (exp -> string .)
    )               reduce using rule 43 (exp -> string .)


state 45

    (25) statement -> print_stmt .

    $               reduce using rule 25 (statement -> print_stmt .)
    PRINT           reduce using rule 25 (statement -> print_stmt .)
    IF              reduce using rule 25 (statement -> print_stmt .)
    WHILE           reduce using rule 25 (statement -> print_stmt .)
    READ            reduce using rule 25 (statement -> print_stmt .)
    STRING          reduce using rule 25 (statement -> print_stmt .)
    NEW             reduce using rule 25 (statement -> print_stmt .)
    ID              reduce using rule 25 (statement -> print_stmt .)
    THIS            reduce using rule 25 (statement -> print_stmt .)
    (               reduce using rule 25 (statement -> print_stmt .)
    FLOAT           reduce using rule 25 (statement -> print_stmt .)
    INT             reduce using rule 25 (statement -> print_stmt .)
    }               reduce using rule 25 (statement -> print_stmt .)
    RETURN          reduce using rule 25 (statement -> print_stmt .)
    $end            reduce using rule 25 (statement -> print_stmt .)


state 46

    (61) math_and -> math_comp . math_and_alt
    (62) math_and_alt -> . AND math_comp new_quad math_and_alt
    (63) math_and_alt -> . empty
    (99) empty -> .

    AND             shift and go to state 97
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_and_alt                   shift and go to state 98
    empty                          shift and go to state 99

state 47

    (24) statement -> declaration . ;
    (50) var -> declaration .

    ;               shift and go to state 100
    =               reduce using rule 50 (var -> declaration .)


state 48

    (53) stack_call -> ID . . stack_method
    (86) prop -> ID . . ID
    (87) prop -> ID .

    .               shift and go to state 101
    (               reduce using rule 87 (prop -> ID .)
    =               reduce using rule 87 (prop -> ID .)
    *               reduce using rule 87 (prop -> ID .)
    /               reduce using rule 87 (prop -> ID .)
    +               reduce using rule 87 (prop -> ID .)
    -               reduce using rule 87 (prop -> ID .)
    <               reduce using rule 87 (prop -> ID .)
    >               reduce using rule 87 (prop -> ID .)
    EQ              reduce using rule 87 (prop -> ID .)
    NE              reduce using rule 87 (prop -> ID .)
    LE              reduce using rule 87 (prop -> ID .)
    GE              reduce using rule 87 (prop -> ID .)
    AND             reduce using rule 87 (prop -> ID .)
    OR              reduce using rule 87 (prop -> ID .)
    ;               reduce using rule 87 (prop -> ID .)
    ,               reduce using rule 87 (prop -> ID .)
    )               reduce using rule 87 (prop -> ID .)


state 49

    (95) if_block -> IF . ( exp exp_evaluation ) block
    (96) if_block -> IF . ( exp exp_evaluation ) block after_if_block ELSE block

    (               shift and go to state 102


state 50

    (73) math_exp -> term . math_exp_alt
    (74) math_exp_alt -> . + term new_quad math_exp_alt
    (75) math_exp_alt -> . - term new_quad math_exp_alt
    (76) math_exp_alt -> . empty
    (99) empty -> .

    +               shift and go to state 105
    -               shift and go to state 104
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_exp_alt                   shift and go to state 103
    empty                          shift and go to state 106

state 51

    (28) statement -> expr .

    $               reduce using rule 28 (statement -> expr .)
    PRINT           reduce using rule 28 (statement -> expr .)
    IF              reduce using rule 28 (statement -> expr .)
    WHILE           reduce using rule 28 (statement -> expr .)
    READ            reduce using rule 28 (statement -> expr .)
    STRING          reduce using rule 28 (statement -> expr .)
    NEW             reduce using rule 28 (statement -> expr .)
    ID              reduce using rule 28 (statement -> expr .)
    THIS            reduce using rule 28 (statement -> expr .)
    (               reduce using rule 28 (statement -> expr .)
    FLOAT           reduce using rule 28 (statement -> expr .)
    INT             reduce using rule 28 (statement -> expr .)
    }               reduce using rule 28 (statement -> expr .)
    RETURN          reduce using rule 28 (statement -> expr .)
    $end            reduce using rule 28 (statement -> expr .)


state 52

    (26) statement -> if_block .

    $               reduce using rule 26 (statement -> if_block .)
    PRINT           reduce using rule 26 (statement -> if_block .)
    IF              reduce using rule 26 (statement -> if_block .)
    WHILE           reduce using rule 26 (statement -> if_block .)
    READ            reduce using rule 26 (statement -> if_block .)
    STRING          reduce using rule 26 (statement -> if_block .)
    NEW             reduce using rule 26 (statement -> if_block .)
    ID              reduce using rule 26 (statement -> if_block .)
    THIS            reduce using rule 26 (statement -> if_block .)
    (               reduce using rule 26 (statement -> if_block .)
    FLOAT           reduce using rule 26 (statement -> if_block .)
    INT             reduce using rule 26 (statement -> if_block .)
    }               reduce using rule 26 (statement -> if_block .)
    RETURN          reduce using rule 26 (statement -> if_block .)
    $end            reduce using rule 26 (statement -> if_block .)


state 53

    (85) prop -> THIS . . ID

    .               shift and go to state 107


state 54

    (27) statement -> while_block .

    $               reduce using rule 27 (statement -> while_block .)
    PRINT           reduce using rule 27 (statement -> while_block .)
    IF              reduce using rule 27 (statement -> while_block .)
    WHILE           reduce using rule 27 (statement -> while_block .)
    READ            reduce using rule 27 (statement -> while_block .)
    STRING          reduce using rule 27 (statement -> while_block .)
    NEW             reduce using rule 27 (statement -> while_block .)
    ID              reduce using rule 27 (statement -> while_block .)
    THIS            reduce using rule 27 (statement -> while_block .)
    (               reduce using rule 27 (statement -> while_block .)
    FLOAT           reduce using rule 27 (statement -> while_block .)
    INT             reduce using rule 27 (statement -> while_block .)
    }               reduce using rule 27 (statement -> while_block .)
    RETURN          reduce using rule 27 (statement -> while_block .)
    $end            reduce using rule 27 (statement -> while_block .)


state 55

    (39) expr -> exp . ;

    ;               shift and go to state 108


state 56

    (89) number -> INT .

    *               reduce using rule 89 (number -> INT .)
    /               reduce using rule 89 (number -> INT .)
    +               reduce using rule 89 (number -> INT .)
    -               reduce using rule 89 (number -> INT .)
    <               reduce using rule 89 (number -> INT .)
    >               reduce using rule 89 (number -> INT .)
    EQ              reduce using rule 89 (number -> INT .)
    NE              reduce using rule 89 (number -> INT .)
    LE              reduce using rule 89 (number -> INT .)
    GE              reduce using rule 89 (number -> INT .)
    AND             reduce using rule 89 (number -> INT .)
    OR              reduce using rule 89 (number -> INT .)
    ;               reduce using rule 89 (number -> INT .)
    )               reduce using rule 89 (number -> INT .)
    ,               reduce using rule 89 (number -> INT .)


state 57

    (42) exp -> assign .

    ;               reduce using rule 42 (exp -> assign .)
    ,               reduce using rule 42 (exp -> assign .)
    )               reduce using rule 42 (exp -> assign .)


state 58

    (16) function -> # ID neg_lookup . : return_type params scope_function func_block

    :               shift and go to state 109


state 59

    (104) neg_lookup -> empty .

    :               reduce using rule 104 (neg_lookup -> empty .)


state 60

    (8) params -> ( attrs . )

    )               shift and go to state 110


state 61

    (30) attr -> ID . : type
    (31) attr -> ID . : stack_type

    :               shift and go to state 111


state 62

    (10) attrs -> empty .

    )               reduce using rule 10 (attrs -> empty .)


state 63

    (9) attrs -> attr . attrs_alt
    (11) attrs_alt -> . , attr attrs_alt
    (12) attrs_alt -> . empty
    (99) empty -> .

    ,               shift and go to state 112
    )               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 113
    attrs_alt                      shift and go to state 114

state 64

    (5) class -> @ ID inheritance params scope_class . class_block
    (13) class_block -> . { functions }

    {               shift and go to state 116

    class_block                    shift and go to state 115

state 65

    (101) scope_class -> empty .

    {               reduce using rule 101 (scope_class -> empty .)


state 66

    (103) check_class -> empty .

    (               reduce using rule 103 (check_class -> empty .)
    ,               reduce using rule 103 (check_class -> empty .)
    )               reduce using rule 103 (check_class -> empty .)
    ;               reduce using rule 103 (check_class -> empty .)
    =               reduce using rule 103 (check_class -> empty .)
    >               reduce using rule 103 (check_class -> empty .)


state 67

    (6) inheritance -> < ID check_class . >

    >               shift and go to state 117


state 68

    (88) number -> FLOAT empty .

    *               reduce using rule 88 (number -> FLOAT empty .)
    /               reduce using rule 88 (number -> FLOAT empty .)
    +               reduce using rule 88 (number -> FLOAT empty .)
    -               reduce using rule 88 (number -> FLOAT empty .)
    <               reduce using rule 88 (number -> FLOAT empty .)
    >               reduce using rule 88 (number -> FLOAT empty .)
    EQ              reduce using rule 88 (number -> FLOAT empty .)
    NE              reduce using rule 88 (number -> FLOAT empty .)
    LE              reduce using rule 88 (number -> FLOAT empty .)
    GE              reduce using rule 88 (number -> FLOAT empty .)
    AND             reduce using rule 88 (number -> FLOAT empty .)
    OR              reduce using rule 88 (number -> FLOAT empty .)
    ;               reduce using rule 88 (number -> FLOAT empty .)
    )               reduce using rule 88 (number -> FLOAT empty .)
    ,               reduce using rule 88 (number -> FLOAT empty .)


state 69

    (46) read -> READ ( . )

    )               shift and go to state 118


state 70

    (97) while_block -> WHILE ( . leave_breadcrumb exp exp_evaluation ) block
    (107) leave_breadcrumb -> . empty
    (99) empty -> .

    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    $               reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)

    empty                          shift and go to state 120
    leave_breadcrumb               shift and go to state 119

state 71

    (51) new -> NEW constructor_call .

    ;               reduce using rule 51 (new -> NEW constructor_call .)
    ,               reduce using rule 51 (new -> NEW constructor_call .)
    )               reduce using rule 51 (new -> NEW constructor_call .)


state 72

    (52) constructor_call -> ID . ( args )

    (               shift and go to state 121


state 73

    (38) print_stmt -> PRINT ( . exp ) ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (29) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    $               shift and go to state 34
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    prop                           shift and go to state 32
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    read                           shift and go to state 36
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 122
    term                           shift and go to state 50
    exp                            shift and go to state 123
    assign                         shift and go to state 57

state 74

    (90) call -> prop ( . args )
    (91) args -> . exp args_aux
    (92) args -> . empty
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (99) empty -> .
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (29) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    )               reduce using rule 99 (empty -> .)
    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    $               shift and go to state 34
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    prop                           shift and go to state 32
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    empty                          shift and go to state 124
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    read                           shift and go to state 36
    math_comp                      shift and go to state 46
    args                           shift and go to state 125
    declaration                    shift and go to state 122
    term                           shift and go to state 50
    exp                            shift and go to state 126
    assign                         shift and go to state 57

state 75

    (65) math_comp_alt -> comparison_op . math_exp new_quad
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 35
    THIS            shift and go to state 53
    ID              shift and go to state 87
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    term                           shift and go to state 50
    prop                           shift and go to state 86
    call                           shift and go to state 37
    math_exp                       shift and go to state 127
    factor                         shift and go to state 39
    number                         shift and go to state 26

state 76

    (71) comparison_op -> LE .

    (               reduce using rule 71 (comparison_op -> LE .)
    THIS            reduce using rule 71 (comparison_op -> LE .)
    ID              reduce using rule 71 (comparison_op -> LE .)
    FLOAT           reduce using rule 71 (comparison_op -> LE .)
    INT             reduce using rule 71 (comparison_op -> LE .)


state 77

    (70) comparison_op -> NE .

    (               reduce using rule 70 (comparison_op -> NE .)
    THIS            reduce using rule 70 (comparison_op -> NE .)
    ID              reduce using rule 70 (comparison_op -> NE .)
    FLOAT           reduce using rule 70 (comparison_op -> NE .)
    INT             reduce using rule 70 (comparison_op -> NE .)


state 78

    (64) math_comp -> math_exp math_comp_alt .

    AND             reduce using rule 64 (math_comp -> math_exp math_comp_alt .)
    OR              reduce using rule 64 (math_comp -> math_exp math_comp_alt .)
    ;               reduce using rule 64 (math_comp -> math_exp math_comp_alt .)
    )               reduce using rule 64 (math_comp -> math_exp math_comp_alt .)
    ,               reduce using rule 64 (math_comp -> math_exp math_comp_alt .)


state 79

    (72) comparison_op -> GE .

    (               reduce using rule 72 (comparison_op -> GE .)
    THIS            reduce using rule 72 (comparison_op -> GE .)
    ID              reduce using rule 72 (comparison_op -> GE .)
    FLOAT           reduce using rule 72 (comparison_op -> GE .)
    INT             reduce using rule 72 (comparison_op -> GE .)


state 80

    (69) comparison_op -> EQ .

    (               reduce using rule 69 (comparison_op -> EQ .)
    THIS            reduce using rule 69 (comparison_op -> EQ .)
    ID              reduce using rule 69 (comparison_op -> EQ .)
    FLOAT           reduce using rule 69 (comparison_op -> EQ .)
    INT             reduce using rule 69 (comparison_op -> EQ .)


state 81

    (67) comparison_op -> < .

    (               reduce using rule 67 (comparison_op -> < .)
    THIS            reduce using rule 67 (comparison_op -> < .)
    ID              reduce using rule 67 (comparison_op -> < .)
    FLOAT           reduce using rule 67 (comparison_op -> < .)
    INT             reduce using rule 67 (comparison_op -> < .)


state 82

    (66) math_comp_alt -> empty .

    AND             reduce using rule 66 (math_comp_alt -> empty .)
    OR              reduce using rule 66 (math_comp_alt -> empty .)
    ;               reduce using rule 66 (math_comp_alt -> empty .)
    )               reduce using rule 66 (math_comp_alt -> empty .)
    ,               reduce using rule 66 (math_comp_alt -> empty .)


state 83

    (68) comparison_op -> > .

    (               reduce using rule 68 (comparison_op -> > .)
    THIS            reduce using rule 68 (comparison_op -> > .)
    ID              reduce using rule 68 (comparison_op -> > .)
    FLOAT           reduce using rule 68 (comparison_op -> > .)
    INT             reduce using rule 68 (comparison_op -> > .)


state 84

    (29) declaration -> $ attr .

    =               reduce using rule 29 (declaration -> $ attr .)
    ;               reduce using rule 29 (declaration -> $ attr .)


state 85

    (84) factor -> ( math_or . )

    )               shift and go to state 128


state 86

    (81) factor -> prop .
    (90) call -> prop . ( args )

    *               reduce using rule 81 (factor -> prop .)
    /               reduce using rule 81 (factor -> prop .)
    +               reduce using rule 81 (factor -> prop .)
    -               reduce using rule 81 (factor -> prop .)
    <               reduce using rule 81 (factor -> prop .)
    >               reduce using rule 81 (factor -> prop .)
    EQ              reduce using rule 81 (factor -> prop .)
    NE              reduce using rule 81 (factor -> prop .)
    LE              reduce using rule 81 (factor -> prop .)
    GE              reduce using rule 81 (factor -> prop .)
    AND             reduce using rule 81 (factor -> prop .)
    OR              reduce using rule 81 (factor -> prop .)
    ;               reduce using rule 81 (factor -> prop .)
    )               reduce using rule 81 (factor -> prop .)
    ,               reduce using rule 81 (factor -> prop .)
    (               shift and go to state 74


state 87

    (86) prop -> ID . . ID
    (87) prop -> ID .

    .               shift and go to state 129
    (               reduce using rule 87 (prop -> ID .)
    *               reduce using rule 87 (prop -> ID .)
    /               reduce using rule 87 (prop -> ID .)
    +               reduce using rule 87 (prop -> ID .)
    -               reduce using rule 87 (prop -> ID .)
    AND             reduce using rule 87 (prop -> ID .)
    OR              reduce using rule 87 (prop -> ID .)
    ;               reduce using rule 87 (prop -> ID .)
    )               reduce using rule 87 (prop -> ID .)
    ,               reduce using rule 87 (prop -> ID .)
    <               reduce using rule 87 (prop -> ID .)
    >               reduce using rule 87 (prop -> ID .)
    EQ              reduce using rule 87 (prop -> ID .)
    NE              reduce using rule 87 (prop -> ID .)
    LE              reduce using rule 87 (prop -> ID .)
    GE              reduce using rule 87 (prop -> ID .)


state 88

    (22) statements -> statement statements .

    RETURN          reduce using rule 22 (statements -> statement statements .)
    }               reduce using rule 22 (statements -> statement statements .)
    $end            reduce using rule 22 (statements -> statement statements .)


state 89

    (77) term -> factor term_alt .

    +               reduce using rule 77 (term -> factor term_alt .)
    -               reduce using rule 77 (term -> factor term_alt .)
    AND             reduce using rule 77 (term -> factor term_alt .)
    OR              reduce using rule 77 (term -> factor term_alt .)
    ;               reduce using rule 77 (term -> factor term_alt .)
    )               reduce using rule 77 (term -> factor term_alt .)
    ,               reduce using rule 77 (term -> factor term_alt .)
    <               reduce using rule 77 (term -> factor term_alt .)
    >               reduce using rule 77 (term -> factor term_alt .)
    EQ              reduce using rule 77 (term -> factor term_alt .)
    NE              reduce using rule 77 (term -> factor term_alt .)
    LE              reduce using rule 77 (term -> factor term_alt .)
    GE              reduce using rule 77 (term -> factor term_alt .)


state 90

    (78) term_alt -> * . factor new_quad term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 35
    THIS            shift and go to state 53
    ID              shift and go to state 87
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    number                         shift and go to state 26
    prop                           shift and go to state 86
    call                           shift and go to state 37
    factor                         shift and go to state 130

state 91

    (79) term_alt -> / . factor new_quad term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 35
    THIS            shift and go to state 53
    ID              shift and go to state 87
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    number                         shift and go to state 26
    prop                           shift and go to state 86
    call                           shift and go to state 37
    factor                         shift and go to state 131

state 92

    (80) term_alt -> empty .

    +               reduce using rule 80 (term_alt -> empty .)
    -               reduce using rule 80 (term_alt -> empty .)
    <               reduce using rule 80 (term_alt -> empty .)
    >               reduce using rule 80 (term_alt -> empty .)
    EQ              reduce using rule 80 (term_alt -> empty .)
    NE              reduce using rule 80 (term_alt -> empty .)
    LE              reduce using rule 80 (term_alt -> empty .)
    GE              reduce using rule 80 (term_alt -> empty .)
    AND             reduce using rule 80 (term_alt -> empty .)
    OR              reduce using rule 80 (term_alt -> empty .)
    ;               reduce using rule 80 (term_alt -> empty .)
    )               reduce using rule 80 (term_alt -> empty .)
    ,               reduce using rule 80 (term_alt -> empty .)


state 93

    (47) assign -> var = . exp
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (29) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    $               shift and go to state 34
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    prop                           shift and go to state 32
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    read                           shift and go to state 36
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 122
    term                           shift and go to state 50
    exp                            shift and go to state 132
    assign                         shift and go to state 57

state 94

    (58) math_or -> math_and math_or_alt .

    ;               reduce using rule 58 (math_or -> math_and math_or_alt .)
    ,               reduce using rule 58 (math_or -> math_and math_or_alt .)
    )               reduce using rule 58 (math_or -> math_and math_or_alt .)


state 95

    (60) math_or_alt -> empty .

    ;               reduce using rule 60 (math_or_alt -> empty .)
    )               reduce using rule 60 (math_or_alt -> empty .)
    ,               reduce using rule 60 (math_or_alt -> empty .)


state 96

    (59) math_or_alt -> OR . math_and new_quad math_or_alt
    (61) math_and -> . math_comp math_and_alt
    (64) math_comp -> . math_exp math_comp_alt
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 35
    THIS            shift and go to state 53
    ID              shift and go to state 87
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    term                           shift and go to state 50
    math_comp                      shift and go to state 46
    number                         shift and go to state 26
    prop                           shift and go to state 86
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    math_and                       shift and go to state 133

state 97

    (62) math_and_alt -> AND . math_comp new_quad math_and_alt
    (64) math_comp -> . math_exp math_comp_alt
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 35
    THIS            shift and go to state 53
    ID              shift and go to state 87
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    term                           shift and go to state 50
    math_comp                      shift and go to state 134
    number                         shift and go to state 26
    prop                           shift and go to state 86
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39

state 98

    (61) math_and -> math_comp math_and_alt .

    OR              reduce using rule 61 (math_and -> math_comp math_and_alt .)
    ;               reduce using rule 61 (math_and -> math_comp math_and_alt .)
    )               reduce using rule 61 (math_and -> math_comp math_and_alt .)
    ,               reduce using rule 61 (math_and -> math_comp math_and_alt .)


state 99

    (63) math_and_alt -> empty .

    OR              reduce using rule 63 (math_and_alt -> empty .)
    ;               reduce using rule 63 (math_and_alt -> empty .)
    )               reduce using rule 63 (math_and_alt -> empty .)
    ,               reduce using rule 63 (math_and_alt -> empty .)


state 100

    (24) statement -> declaration ; .

    $               reduce using rule 24 (statement -> declaration ; .)
    PRINT           reduce using rule 24 (statement -> declaration ; .)
    IF              reduce using rule 24 (statement -> declaration ; .)
    WHILE           reduce using rule 24 (statement -> declaration ; .)
    READ            reduce using rule 24 (statement -> declaration ; .)
    STRING          reduce using rule 24 (statement -> declaration ; .)
    NEW             reduce using rule 24 (statement -> declaration ; .)
    ID              reduce using rule 24 (statement -> declaration ; .)
    THIS            reduce using rule 24 (statement -> declaration ; .)
    (               reduce using rule 24 (statement -> declaration ; .)
    FLOAT           reduce using rule 24 (statement -> declaration ; .)
    INT             reduce using rule 24 (statement -> declaration ; .)
    }               reduce using rule 24 (statement -> declaration ; .)
    RETURN          reduce using rule 24 (statement -> declaration ; .)
    $end            reduce using rule 24 (statement -> declaration ; .)


state 101

    (53) stack_call -> ID . . stack_method
    (86) prop -> ID . . ID
    (54) stack_method -> . POP ( )
    (55) stack_method -> . PUSH ( exp )
    (56) stack_method -> . PEEK ( )
    (57) stack_method -> . SIZE ( )

    ID              shift and go to state 139
    POP             shift and go to state 137
    PUSH            shift and go to state 138
    PEEK            shift and go to state 135
    SIZE            shift and go to state 140

    stack_method                   shift and go to state 136

state 102

    (95) if_block -> IF ( . exp exp_evaluation ) block
    (96) if_block -> IF ( . exp exp_evaluation ) block after_if_block ELSE block
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (29) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    $               shift and go to state 34
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    prop                           shift and go to state 32
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    read                           shift and go to state 36
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 122
    term                           shift and go to state 50
    exp                            shift and go to state 141
    assign                         shift and go to state 57

state 103

    (73) math_exp -> term math_exp_alt .

    AND             reduce using rule 73 (math_exp -> term math_exp_alt .)
    OR              reduce using rule 73 (math_exp -> term math_exp_alt .)
    ;               reduce using rule 73 (math_exp -> term math_exp_alt .)
    )               reduce using rule 73 (math_exp -> term math_exp_alt .)
    ,               reduce using rule 73 (math_exp -> term math_exp_alt .)
    <               reduce using rule 73 (math_exp -> term math_exp_alt .)
    >               reduce using rule 73 (math_exp -> term math_exp_alt .)
    EQ              reduce using rule 73 (math_exp -> term math_exp_alt .)
    NE              reduce using rule 73 (math_exp -> term math_exp_alt .)
    LE              reduce using rule 73 (math_exp -> term math_exp_alt .)
    GE              reduce using rule 73 (math_exp -> term math_exp_alt .)


state 104

    (75) math_exp_alt -> - . term new_quad math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 35
    THIS            shift and go to state 53
    ID              shift and go to state 87
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    term                           shift and go to state 142
    number                         shift and go to state 26
    prop                           shift and go to state 86
    call                           shift and go to state 37
    factor                         shift and go to state 39

state 105

    (74) math_exp_alt -> + . term new_quad math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 35
    THIS            shift and go to state 53
    ID              shift and go to state 87
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    term                           shift and go to state 143
    number                         shift and go to state 26
    prop                           shift and go to state 86
    call                           shift and go to state 37
    factor                         shift and go to state 39

state 106

    (76) math_exp_alt -> empty .

    <               reduce using rule 76 (math_exp_alt -> empty .)
    >               reduce using rule 76 (math_exp_alt -> empty .)
    EQ              reduce using rule 76 (math_exp_alt -> empty .)
    NE              reduce using rule 76 (math_exp_alt -> empty .)
    LE              reduce using rule 76 (math_exp_alt -> empty .)
    GE              reduce using rule 76 (math_exp_alt -> empty .)
    AND             reduce using rule 76 (math_exp_alt -> empty .)
    OR              reduce using rule 76 (math_exp_alt -> empty .)
    ;               reduce using rule 76 (math_exp_alt -> empty .)
    )               reduce using rule 76 (math_exp_alt -> empty .)
    ,               reduce using rule 76 (math_exp_alt -> empty .)


state 107

    (85) prop -> THIS . . ID

    ID              shift and go to state 144


state 108

    (39) expr -> exp ; .

    $               reduce using rule 39 (expr -> exp ; .)
    PRINT           reduce using rule 39 (expr -> exp ; .)
    IF              reduce using rule 39 (expr -> exp ; .)
    WHILE           reduce using rule 39 (expr -> exp ; .)
    READ            reduce using rule 39 (expr -> exp ; .)
    STRING          reduce using rule 39 (expr -> exp ; .)
    NEW             reduce using rule 39 (expr -> exp ; .)
    ID              reduce using rule 39 (expr -> exp ; .)
    THIS            reduce using rule 39 (expr -> exp ; .)
    (               reduce using rule 39 (expr -> exp ; .)
    FLOAT           reduce using rule 39 (expr -> exp ; .)
    INT             reduce using rule 39 (expr -> exp ; .)
    $end            reduce using rule 39 (expr -> exp ; .)
    }               reduce using rule 39 (expr -> exp ; .)
    RETURN          reduce using rule 39 (expr -> exp ; .)


state 109

    (16) function -> # ID neg_lookup : . return_type params scope_function func_block
    (17) return_type -> . VOID
    (18) return_type -> . type
    (32) type -> . INT_TYPE
    (33) type -> . FLOAT_TYPE
    (34) type -> . STRING_TYPE
    (35) type -> . BOOLEAN_TYPE
    (36) type -> . ID check_class

    VOID            shift and go to state 146
    INT_TYPE        shift and go to state 149
    FLOAT_TYPE      shift and go to state 145
    STRING_TYPE     shift and go to state 148
    BOOLEAN_TYPE    shift and go to state 147
    ID              shift and go to state 152

    return_type                    shift and go to state 150
    type                           shift and go to state 151

state 110

    (8) params -> ( attrs ) .

    {               reduce using rule 8 (params -> ( attrs ) .)


state 111

    (30) attr -> ID : . type
    (31) attr -> ID : . stack_type
    (32) type -> . INT_TYPE
    (33) type -> . FLOAT_TYPE
    (34) type -> . STRING_TYPE
    (35) type -> . BOOLEAN_TYPE
    (36) type -> . ID check_class
    (37) stack_type -> . STACK ( type )

    INT_TYPE        shift and go to state 149
    FLOAT_TYPE      shift and go to state 145
    STRING_TYPE     shift and go to state 148
    BOOLEAN_TYPE    shift and go to state 147
    ID              shift and go to state 152
    STACK           shift and go to state 154

    type                           shift and go to state 155
    stack_type                     shift and go to state 153

state 112

    (11) attrs_alt -> , . attr attrs_alt
    (30) attr -> . ID : type
    (31) attr -> . ID : stack_type

    ID              shift and go to state 61

    attr                           shift and go to state 156

state 113

    (12) attrs_alt -> empty .

    )               reduce using rule 12 (attrs_alt -> empty .)


state 114

    (9) attrs -> attr attrs_alt .

    )               reduce using rule 9 (attrs -> attr attrs_alt .)


state 115

    (5) class -> @ ID inheritance params scope_class class_block .

    @               reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    #               reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    $               reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    PRINT           reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    IF              reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    WHILE           reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    READ            reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    STRING          reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    NEW             reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    ID              reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    THIS            reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    (               reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    FLOAT           reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    INT             reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    $end            reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)


state 116

    (13) class_block -> { . functions }
    (14) functions -> . function functions
    (15) functions -> . empty
    (16) function -> . # ID neg_lookup : return_type params scope_function func_block
    (99) empty -> .

    #               shift and go to state 9
    }               reduce using rule 99 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 157
    empty                          shift and go to state 10

state 117

    (6) inheritance -> < ID check_class > .

    (               reduce using rule 6 (inheritance -> < ID check_class > .)


state 118

    (46) read -> READ ( ) .

    ;               reduce using rule 46 (read -> READ ( ) .)
    )               reduce using rule 46 (read -> READ ( ) .)
    ,               reduce using rule 46 (read -> READ ( ) .)


state 119

    (97) while_block -> WHILE ( leave_breadcrumb . exp exp_evaluation ) block
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (29) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    $               shift and go to state 34
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    prop                           shift and go to state 32
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    read                           shift and go to state 36
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 122
    term                           shift and go to state 50
    exp                            shift and go to state 158
    assign                         shift and go to state 57

state 120

    (107) leave_breadcrumb -> empty .

    READ            reduce using rule 107 (leave_breadcrumb -> empty .)
    STRING          reduce using rule 107 (leave_breadcrumb -> empty .)
    NEW             reduce using rule 107 (leave_breadcrumb -> empty .)
    ID              reduce using rule 107 (leave_breadcrumb -> empty .)
    THIS            reduce using rule 107 (leave_breadcrumb -> empty .)
    $               reduce using rule 107 (leave_breadcrumb -> empty .)
    (               reduce using rule 107 (leave_breadcrumb -> empty .)
    FLOAT           reduce using rule 107 (leave_breadcrumb -> empty .)
    INT             reduce using rule 107 (leave_breadcrumb -> empty .)


state 121

    (52) constructor_call -> ID ( . args )
    (91) args -> . exp args_aux
    (92) args -> . empty
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (99) empty -> .
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (29) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    )               reduce using rule 99 (empty -> .)
    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    $               shift and go to state 34
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    prop                           shift and go to state 32
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    empty                          shift and go to state 124
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    read                           shift and go to state 36
    math_comp                      shift and go to state 46
    args                           shift and go to state 159
    declaration                    shift and go to state 122
    term                           shift and go to state 50
    exp                            shift and go to state 126
    assign                         shift and go to state 57

state 122

    (50) var -> declaration .

    =               reduce using rule 50 (var -> declaration .)


state 123

    (38) print_stmt -> PRINT ( exp . ) ;

    )               shift and go to state 160


state 124

    (92) args -> empty .

    )               reduce using rule 92 (args -> empty .)


state 125

    (90) call -> prop ( args . )

    )               shift and go to state 161


state 126

    (91) args -> exp . args_aux
    (93) args_aux -> . , exp args_aux
    (94) args_aux -> . empty
    (99) empty -> .

    ,               shift and go to state 164
    )               reduce using rule 99 (empty -> .)

    args_aux                       shift and go to state 162
    empty                          shift and go to state 163

state 127

    (65) math_comp_alt -> comparison_op math_exp . new_quad
    (100) new_quad -> . empty
    (99) empty -> .

    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 165
    empty                          shift and go to state 166

state 128

    (84) factor -> ( math_or ) .

    *               reduce using rule 84 (factor -> ( math_or ) .)
    /               reduce using rule 84 (factor -> ( math_or ) .)
    +               reduce using rule 84 (factor -> ( math_or ) .)
    -               reduce using rule 84 (factor -> ( math_or ) .)
    <               reduce using rule 84 (factor -> ( math_or ) .)
    >               reduce using rule 84 (factor -> ( math_or ) .)
    EQ              reduce using rule 84 (factor -> ( math_or ) .)
    NE              reduce using rule 84 (factor -> ( math_or ) .)
    LE              reduce using rule 84 (factor -> ( math_or ) .)
    GE              reduce using rule 84 (factor -> ( math_or ) .)
    AND             reduce using rule 84 (factor -> ( math_or ) .)
    OR              reduce using rule 84 (factor -> ( math_or ) .)
    ,               reduce using rule 84 (factor -> ( math_or ) .)
    )               reduce using rule 84 (factor -> ( math_or ) .)
    ;               reduce using rule 84 (factor -> ( math_or ) .)


state 129

    (86) prop -> ID . . ID

    ID              shift and go to state 139


state 130

    (78) term_alt -> * factor . new_quad term_alt
    (100) new_quad -> . empty
    (99) empty -> .

    *               reduce using rule 99 (empty -> .)
    /               reduce using rule 99 (empty -> .)
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 167
    empty                          shift and go to state 166

state 131

    (79) term_alt -> / factor . new_quad term_alt
    (100) new_quad -> . empty
    (99) empty -> .

    *               reduce using rule 99 (empty -> .)
    /               reduce using rule 99 (empty -> .)
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 168
    empty                          shift and go to state 166

state 132

    (47) assign -> var = exp .

    ;               reduce using rule 47 (assign -> var = exp .)
    )               reduce using rule 47 (assign -> var = exp .)
    ,               reduce using rule 47 (assign -> var = exp .)


state 133

    (59) math_or_alt -> OR math_and . new_quad math_or_alt
    (100) new_quad -> . empty
    (99) empty -> .

    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 169
    empty                          shift and go to state 166

state 134

    (62) math_and_alt -> AND math_comp . new_quad math_and_alt
    (100) new_quad -> . empty
    (99) empty -> .

    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 170
    empty                          shift and go to state 166

state 135

    (56) stack_method -> PEEK . ( )

    (               shift and go to state 171


state 136

    (53) stack_call -> ID . stack_method .

    ;               reduce using rule 53 (stack_call -> ID . stack_method .)
    )               reduce using rule 53 (stack_call -> ID . stack_method .)
    ,               reduce using rule 53 (stack_call -> ID . stack_method .)


state 137

    (54) stack_method -> POP . ( )

    (               shift and go to state 172


state 138

    (55) stack_method -> PUSH . ( exp )

    (               shift and go to state 173


state 139

    (86) prop -> ID . ID .

    (               reduce using rule 86 (prop -> ID . ID .)
    *               reduce using rule 86 (prop -> ID . ID .)
    /               reduce using rule 86 (prop -> ID . ID .)
    +               reduce using rule 86 (prop -> ID . ID .)
    -               reduce using rule 86 (prop -> ID . ID .)
    AND             reduce using rule 86 (prop -> ID . ID .)
    OR              reduce using rule 86 (prop -> ID . ID .)
    ;               reduce using rule 86 (prop -> ID . ID .)
    )               reduce using rule 86 (prop -> ID . ID .)
    ,               reduce using rule 86 (prop -> ID . ID .)
    =               reduce using rule 86 (prop -> ID . ID .)
    <               reduce using rule 86 (prop -> ID . ID .)
    >               reduce using rule 86 (prop -> ID . ID .)
    EQ              reduce using rule 86 (prop -> ID . ID .)
    NE              reduce using rule 86 (prop -> ID . ID .)
    LE              reduce using rule 86 (prop -> ID . ID .)
    GE              reduce using rule 86 (prop -> ID . ID .)


state 140

    (57) stack_method -> SIZE . ( )

    (               shift and go to state 174


state 141

    (95) if_block -> IF ( exp . exp_evaluation ) block
    (96) if_block -> IF ( exp . exp_evaluation ) block after_if_block ELSE block
    (105) exp_evaluation -> . empty
    (99) empty -> .

    )               reduce using rule 99 (empty -> .)

    exp_evaluation                 shift and go to state 176
    empty                          shift and go to state 175

state 142

    (75) math_exp_alt -> - term . new_quad math_exp_alt
    (100) new_quad -> . empty
    (99) empty -> .

    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 177
    empty                          shift and go to state 166

state 143

    (74) math_exp_alt -> + term . new_quad math_exp_alt
    (100) new_quad -> . empty
    (99) empty -> .

    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 178
    empty                          shift and go to state 166

state 144

    (85) prop -> THIS . ID .

    (               reduce using rule 85 (prop -> THIS . ID .)
    *               reduce using rule 85 (prop -> THIS . ID .)
    /               reduce using rule 85 (prop -> THIS . ID .)
    +               reduce using rule 85 (prop -> THIS . ID .)
    -               reduce using rule 85 (prop -> THIS . ID .)
    AND             reduce using rule 85 (prop -> THIS . ID .)
    OR              reduce using rule 85 (prop -> THIS . ID .)
    ;               reduce using rule 85 (prop -> THIS . ID .)
    )               reduce using rule 85 (prop -> THIS . ID .)
    ,               reduce using rule 85 (prop -> THIS . ID .)
    =               reduce using rule 85 (prop -> THIS . ID .)
    <               reduce using rule 85 (prop -> THIS . ID .)
    >               reduce using rule 85 (prop -> THIS . ID .)
    EQ              reduce using rule 85 (prop -> THIS . ID .)
    NE              reduce using rule 85 (prop -> THIS . ID .)
    LE              reduce using rule 85 (prop -> THIS . ID .)
    GE              reduce using rule 85 (prop -> THIS . ID .)


state 145

    (33) type -> FLOAT_TYPE .

    )               reduce using rule 33 (type -> FLOAT_TYPE .)
    (               reduce using rule 33 (type -> FLOAT_TYPE .)
    ,               reduce using rule 33 (type -> FLOAT_TYPE .)
    ;               reduce using rule 33 (type -> FLOAT_TYPE .)
    =               reduce using rule 33 (type -> FLOAT_TYPE .)


state 146

    (17) return_type -> VOID .

    (               reduce using rule 17 (return_type -> VOID .)


state 147

    (35) type -> BOOLEAN_TYPE .

    )               reduce using rule 35 (type -> BOOLEAN_TYPE .)
    (               reduce using rule 35 (type -> BOOLEAN_TYPE .)
    ,               reduce using rule 35 (type -> BOOLEAN_TYPE .)
    ;               reduce using rule 35 (type -> BOOLEAN_TYPE .)
    =               reduce using rule 35 (type -> BOOLEAN_TYPE .)


state 148

    (34) type -> STRING_TYPE .

    )               reduce using rule 34 (type -> STRING_TYPE .)
    (               reduce using rule 34 (type -> STRING_TYPE .)
    ,               reduce using rule 34 (type -> STRING_TYPE .)
    ;               reduce using rule 34 (type -> STRING_TYPE .)
    =               reduce using rule 34 (type -> STRING_TYPE .)


state 149

    (32) type -> INT_TYPE .

    )               reduce using rule 32 (type -> INT_TYPE .)
    (               reduce using rule 32 (type -> INT_TYPE .)
    ,               reduce using rule 32 (type -> INT_TYPE .)
    ;               reduce using rule 32 (type -> INT_TYPE .)
    =               reduce using rule 32 (type -> INT_TYPE .)


state 150

    (16) function -> # ID neg_lookup : return_type . params scope_function func_block
    (8) params -> . ( attrs )

    (               shift and go to state 19

    params                         shift and go to state 179

state 151

    (18) return_type -> type .

    (               reduce using rule 18 (return_type -> type .)


state 152

    (36) type -> ID . check_class
    (103) check_class -> . empty
    (99) empty -> .

    (               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    =               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 66
    check_class                    shift and go to state 180

state 153

    (31) attr -> ID : stack_type .

    ,               reduce using rule 31 (attr -> ID : stack_type .)
    )               reduce using rule 31 (attr -> ID : stack_type .)
    ;               reduce using rule 31 (attr -> ID : stack_type .)
    =               reduce using rule 31 (attr -> ID : stack_type .)


state 154

    (37) stack_type -> STACK . ( type )

    (               shift and go to state 181


state 155

    (30) attr -> ID : type .

    ,               reduce using rule 30 (attr -> ID : type .)
    )               reduce using rule 30 (attr -> ID : type .)
    ;               reduce using rule 30 (attr -> ID : type .)
    =               reduce using rule 30 (attr -> ID : type .)


state 156

    (11) attrs_alt -> , attr . attrs_alt
    (11) attrs_alt -> . , attr attrs_alt
    (12) attrs_alt -> . empty
    (99) empty -> .

    ,               shift and go to state 112
    )               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 113
    attrs_alt                      shift and go to state 182

state 157

    (13) class_block -> { functions . }

    }               shift and go to state 183


state 158

    (97) while_block -> WHILE ( leave_breadcrumb exp . exp_evaluation ) block
    (105) exp_evaluation -> . empty
    (99) empty -> .

    )               reduce using rule 99 (empty -> .)

    exp_evaluation                 shift and go to state 184
    empty                          shift and go to state 175

state 159

    (52) constructor_call -> ID ( args . )

    )               shift and go to state 185


state 160

    (38) print_stmt -> PRINT ( exp ) . ;

    ;               shift and go to state 186


state 161

    (90) call -> prop ( args ) .

    *               reduce using rule 90 (call -> prop ( args ) .)
    /               reduce using rule 90 (call -> prop ( args ) .)
    +               reduce using rule 90 (call -> prop ( args ) .)
    -               reduce using rule 90 (call -> prop ( args ) .)
    <               reduce using rule 90 (call -> prop ( args ) .)
    >               reduce using rule 90 (call -> prop ( args ) .)
    EQ              reduce using rule 90 (call -> prop ( args ) .)
    NE              reduce using rule 90 (call -> prop ( args ) .)
    LE              reduce using rule 90 (call -> prop ( args ) .)
    GE              reduce using rule 90 (call -> prop ( args ) .)
    AND             reduce using rule 90 (call -> prop ( args ) .)
    OR              reduce using rule 90 (call -> prop ( args ) .)
    )               reduce using rule 90 (call -> prop ( args ) .)
    ;               reduce using rule 90 (call -> prop ( args ) .)
    ,               reduce using rule 90 (call -> prop ( args ) .)


state 162

    (91) args -> exp args_aux .

    )               reduce using rule 91 (args -> exp args_aux .)


state 163

    (94) args_aux -> empty .

    )               reduce using rule 94 (args_aux -> empty .)


state 164

    (93) args_aux -> , . exp args_aux
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (29) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    $               shift and go to state 34
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    prop                           shift and go to state 32
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    read                           shift and go to state 36
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 122
    term                           shift and go to state 50
    exp                            shift and go to state 187
    assign                         shift and go to state 57

state 165

    (65) math_comp_alt -> comparison_op math_exp new_quad .

    AND             reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)
    OR              reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)
    ;               reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)
    )               reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)
    ,               reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)


state 166

    (100) new_quad -> empty .

    +               reduce using rule 100 (new_quad -> empty .)
    -               reduce using rule 100 (new_quad -> empty .)
    <               reduce using rule 100 (new_quad -> empty .)
    >               reduce using rule 100 (new_quad -> empty .)
    EQ              reduce using rule 100 (new_quad -> empty .)
    NE              reduce using rule 100 (new_quad -> empty .)
    LE              reduce using rule 100 (new_quad -> empty .)
    GE              reduce using rule 100 (new_quad -> empty .)
    AND             reduce using rule 100 (new_quad -> empty .)
    OR              reduce using rule 100 (new_quad -> empty .)
    ;               reduce using rule 100 (new_quad -> empty .)
    )               reduce using rule 100 (new_quad -> empty .)
    ,               reduce using rule 100 (new_quad -> empty .)
    *               reduce using rule 100 (new_quad -> empty .)
    /               reduce using rule 100 (new_quad -> empty .)


state 167

    (78) term_alt -> * factor new_quad . term_alt
    (78) term_alt -> . * factor new_quad term_alt
    (79) term_alt -> . / factor new_quad term_alt
    (80) term_alt -> . empty
    (99) empty -> .

    *               shift and go to state 90
    /               shift and go to state 91
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 92
    term_alt                       shift and go to state 188

state 168

    (79) term_alt -> / factor new_quad . term_alt
    (78) term_alt -> . * factor new_quad term_alt
    (79) term_alt -> . / factor new_quad term_alt
    (80) term_alt -> . empty
    (99) empty -> .

    *               shift and go to state 90
    /               shift and go to state 91
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 92
    term_alt                       shift and go to state 189

state 169

    (59) math_or_alt -> OR math_and new_quad . math_or_alt
    (59) math_or_alt -> . OR math_and new_quad math_or_alt
    (60) math_or_alt -> . empty
    (99) empty -> .

    OR              shift and go to state 96
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_or_alt                    shift and go to state 190
    empty                          shift and go to state 95

state 170

    (62) math_and_alt -> AND math_comp new_quad . math_and_alt
    (62) math_and_alt -> . AND math_comp new_quad math_and_alt
    (63) math_and_alt -> . empty
    (99) empty -> .

    AND             shift and go to state 97
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_and_alt                   shift and go to state 191
    empty                          shift and go to state 99

state 171

    (56) stack_method -> PEEK ( . )

    )               shift and go to state 192


state 172

    (54) stack_method -> POP ( . )

    )               shift and go to state 193


state 173

    (55) stack_method -> PUSH ( . exp )
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (29) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    $               shift and go to state 34
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    prop                           shift and go to state 32
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    read                           shift and go to state 36
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 122
    term                           shift and go to state 50
    exp                            shift and go to state 194
    assign                         shift and go to state 57

state 174

    (57) stack_method -> SIZE ( . )

    )               shift and go to state 195


state 175

    (105) exp_evaluation -> empty .

    )               reduce using rule 105 (exp_evaluation -> empty .)


state 176

    (95) if_block -> IF ( exp exp_evaluation . ) block
    (96) if_block -> IF ( exp exp_evaluation . ) block after_if_block ELSE block

    )               shift and go to state 196


state 177

    (75) math_exp_alt -> - term new_quad . math_exp_alt
    (74) math_exp_alt -> . + term new_quad math_exp_alt
    (75) math_exp_alt -> . - term new_quad math_exp_alt
    (76) math_exp_alt -> . empty
    (99) empty -> .

    +               shift and go to state 105
    -               shift and go to state 104
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_exp_alt                   shift and go to state 197
    empty                          shift and go to state 106

state 178

    (74) math_exp_alt -> + term new_quad . math_exp_alt
    (74) math_exp_alt -> . + term new_quad math_exp_alt
    (75) math_exp_alt -> . - term new_quad math_exp_alt
    (76) math_exp_alt -> . empty
    (99) empty -> .

    +               shift and go to state 105
    -               shift and go to state 104
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_exp_alt                   shift and go to state 198
    empty                          shift and go to state 106

state 179

    (16) function -> # ID neg_lookup : return_type params . scope_function func_block
    (102) scope_function -> . empty
    (99) empty -> .

    {               reduce using rule 99 (empty -> .)

    scope_function                 shift and go to state 199
    empty                          shift and go to state 200

state 180

    (36) type -> ID check_class .

    )               reduce using rule 36 (type -> ID check_class .)
    (               reduce using rule 36 (type -> ID check_class .)
    ,               reduce using rule 36 (type -> ID check_class .)
    ;               reduce using rule 36 (type -> ID check_class .)
    =               reduce using rule 36 (type -> ID check_class .)


state 181

    (37) stack_type -> STACK ( . type )
    (32) type -> . INT_TYPE
    (33) type -> . FLOAT_TYPE
    (34) type -> . STRING_TYPE
    (35) type -> . BOOLEAN_TYPE
    (36) type -> . ID check_class

    INT_TYPE        shift and go to state 149
    FLOAT_TYPE      shift and go to state 145
    STRING_TYPE     shift and go to state 148
    BOOLEAN_TYPE    shift and go to state 147
    ID              shift and go to state 152

    type                           shift and go to state 201

state 182

    (11) attrs_alt -> , attr attrs_alt .

    )               reduce using rule 11 (attrs_alt -> , attr attrs_alt .)


state 183

    (13) class_block -> { functions } .

    @               reduce using rule 13 (class_block -> { functions } .)
    #               reduce using rule 13 (class_block -> { functions } .)
    $               reduce using rule 13 (class_block -> { functions } .)
    PRINT           reduce using rule 13 (class_block -> { functions } .)
    IF              reduce using rule 13 (class_block -> { functions } .)
    WHILE           reduce using rule 13 (class_block -> { functions } .)
    READ            reduce using rule 13 (class_block -> { functions } .)
    STRING          reduce using rule 13 (class_block -> { functions } .)
    NEW             reduce using rule 13 (class_block -> { functions } .)
    ID              reduce using rule 13 (class_block -> { functions } .)
    THIS            reduce using rule 13 (class_block -> { functions } .)
    (               reduce using rule 13 (class_block -> { functions } .)
    FLOAT           reduce using rule 13 (class_block -> { functions } .)
    INT             reduce using rule 13 (class_block -> { functions } .)
    $end            reduce using rule 13 (class_block -> { functions } .)


state 184

    (97) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation . ) block

    )               shift and go to state 202


state 185

    (52) constructor_call -> ID ( args ) .

    ;               reduce using rule 52 (constructor_call -> ID ( args ) .)
    )               reduce using rule 52 (constructor_call -> ID ( args ) .)
    ,               reduce using rule 52 (constructor_call -> ID ( args ) .)


state 186

    (38) print_stmt -> PRINT ( exp ) ; .

    $               reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    PRINT           reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    IF              reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    WHILE           reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    READ            reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    STRING          reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    NEW             reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    ID              reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    THIS            reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    (               reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    FLOAT           reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    INT             reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    $end            reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    }               reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    RETURN          reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)


state 187

    (93) args_aux -> , exp . args_aux
    (93) args_aux -> . , exp args_aux
    (94) args_aux -> . empty
    (99) empty -> .

    ,               shift and go to state 164
    )               reduce using rule 99 (empty -> .)

    args_aux                       shift and go to state 203
    empty                          shift and go to state 163

state 188

    (78) term_alt -> * factor new_quad term_alt .

    +               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    -               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    <               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    >               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    EQ              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    NE              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    LE              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    GE              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    AND             reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    OR              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    ;               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    )               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    ,               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)


state 189

    (79) term_alt -> / factor new_quad term_alt .

    +               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    -               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    <               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    >               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    EQ              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    NE              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    LE              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    GE              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    AND             reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    OR              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    ;               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    )               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    ,               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)


state 190

    (59) math_or_alt -> OR math_and new_quad math_or_alt .

    ;               reduce using rule 59 (math_or_alt -> OR math_and new_quad math_or_alt .)
    )               reduce using rule 59 (math_or_alt -> OR math_and new_quad math_or_alt .)
    ,               reduce using rule 59 (math_or_alt -> OR math_and new_quad math_or_alt .)


state 191

    (62) math_and_alt -> AND math_comp new_quad math_and_alt .

    OR              reduce using rule 62 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ;               reduce using rule 62 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    )               reduce using rule 62 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ,               reduce using rule 62 (math_and_alt -> AND math_comp new_quad math_and_alt .)


state 192

    (56) stack_method -> PEEK ( ) .

    ;               reduce using rule 56 (stack_method -> PEEK ( ) .)
    )               reduce using rule 56 (stack_method -> PEEK ( ) .)
    ,               reduce using rule 56 (stack_method -> PEEK ( ) .)


state 193

    (54) stack_method -> POP ( ) .

    ;               reduce using rule 54 (stack_method -> POP ( ) .)
    )               reduce using rule 54 (stack_method -> POP ( ) .)
    ,               reduce using rule 54 (stack_method -> POP ( ) .)


state 194

    (55) stack_method -> PUSH ( exp . )

    )               shift and go to state 204


state 195

    (57) stack_method -> SIZE ( ) .

    ;               reduce using rule 57 (stack_method -> SIZE ( ) .)
    )               reduce using rule 57 (stack_method -> SIZE ( ) .)
    ,               reduce using rule 57 (stack_method -> SIZE ( ) .)


state 196

    (95) if_block -> IF ( exp exp_evaluation ) . block
    (96) if_block -> IF ( exp exp_evaluation ) . block after_if_block ELSE block
    (98) block -> . { statements }

    {               shift and go to state 205

    block                          shift and go to state 206

state 197

    (75) math_exp_alt -> - term new_quad math_exp_alt .

    <               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    >               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    EQ              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    NE              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    LE              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    GE              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    AND             reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    OR              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    ;               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    )               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    ,               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)


state 198

    (74) math_exp_alt -> + term new_quad math_exp_alt .

    <               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    >               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    EQ              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    NE              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    LE              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    GE              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    AND             reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    OR              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    ;               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    )               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    ,               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)


state 199

    (16) function -> # ID neg_lookup : return_type params scope_function . func_block
    (19) func_block -> . { statements return }

    {               shift and go to state 208

    func_block                     shift and go to state 207

state 200

    (102) scope_function -> empty .

    {               reduce using rule 102 (scope_function -> empty .)


state 201

    (37) stack_type -> STACK ( type . )

    )               shift and go to state 209


state 202

    (97) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) . block
    (98) block -> . { statements }

    {               shift and go to state 205

    block                          shift and go to state 210

state 203

    (93) args_aux -> , exp args_aux .

    )               reduce using rule 93 (args_aux -> , exp args_aux .)


state 204

    (55) stack_method -> PUSH ( exp ) .

    ;               reduce using rule 55 (stack_method -> PUSH ( exp ) .)
    )               reduce using rule 55 (stack_method -> PUSH ( exp ) .)
    ,               reduce using rule 55 (stack_method -> PUSH ( exp ) .)


state 205

    (98) block -> { . statements }
    (22) statements -> . statement statements
    (23) statements -> . empty
    (24) statement -> . declaration ;
    (25) statement -> . print_stmt
    (26) statement -> . if_block
    (27) statement -> . while_block
    (28) statement -> . expr
    (99) empty -> .
    (29) declaration -> . $ attr
    (38) print_stmt -> . PRINT ( exp ) ;
    (95) if_block -> . IF ( exp exp_evaluation ) block
    (96) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (97) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (39) expr -> . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    }               reduce using rule 99 (empty -> .)
    $               shift and go to state 34
    PRINT           shift and go to state 30
    IF              shift and go to state 49
    WHILE           shift and go to state 27
    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    statements                     shift and go to state 211
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    string                         shift and go to state 44
    math_exp                       shift and go to state 33
    prop                           shift and go to state 32
    read                           shift and go to state 36
    call                           shift and go to state 37
    statement                      shift and go to state 38
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    empty                          shift and go to state 42
    math_and                       shift and go to state 43
    print_stmt                     shift and go to state 45
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 47
    term                           shift and go to state 50
    expr                           shift and go to state 51
    if_block                       shift and go to state 52
    while_block                    shift and go to state 54
    exp                            shift and go to state 55
    assign                         shift and go to state 57

state 206

    (95) if_block -> IF ( exp exp_evaluation ) block .
    (96) if_block -> IF ( exp exp_evaluation ) block . after_if_block ELSE block
    (106) after_if_block -> . empty
    (99) empty -> .

    $               reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    PRINT           reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    IF              reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    WHILE           reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    READ            reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    STRING          reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    NEW             reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    ID              reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    THIS            reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    (               reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    FLOAT           reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    INT             reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    RETURN          reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    }               reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    $end            reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    ELSE            reduce using rule 99 (empty -> .)

    empty                          shift and go to state 213
    after_if_block                 shift and go to state 212

state 207

    (16) function -> # ID neg_lookup : return_type params scope_function func_block .

    #               reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $               reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    PRINT           reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    IF              reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    WHILE           reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    READ            reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    STRING          reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    NEW             reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    ID              reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    THIS            reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    (               reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FLOAT           reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    INT             reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $end            reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    }               reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)


state 208

    (19) func_block -> { . statements return }
    (22) statements -> . statement statements
    (23) statements -> . empty
    (24) statement -> . declaration ;
    (25) statement -> . print_stmt
    (26) statement -> . if_block
    (27) statement -> . while_block
    (28) statement -> . expr
    (99) empty -> .
    (29) declaration -> . $ attr
    (38) print_stmt -> . PRINT ( exp ) ;
    (95) if_block -> . IF ( exp exp_evaluation ) block
    (96) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (97) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (39) expr -> . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    RETURN          reduce using rule 99 (empty -> .)
    }               reduce using rule 99 (empty -> .)
    $               shift and go to state 34
    PRINT           shift and go to state 30
    IF              shift and go to state 49
    WHILE           shift and go to state 27
    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    statements                     shift and go to state 214
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    math_and                       shift and go to state 43
    math_exp                       shift and go to state 33
    prop                           shift and go to state 32
    read                           shift and go to state 36
    call                           shift and go to state 37
    statement                      shift and go to state 38
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    empty                          shift and go to state 42
    string                         shift and go to state 44
    print_stmt                     shift and go to state 45
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 47
    term                           shift and go to state 50
    expr                           shift and go to state 51
    if_block                       shift and go to state 52
    while_block                    shift and go to state 54
    exp                            shift and go to state 55
    assign                         shift and go to state 57

state 209

    (37) stack_type -> STACK ( type ) .

    ,               reduce using rule 37 (stack_type -> STACK ( type ) .)
    )               reduce using rule 37 (stack_type -> STACK ( type ) .)
    ;               reduce using rule 37 (stack_type -> STACK ( type ) .)
    =               reduce using rule 37 (stack_type -> STACK ( type ) .)


state 210

    (97) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .

    $               reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    PRINT           reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    IF              reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    WHILE           reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    READ            reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    STRING          reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    NEW             reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    ID              reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    THIS            reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    (               reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    FLOAT           reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    INT             reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    RETURN          reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    }               reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    $end            reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)


state 211

    (98) block -> { statements . }

    }               shift and go to state 215


state 212

    (96) if_block -> IF ( exp exp_evaluation ) block after_if_block . ELSE block

    ELSE            shift and go to state 216


state 213

    (106) after_if_block -> empty .

    ELSE            reduce using rule 106 (after_if_block -> empty .)


state 214

    (19) func_block -> { statements . return }
    (20) return -> . RETURN exp ;
    (21) return -> . empty
    (99) empty -> .

    RETURN          shift and go to state 218
    }               reduce using rule 99 (empty -> .)

    return                         shift and go to state 217
    empty                          shift and go to state 219

state 215

    (98) block -> { statements } .

    ELSE            reduce using rule 98 (block -> { statements } .)
    $               reduce using rule 98 (block -> { statements } .)
    PRINT           reduce using rule 98 (block -> { statements } .)
    IF              reduce using rule 98 (block -> { statements } .)
    WHILE           reduce using rule 98 (block -> { statements } .)
    READ            reduce using rule 98 (block -> { statements } .)
    STRING          reduce using rule 98 (block -> { statements } .)
    NEW             reduce using rule 98 (block -> { statements } .)
    ID              reduce using rule 98 (block -> { statements } .)
    THIS            reduce using rule 98 (block -> { statements } .)
    (               reduce using rule 98 (block -> { statements } .)
    FLOAT           reduce using rule 98 (block -> { statements } .)
    INT             reduce using rule 98 (block -> { statements } .)
    $end            reduce using rule 98 (block -> { statements } .)
    }               reduce using rule 98 (block -> { statements } .)
    RETURN          reduce using rule 98 (block -> { statements } .)


state 216

    (96) if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE . block
    (98) block -> . { statements }

    {               shift and go to state 205

    block                          shift and go to state 220

state 217

    (19) func_block -> { statements return . }

    }               shift and go to state 221


state 218

    (20) return -> RETURN . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (29) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 25
    STRING          shift and go to state 28
    NEW             shift and go to state 29
    ID              shift and go to state 48
    THIS            shift and go to state 53
    $               shift and go to state 34
    (               shift and go to state 35
    FLOAT           shift and go to state 23
    INT             shift and go to state 56

    math_or                        shift and go to state 22
    number                         shift and go to state 26
    stack_call                     shift and go to state 31
    prop                           shift and go to state 32
    call                           shift and go to state 37
    math_exp                       shift and go to state 33
    factor                         shift and go to state 39
    var                            shift and go to state 40
    new                            shift and go to state 41
    math_and                       shift and go to state 43
    string                         shift and go to state 44
    read                           shift and go to state 36
    math_comp                      shift and go to state 46
    declaration                    shift and go to state 122
    term                           shift and go to state 50
    exp                            shift and go to state 222
    assign                         shift and go to state 57

state 219

    (21) return -> empty .

    }               reduce using rule 21 (return -> empty .)


state 220

    (96) if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .

    $               reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    PRINT           reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    IF              reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    WHILE           reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    READ            reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    STRING          reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    NEW             reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    ID              reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    THIS            reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    (               reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    FLOAT           reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    INT             reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    RETURN          reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    }               reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    $end            reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)


state 221

    (19) func_block -> { statements return } .

    #               reduce using rule 19 (func_block -> { statements return } .)
    $               reduce using rule 19 (func_block -> { statements return } .)
    PRINT           reduce using rule 19 (func_block -> { statements return } .)
    IF              reduce using rule 19 (func_block -> { statements return } .)
    WHILE           reduce using rule 19 (func_block -> { statements return } .)
    READ            reduce using rule 19 (func_block -> { statements return } .)
    STRING          reduce using rule 19 (func_block -> { statements return } .)
    NEW             reduce using rule 19 (func_block -> { statements return } .)
    ID              reduce using rule 19 (func_block -> { statements return } .)
    THIS            reduce using rule 19 (func_block -> { statements return } .)
    (               reduce using rule 19 (func_block -> { statements return } .)
    FLOAT           reduce using rule 19 (func_block -> { statements return } .)
    INT             reduce using rule 19 (func_block -> { statements return } .)
    $end            reduce using rule 19 (func_block -> { statements return } .)
    }               reduce using rule 19 (func_block -> { statements return } .)


state 222

    (20) return -> RETURN exp . ;

    ;               shift and go to state 223


state 223

    (20) return -> RETURN exp ; .

    }               reduce using rule 20 (return -> RETURN exp ; .)

