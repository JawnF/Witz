Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> classes functions fill_goto statements
Rule 2     fill_goto -> empty
Rule 3     classes -> class classes
Rule 4     classes -> empty
Rule 5     class -> @ ID inheritance params scope_class class_block
Rule 6     inheritance -> < ID check_class >
Rule 7     inheritance -> empty
Rule 8     params -> ( attrs )
Rule 9     attrs -> attr attrs_alt
Rule 10    attrs -> empty
Rule 11    attrs_alt -> , attr attrs_alt
Rule 12    attrs_alt -> empty
Rule 13    class_block -> { functions }
Rule 14    functions -> function functions
Rule 15    functions -> empty
Rule 16    function -> # ID neg_lookup : return_type params scope_function func_block
Rule 17    return_type -> VOID
Rule 18    return_type -> type
Rule 19    func_block -> { statements return }
Rule 20    return -> RETURN exp ;
Rule 21    return -> empty
Rule 22    statements -> statement statements
Rule 23    statements -> empty
Rule 24    statement -> declaration ;
Rule 25    statement -> print_stmt
Rule 26    statement -> if_block
Rule 27    statement -> while_block
Rule 28    statement -> for_block
Rule 29    statement -> expr
Rule 30    declaration -> $ attr
Rule 31    attr -> ID : type
Rule 32    attr -> ID : stack_type
Rule 33    type -> INT_TYPE
Rule 34    type -> FLOAT_TYPE
Rule 35    type -> STRING_TYPE
Rule 36    type -> BOOLEAN_TYPE
Rule 37    type -> ID check_class
Rule 38    stack_type -> STACK ( type )
Rule 39    print_stmt -> PRINT ( exp ) ;
Rule 40    expr -> exp ;
Rule 41    exp -> read
Rule 42    exp -> math_or
Rule 43    exp -> assign
Rule 44    exp -> string
Rule 45    exp -> new
Rule 46    exp -> stack_call
Rule 47    read -> READ ( )
Rule 48    assign -> var = exp
Rule 49    string -> STRING
Rule 50    var -> prop
Rule 51    var -> declaration
Rule 52    new -> NEW constructor_call
Rule 53    constructor_call -> ID ( args )
Rule 54    stack_call -> ID . stack_method
Rule 55    stack_method -> POP ( )
Rule 56    stack_method -> PUSH ( exp )
Rule 57    stack_method -> PEEK ( )
Rule 58    math_or -> math_and math_or_alt
Rule 59    math_or_alt -> OR math_and new_quad math_or_alt
Rule 60    math_or_alt -> empty
Rule 61    math_and -> math_comp math_and_alt
Rule 62    math_and_alt -> AND math_comp new_quad math_and_alt
Rule 63    math_and_alt -> empty
Rule 64    math_comp -> math_exp math_comp_alt
Rule 65    math_comp_alt -> comparison_op math_exp new_quad
Rule 66    math_comp_alt -> empty
Rule 67    comparison_op -> <
Rule 68    comparison_op -> >
Rule 69    comparison_op -> EQ
Rule 70    comparison_op -> NE
Rule 71    comparison_op -> LE
Rule 72    comparison_op -> GE
Rule 73    math_exp -> term math_exp_alt
Rule 74    math_exp_alt -> + term new_quad math_exp_alt
Rule 75    math_exp_alt -> - term new_quad math_exp_alt
Rule 76    math_exp_alt -> empty
Rule 77    term -> factor term_alt
Rule 78    term_alt -> * factor new_quad term_alt
Rule 79    term_alt -> / factor new_quad term_alt
Rule 80    term_alt -> empty
Rule 81    factor -> prop
Rule 82    factor -> number
Rule 83    factor -> call
Rule 84    factor -> ( math_or )
Rule 85    prop -> THIS . ID
Rule 86    prop -> ID . ID
Rule 87    prop -> ID
Rule 88    number -> FLOAT empty
Rule 89    number -> INT
Rule 90    call -> prop ( args )
Rule 91    args -> exp args_aux
Rule 92    args -> empty
Rule 93    args_aux -> , exp args_aux
Rule 94    args_aux -> empty
Rule 95    if_block -> IF ( exp exp_evaluation ) block
Rule 96    if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block
Rule 97    while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block
Rule 98    for_block -> FOR number FOR_TO number SKIP number block
Rule 99    block -> { statements }
Rule 100   empty -> <empty>
Rule 101   new_quad -> empty
Rule 102   scope_class -> empty
Rule 103   scope_function -> empty
Rule 104   check_class -> empty
Rule 105   neg_lookup -> empty
Rule 106   exp_evaluation -> empty
Rule 107   after_if_block -> empty
Rule 108   leave_breadcrumb -> empty

Terminals, with rules where they appear

#                    : 16
$                    : 30
(                    : 8 38 39 47 53 55 56 57 84 90 95 96 97
)                    : 8 38 39 47 53 55 56 57 84 90 95 96 97
*                    : 78
+                    : 74
,                    : 11 93
-                    : 75
.                    : 54 85 86
/                    : 79
:                    : 16 31 32
;                    : 20 24 39 40
<                    : 6 67
=                    : 48
>                    : 6 68
@                    : 5
AND                  : 62
BOOLEAN_TYPE         : 36
ELSE                 : 96
EQ                   : 69
FLOAT                : 88
FLOAT_TYPE           : 34
FOR                  : 98
FOR_TO               : 98
GE                   : 72
ID                   : 5 6 16 31 32 37 53 54 85 86 86 87
IF                   : 95 96
INT                  : 89
INT_TYPE             : 33
LE                   : 71
NE                   : 70
NEW                  : 52
OR                   : 59
PEEK                 : 57
POP                  : 55
PRINT                : 39
PUSH                 : 56
READ                 : 47
RETURN               : 20
SKIP                 : 98
STACK                : 38
STRING               : 49
STRING_TYPE          : 35
THIS                 : 85
VOID                 : 17
WHILE                : 97
error                : 
{                    : 13 19 99
}                    : 13 19 99

Nonterminals, with rules where they appear

after_if_block       : 96
args                 : 53 90
args_aux             : 91 93
assign               : 43
attr                 : 9 11 30
attrs                : 8
attrs_alt            : 9 11
block                : 95 96 96 97 98
call                 : 83
check_class          : 6 37
class                : 3
class_block          : 5
classes              : 1 3
comparison_op        : 65
constructor_call     : 52
declaration          : 24 51
empty                : 2 4 7 10 12 15 21 23 60 63 66 76 80 88 92 94 101 102 103 104 105 106 107 108
exp                  : 20 39 40 48 56 91 93 95 96 97
exp_evaluation       : 95 96 97
expr                 : 29
factor               : 77 78 79
fill_goto            : 1
for_block            : 28
func_block           : 16
function             : 14
functions            : 1 13 14
if_block             : 26
inheritance          : 5
leave_breadcrumb     : 97
math_and             : 58 59
math_and_alt         : 61 62
math_comp            : 61 62
math_comp_alt        : 64
math_exp             : 64 65
math_exp_alt         : 73 74 75
math_or              : 42 84
math_or_alt          : 58 59
neg_lookup           : 16
new                  : 45
new_quad             : 59 62 65 74 75 78 79
number               : 82 98 98 98
params               : 5 16
print_stmt           : 25
program              : 0
prop                 : 50 81 90
read                 : 41
return               : 19
return_type          : 16
scope_class          : 5
scope_function       : 16
stack_call           : 46
stack_method         : 54
stack_type           : 32
statement            : 22
statements           : 1 19 22 99
string               : 44
term                 : 73 74 75
term_alt             : 77 78 79
type                 : 18 31 38
var                  : 48
while_block          : 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . classes functions fill_goto statements
    (3) classes -> . class classes
    (4) classes -> . empty
    (5) class -> . @ ID inheritance params scope_class class_block
    (100) empty -> .

    @               shift and go to state 2
    #               reduce using rule 100 (empty -> .)
    $               reduce using rule 100 (empty -> .)
    PRINT           reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    READ            reduce using rule 100 (empty -> .)
    STRING          reduce using rule 100 (empty -> .)
    NEW             reduce using rule 100 (empty -> .)
    ID              reduce using rule 100 (empty -> .)
    THIS            reduce using rule 100 (empty -> .)
    (               reduce using rule 100 (empty -> .)
    FLOAT           reduce using rule 100 (empty -> .)
    INT             reduce using rule 100 (empty -> .)
    $end            reduce using rule 100 (empty -> .)

    program                        shift and go to state 1
    classes                        shift and go to state 3
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (5) class -> @ . ID inheritance params scope_class class_block

    ID              shift and go to state 6


state 3

    (1) program -> classes . functions fill_goto statements
    (14) functions -> . function functions
    (15) functions -> . empty
    (16) function -> . # ID neg_lookup : return_type params scope_function func_block
    (100) empty -> .

    #               shift and go to state 9
    $               reduce using rule 100 (empty -> .)
    PRINT           reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    READ            reduce using rule 100 (empty -> .)
    STRING          reduce using rule 100 (empty -> .)
    NEW             reduce using rule 100 (empty -> .)
    ID              reduce using rule 100 (empty -> .)
    THIS            reduce using rule 100 (empty -> .)
    (               reduce using rule 100 (empty -> .)
    FLOAT           reduce using rule 100 (empty -> .)
    INT             reduce using rule 100 (empty -> .)
    $end            reduce using rule 100 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 8
    empty                          shift and go to state 10

state 4

    (3) classes -> class . classes
    (3) classes -> . class classes
    (4) classes -> . empty
    (5) class -> . @ ID inheritance params scope_class class_block
    (100) empty -> .

    @               shift and go to state 2
    #               reduce using rule 100 (empty -> .)
    $               reduce using rule 100 (empty -> .)
    PRINT           reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    READ            reduce using rule 100 (empty -> .)
    STRING          reduce using rule 100 (empty -> .)
    NEW             reduce using rule 100 (empty -> .)
    ID              reduce using rule 100 (empty -> .)
    THIS            reduce using rule 100 (empty -> .)
    (               reduce using rule 100 (empty -> .)
    FLOAT           reduce using rule 100 (empty -> .)
    INT             reduce using rule 100 (empty -> .)
    $end            reduce using rule 100 (empty -> .)

    classes                        shift and go to state 11
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 5

    (4) classes -> empty .

    #               reduce using rule 4 (classes -> empty .)
    $               reduce using rule 4 (classes -> empty .)
    PRINT           reduce using rule 4 (classes -> empty .)
    IF              reduce using rule 4 (classes -> empty .)
    WHILE           reduce using rule 4 (classes -> empty .)
    FOR             reduce using rule 4 (classes -> empty .)
    READ            reduce using rule 4 (classes -> empty .)
    STRING          reduce using rule 4 (classes -> empty .)
    NEW             reduce using rule 4 (classes -> empty .)
    ID              reduce using rule 4 (classes -> empty .)
    THIS            reduce using rule 4 (classes -> empty .)
    (               reduce using rule 4 (classes -> empty .)
    FLOAT           reduce using rule 4 (classes -> empty .)
    INT             reduce using rule 4 (classes -> empty .)
    $end            reduce using rule 4 (classes -> empty .)


state 6

    (5) class -> @ ID . inheritance params scope_class class_block
    (6) inheritance -> . < ID check_class >
    (7) inheritance -> . empty
    (100) empty -> .

    <               shift and go to state 13
    (               reduce using rule 100 (empty -> .)

    inheritance                    shift and go to state 12
    empty                          shift and go to state 14

state 7

    (14) functions -> function . functions
    (14) functions -> . function functions
    (15) functions -> . empty
    (16) function -> . # ID neg_lookup : return_type params scope_function func_block
    (100) empty -> .

    #               shift and go to state 9
    $               reduce using rule 100 (empty -> .)
    PRINT           reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    READ            reduce using rule 100 (empty -> .)
    STRING          reduce using rule 100 (empty -> .)
    NEW             reduce using rule 100 (empty -> .)
    ID              reduce using rule 100 (empty -> .)
    THIS            reduce using rule 100 (empty -> .)
    (               reduce using rule 100 (empty -> .)
    FLOAT           reduce using rule 100 (empty -> .)
    INT             reduce using rule 100 (empty -> .)
    $end            reduce using rule 100 (empty -> .)
    }               reduce using rule 100 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 15
    empty                          shift and go to state 10

state 8

    (1) program -> classes functions . fill_goto statements
    (2) fill_goto -> . empty
    (100) empty -> .

    $               reduce using rule 100 (empty -> .)
    PRINT           reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    READ            reduce using rule 100 (empty -> .)
    STRING          reduce using rule 100 (empty -> .)
    NEW             reduce using rule 100 (empty -> .)
    ID              reduce using rule 100 (empty -> .)
    THIS            reduce using rule 100 (empty -> .)
    (               reduce using rule 100 (empty -> .)
    FLOAT           reduce using rule 100 (empty -> .)
    INT             reduce using rule 100 (empty -> .)
    $end            reduce using rule 100 (empty -> .)

    fill_goto                      shift and go to state 16
    empty                          shift and go to state 17

state 9

    (16) function -> # . ID neg_lookup : return_type params scope_function func_block

    ID              shift and go to state 18


state 10

    (15) functions -> empty .

    $               reduce using rule 15 (functions -> empty .)
    PRINT           reduce using rule 15 (functions -> empty .)
    IF              reduce using rule 15 (functions -> empty .)
    WHILE           reduce using rule 15 (functions -> empty .)
    FOR             reduce using rule 15 (functions -> empty .)
    READ            reduce using rule 15 (functions -> empty .)
    STRING          reduce using rule 15 (functions -> empty .)
    NEW             reduce using rule 15 (functions -> empty .)
    ID              reduce using rule 15 (functions -> empty .)
    THIS            reduce using rule 15 (functions -> empty .)
    (               reduce using rule 15 (functions -> empty .)
    FLOAT           reduce using rule 15 (functions -> empty .)
    INT             reduce using rule 15 (functions -> empty .)
    $end            reduce using rule 15 (functions -> empty .)
    }               reduce using rule 15 (functions -> empty .)


state 11

    (3) classes -> class classes .

    #               reduce using rule 3 (classes -> class classes .)
    $               reduce using rule 3 (classes -> class classes .)
    PRINT           reduce using rule 3 (classes -> class classes .)
    IF              reduce using rule 3 (classes -> class classes .)
    WHILE           reduce using rule 3 (classes -> class classes .)
    FOR             reduce using rule 3 (classes -> class classes .)
    READ            reduce using rule 3 (classes -> class classes .)
    STRING          reduce using rule 3 (classes -> class classes .)
    NEW             reduce using rule 3 (classes -> class classes .)
    ID              reduce using rule 3 (classes -> class classes .)
    THIS            reduce using rule 3 (classes -> class classes .)
    (               reduce using rule 3 (classes -> class classes .)
    FLOAT           reduce using rule 3 (classes -> class classes .)
    INT             reduce using rule 3 (classes -> class classes .)
    $end            reduce using rule 3 (classes -> class classes .)


state 12

    (5) class -> @ ID inheritance . params scope_class class_block
    (8) params -> . ( attrs )

    (               shift and go to state 19

    params                         shift and go to state 20

state 13

    (6) inheritance -> < . ID check_class >

    ID              shift and go to state 21


state 14

    (7) inheritance -> empty .

    (               reduce using rule 7 (inheritance -> empty .)


state 15

    (14) functions -> function functions .

    $               reduce using rule 14 (functions -> function functions .)
    PRINT           reduce using rule 14 (functions -> function functions .)
    IF              reduce using rule 14 (functions -> function functions .)
    WHILE           reduce using rule 14 (functions -> function functions .)
    FOR             reduce using rule 14 (functions -> function functions .)
    READ            reduce using rule 14 (functions -> function functions .)
    STRING          reduce using rule 14 (functions -> function functions .)
    NEW             reduce using rule 14 (functions -> function functions .)
    ID              reduce using rule 14 (functions -> function functions .)
    THIS            reduce using rule 14 (functions -> function functions .)
    (               reduce using rule 14 (functions -> function functions .)
    FLOAT           reduce using rule 14 (functions -> function functions .)
    INT             reduce using rule 14 (functions -> function functions .)
    $end            reduce using rule 14 (functions -> function functions .)
    }               reduce using rule 14 (functions -> function functions .)


state 16

    (1) program -> classes functions fill_goto . statements
    (22) statements -> . statement statements
    (23) statements -> . empty
    (24) statement -> . declaration ;
    (25) statement -> . print_stmt
    (26) statement -> . if_block
    (27) statement -> . while_block
    (28) statement -> . for_block
    (29) statement -> . expr
    (100) empty -> .
    (30) declaration -> . $ attr
    (39) print_stmt -> . PRINT ( exp ) ;
    (95) if_block -> . IF ( exp exp_evaluation ) block
    (96) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (97) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (98) for_block -> . FOR number FOR_TO number SKIP number block
    (40) expr -> . exp ;
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    $end            reduce using rule 100 (empty -> .)
    $               shift and go to state 35
    PRINT           shift and go to state 31
    IF              shift and go to state 51
    WHILE           shift and go to state 28
    FOR             shift and go to state 46
    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    for_block                      shift and go to state 23
    statements                     shift and go to state 25
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    math_exp                       shift and go to state 34
    prop                           shift and go to state 33
    read                           shift and go to state 37
    call                           shift and go to state 38
    statement                      shift and go to state 39
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    empty                          shift and go to state 43
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    print_stmt                     shift and go to state 47
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 49
    term                           shift and go to state 52
    expr                           shift and go to state 53
    if_block                       shift and go to state 54
    while_block                    shift and go to state 56
    exp                            shift and go to state 57
    assign                         shift and go to state 59

state 17

    (2) fill_goto -> empty .

    $               reduce using rule 2 (fill_goto -> empty .)
    PRINT           reduce using rule 2 (fill_goto -> empty .)
    IF              reduce using rule 2 (fill_goto -> empty .)
    WHILE           reduce using rule 2 (fill_goto -> empty .)
    FOR             reduce using rule 2 (fill_goto -> empty .)
    READ            reduce using rule 2 (fill_goto -> empty .)
    STRING          reduce using rule 2 (fill_goto -> empty .)
    NEW             reduce using rule 2 (fill_goto -> empty .)
    ID              reduce using rule 2 (fill_goto -> empty .)
    THIS            reduce using rule 2 (fill_goto -> empty .)
    (               reduce using rule 2 (fill_goto -> empty .)
    FLOAT           reduce using rule 2 (fill_goto -> empty .)
    INT             reduce using rule 2 (fill_goto -> empty .)
    $end            reduce using rule 2 (fill_goto -> empty .)


state 18

    (16) function -> # ID . neg_lookup : return_type params scope_function func_block
    (105) neg_lookup -> . empty
    (100) empty -> .

    :               reduce using rule 100 (empty -> .)

    neg_lookup                     shift and go to state 60
    empty                          shift and go to state 61

state 19

    (8) params -> ( . attrs )
    (9) attrs -> . attr attrs_alt
    (10) attrs -> . empty
    (31) attr -> . ID : type
    (32) attr -> . ID : stack_type
    (100) empty -> .

    ID              shift and go to state 63
    )               reduce using rule 100 (empty -> .)

    attrs                          shift and go to state 62
    attr                           shift and go to state 65
    empty                          shift and go to state 64

state 20

    (5) class -> @ ID inheritance params . scope_class class_block
    (102) scope_class -> . empty
    (100) empty -> .

    {               reduce using rule 100 (empty -> .)

    scope_class                    shift and go to state 66
    empty                          shift and go to state 67

state 21

    (6) inheritance -> < ID . check_class >
    (104) check_class -> . empty
    (100) empty -> .

    >               reduce using rule 100 (empty -> .)

    empty                          shift and go to state 68
    check_class                    shift and go to state 69

state 22

    (42) exp -> math_or .

    ;               reduce using rule 42 (exp -> math_or .)
    )               reduce using rule 42 (exp -> math_or .)
    ,               reduce using rule 42 (exp -> math_or .)


state 23

    (28) statement -> for_block .

    $               reduce using rule 28 (statement -> for_block .)
    PRINT           reduce using rule 28 (statement -> for_block .)
    IF              reduce using rule 28 (statement -> for_block .)
    WHILE           reduce using rule 28 (statement -> for_block .)
    FOR             reduce using rule 28 (statement -> for_block .)
    READ            reduce using rule 28 (statement -> for_block .)
    STRING          reduce using rule 28 (statement -> for_block .)
    NEW             reduce using rule 28 (statement -> for_block .)
    ID              reduce using rule 28 (statement -> for_block .)
    THIS            reduce using rule 28 (statement -> for_block .)
    (               reduce using rule 28 (statement -> for_block .)
    FLOAT           reduce using rule 28 (statement -> for_block .)
    INT             reduce using rule 28 (statement -> for_block .)
    $end            reduce using rule 28 (statement -> for_block .)
    }               reduce using rule 28 (statement -> for_block .)
    RETURN          reduce using rule 28 (statement -> for_block .)


state 24

    (88) number -> FLOAT . empty
    (100) empty -> .

    *               reduce using rule 100 (empty -> .)
    /               reduce using rule 100 (empty -> .)
    +               reduce using rule 100 (empty -> .)
    -               reduce using rule 100 (empty -> .)
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    FOR_TO          reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)
    SKIP            reduce using rule 100 (empty -> .)
    {               reduce using rule 100 (empty -> .)

    empty                          shift and go to state 70

state 25

    (1) program -> classes functions fill_goto statements .

    $end            reduce using rule 1 (program -> classes functions fill_goto statements .)


state 26

    (47) read -> READ . ( )

    (               shift and go to state 71


state 27

    (82) factor -> number .

    *               reduce using rule 82 (factor -> number .)
    /               reduce using rule 82 (factor -> number .)
    +               reduce using rule 82 (factor -> number .)
    -               reduce using rule 82 (factor -> number .)
    <               reduce using rule 82 (factor -> number .)
    >               reduce using rule 82 (factor -> number .)
    EQ              reduce using rule 82 (factor -> number .)
    NE              reduce using rule 82 (factor -> number .)
    LE              reduce using rule 82 (factor -> number .)
    GE              reduce using rule 82 (factor -> number .)
    AND             reduce using rule 82 (factor -> number .)
    OR              reduce using rule 82 (factor -> number .)
    ;               reduce using rule 82 (factor -> number .)
    )               reduce using rule 82 (factor -> number .)
    ,               reduce using rule 82 (factor -> number .)


state 28

    (97) while_block -> WHILE . ( leave_breadcrumb exp exp_evaluation ) block

    (               shift and go to state 72


state 29

    (49) string -> STRING .

    ,               reduce using rule 49 (string -> STRING .)
    )               reduce using rule 49 (string -> STRING .)
    ;               reduce using rule 49 (string -> STRING .)


state 30

    (52) new -> NEW . constructor_call
    (53) constructor_call -> . ID ( args )

    ID              shift and go to state 74

    constructor_call               shift and go to state 73

state 31

    (39) print_stmt -> PRINT . ( exp ) ;

    (               shift and go to state 75


state 32

    (46) exp -> stack_call .

    ;               reduce using rule 46 (exp -> stack_call .)
    )               reduce using rule 46 (exp -> stack_call .)
    ,               reduce using rule 46 (exp -> stack_call .)


state 33

    (50) var -> prop .
    (81) factor -> prop .
    (90) call -> prop . ( args )

    =               reduce using rule 50 (var -> prop .)
    *               reduce using rule 81 (factor -> prop .)
    /               reduce using rule 81 (factor -> prop .)
    +               reduce using rule 81 (factor -> prop .)
    -               reduce using rule 81 (factor -> prop .)
    <               reduce using rule 81 (factor -> prop .)
    >               reduce using rule 81 (factor -> prop .)
    EQ              reduce using rule 81 (factor -> prop .)
    NE              reduce using rule 81 (factor -> prop .)
    LE              reduce using rule 81 (factor -> prop .)
    GE              reduce using rule 81 (factor -> prop .)
    AND             reduce using rule 81 (factor -> prop .)
    OR              reduce using rule 81 (factor -> prop .)
    ;               reduce using rule 81 (factor -> prop .)
    )               reduce using rule 81 (factor -> prop .)
    ,               reduce using rule 81 (factor -> prop .)
    (               shift and go to state 76


state 34

    (64) math_comp -> math_exp . math_comp_alt
    (65) math_comp_alt -> . comparison_op math_exp new_quad
    (66) math_comp_alt -> . empty
    (67) comparison_op -> . <
    (68) comparison_op -> . >
    (69) comparison_op -> . EQ
    (70) comparison_op -> . NE
    (71) comparison_op -> . LE
    (72) comparison_op -> . GE
    (100) empty -> .

    <               shift and go to state 83
    >               shift and go to state 85
    EQ              shift and go to state 82
    NE              shift and go to state 79
    LE              shift and go to state 78
    GE              shift and go to state 81
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    math_comp_alt                  shift and go to state 80
    comparison_op                  shift and go to state 77
    empty                          shift and go to state 84

state 35

    (30) declaration -> $ . attr
    (31) attr -> . ID : type
    (32) attr -> . ID : stack_type

    ID              shift and go to state 63

    attr                           shift and go to state 86

state 36

    (84) factor -> ( . math_or )
    (58) math_or -> . math_and math_or_alt
    (61) math_and -> . math_comp math_and_alt
    (64) math_comp -> . math_exp math_comp_alt
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 36
    THIS            shift and go to state 55
    ID              shift and go to state 89
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 87
    term                           shift and go to state 52
    math_and                       shift and go to state 44
    math_comp                      shift and go to state 40
    number                         shift and go to state 27
    prop                           shift and go to state 88
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48

state 37

    (41) exp -> read .

    ;               reduce using rule 41 (exp -> read .)
    )               reduce using rule 41 (exp -> read .)
    ,               reduce using rule 41 (exp -> read .)


state 38

    (83) factor -> call .

    *               reduce using rule 83 (factor -> call .)
    /               reduce using rule 83 (factor -> call .)
    +               reduce using rule 83 (factor -> call .)
    -               reduce using rule 83 (factor -> call .)
    <               reduce using rule 83 (factor -> call .)
    >               reduce using rule 83 (factor -> call .)
    EQ              reduce using rule 83 (factor -> call .)
    NE              reduce using rule 83 (factor -> call .)
    LE              reduce using rule 83 (factor -> call .)
    GE              reduce using rule 83 (factor -> call .)
    AND             reduce using rule 83 (factor -> call .)
    OR              reduce using rule 83 (factor -> call .)
    ;               reduce using rule 83 (factor -> call .)
    )               reduce using rule 83 (factor -> call .)
    ,               reduce using rule 83 (factor -> call .)


state 39

    (22) statements -> statement . statements
    (22) statements -> . statement statements
    (23) statements -> . empty
    (24) statement -> . declaration ;
    (25) statement -> . print_stmt
    (26) statement -> . if_block
    (27) statement -> . while_block
    (28) statement -> . for_block
    (29) statement -> . expr
    (100) empty -> .
    (30) declaration -> . $ attr
    (39) print_stmt -> . PRINT ( exp ) ;
    (95) if_block -> . IF ( exp exp_evaluation ) block
    (96) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (97) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (98) for_block -> . FOR number FOR_TO number SKIP number block
    (40) expr -> . exp ;
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    $end            reduce using rule 100 (empty -> .)
    }               reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    $               shift and go to state 35
    PRINT           shift and go to state 31
    IF              shift and go to state 51
    WHILE           shift and go to state 28
    FOR             shift and go to state 46
    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    for_block                      shift and go to state 23
    statements                     shift and go to state 90
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    math_exp                       shift and go to state 34
    prop                           shift and go to state 33
    read                           shift and go to state 37
    call                           shift and go to state 38
    statement                      shift and go to state 39
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    empty                          shift and go to state 43
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    print_stmt                     shift and go to state 47
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 49
    term                           shift and go to state 52
    expr                           shift and go to state 53
    if_block                       shift and go to state 54
    while_block                    shift and go to state 56
    exp                            shift and go to state 57
    assign                         shift and go to state 59

state 40

    (61) math_and -> math_comp . math_and_alt
    (62) math_and_alt -> . AND math_comp new_quad math_and_alt
    (63) math_and_alt -> . empty
    (100) empty -> .

    AND             shift and go to state 91
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    math_and_alt                   shift and go to state 92
    empty                          shift and go to state 93

state 41

    (48) assign -> var . = exp

    =               shift and go to state 94


state 42

    (45) exp -> new .

    ;               reduce using rule 45 (exp -> new .)
    )               reduce using rule 45 (exp -> new .)
    ,               reduce using rule 45 (exp -> new .)


state 43

    (23) statements -> empty .

    $end            reduce using rule 23 (statements -> empty .)
    }               reduce using rule 23 (statements -> empty .)
    RETURN          reduce using rule 23 (statements -> empty .)


state 44

    (58) math_or -> math_and . math_or_alt
    (59) math_or_alt -> . OR math_and new_quad math_or_alt
    (60) math_or_alt -> . empty
    (100) empty -> .

    OR              shift and go to state 97
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    math_or_alt                    shift and go to state 95
    empty                          shift and go to state 96

state 45

    (44) exp -> string .

    ;               reduce using rule 44 (exp -> string .)
    )               reduce using rule 44 (exp -> string .)
    ,               reduce using rule 44 (exp -> string .)


state 46

    (98) for_block -> FOR . number FOR_TO number SKIP number block
    (88) number -> . FLOAT empty
    (89) number -> . INT

    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    number                         shift and go to state 98

state 47

    (25) statement -> print_stmt .

    $               reduce using rule 25 (statement -> print_stmt .)
    PRINT           reduce using rule 25 (statement -> print_stmt .)
    IF              reduce using rule 25 (statement -> print_stmt .)
    WHILE           reduce using rule 25 (statement -> print_stmt .)
    FOR             reduce using rule 25 (statement -> print_stmt .)
    READ            reduce using rule 25 (statement -> print_stmt .)
    STRING          reduce using rule 25 (statement -> print_stmt .)
    NEW             reduce using rule 25 (statement -> print_stmt .)
    ID              reduce using rule 25 (statement -> print_stmt .)
    THIS            reduce using rule 25 (statement -> print_stmt .)
    (               reduce using rule 25 (statement -> print_stmt .)
    FLOAT           reduce using rule 25 (statement -> print_stmt .)
    INT             reduce using rule 25 (statement -> print_stmt .)
    $end            reduce using rule 25 (statement -> print_stmt .)
    }               reduce using rule 25 (statement -> print_stmt .)
    RETURN          reduce using rule 25 (statement -> print_stmt .)


state 48

    (77) term -> factor . term_alt
    (78) term_alt -> . * factor new_quad term_alt
    (79) term_alt -> . / factor new_quad term_alt
    (80) term_alt -> . empty
    (100) empty -> .

    *               shift and go to state 100
    /               shift and go to state 101
    +               reduce using rule 100 (empty -> .)
    -               reduce using rule 100 (empty -> .)
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    empty                          shift and go to state 102
    term_alt                       shift and go to state 99

state 49

    (24) statement -> declaration . ;
    (51) var -> declaration .

    ;               shift and go to state 103
    =               reduce using rule 51 (var -> declaration .)


state 50

    (54) stack_call -> ID . . stack_method
    (86) prop -> ID . . ID
    (87) prop -> ID .

    .               shift and go to state 104
    (               reduce using rule 87 (prop -> ID .)
    =               reduce using rule 87 (prop -> ID .)
    *               reduce using rule 87 (prop -> ID .)
    /               reduce using rule 87 (prop -> ID .)
    +               reduce using rule 87 (prop -> ID .)
    -               reduce using rule 87 (prop -> ID .)
    <               reduce using rule 87 (prop -> ID .)
    >               reduce using rule 87 (prop -> ID .)
    EQ              reduce using rule 87 (prop -> ID .)
    NE              reduce using rule 87 (prop -> ID .)
    LE              reduce using rule 87 (prop -> ID .)
    GE              reduce using rule 87 (prop -> ID .)
    AND             reduce using rule 87 (prop -> ID .)
    OR              reduce using rule 87 (prop -> ID .)
    ;               reduce using rule 87 (prop -> ID .)
    )               reduce using rule 87 (prop -> ID .)
    ,               reduce using rule 87 (prop -> ID .)


state 51

    (95) if_block -> IF . ( exp exp_evaluation ) block
    (96) if_block -> IF . ( exp exp_evaluation ) block after_if_block ELSE block

    (               shift and go to state 105


state 52

    (73) math_exp -> term . math_exp_alt
    (74) math_exp_alt -> . + term new_quad math_exp_alt
    (75) math_exp_alt -> . - term new_quad math_exp_alt
    (76) math_exp_alt -> . empty
    (100) empty -> .

    +               shift and go to state 108
    -               shift and go to state 107
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    math_exp_alt                   shift and go to state 106
    empty                          shift and go to state 109

state 53

    (29) statement -> expr .

    $               reduce using rule 29 (statement -> expr .)
    PRINT           reduce using rule 29 (statement -> expr .)
    IF              reduce using rule 29 (statement -> expr .)
    WHILE           reduce using rule 29 (statement -> expr .)
    FOR             reduce using rule 29 (statement -> expr .)
    READ            reduce using rule 29 (statement -> expr .)
    STRING          reduce using rule 29 (statement -> expr .)
    NEW             reduce using rule 29 (statement -> expr .)
    ID              reduce using rule 29 (statement -> expr .)
    THIS            reduce using rule 29 (statement -> expr .)
    (               reduce using rule 29 (statement -> expr .)
    FLOAT           reduce using rule 29 (statement -> expr .)
    INT             reduce using rule 29 (statement -> expr .)
    $end            reduce using rule 29 (statement -> expr .)
    }               reduce using rule 29 (statement -> expr .)
    RETURN          reduce using rule 29 (statement -> expr .)


state 54

    (26) statement -> if_block .

    $               reduce using rule 26 (statement -> if_block .)
    PRINT           reduce using rule 26 (statement -> if_block .)
    IF              reduce using rule 26 (statement -> if_block .)
    WHILE           reduce using rule 26 (statement -> if_block .)
    FOR             reduce using rule 26 (statement -> if_block .)
    READ            reduce using rule 26 (statement -> if_block .)
    STRING          reduce using rule 26 (statement -> if_block .)
    NEW             reduce using rule 26 (statement -> if_block .)
    ID              reduce using rule 26 (statement -> if_block .)
    THIS            reduce using rule 26 (statement -> if_block .)
    (               reduce using rule 26 (statement -> if_block .)
    FLOAT           reduce using rule 26 (statement -> if_block .)
    INT             reduce using rule 26 (statement -> if_block .)
    $end            reduce using rule 26 (statement -> if_block .)
    }               reduce using rule 26 (statement -> if_block .)
    RETURN          reduce using rule 26 (statement -> if_block .)


state 55

    (85) prop -> THIS . . ID

    .               shift and go to state 110


state 56

    (27) statement -> while_block .

    $               reduce using rule 27 (statement -> while_block .)
    PRINT           reduce using rule 27 (statement -> while_block .)
    IF              reduce using rule 27 (statement -> while_block .)
    WHILE           reduce using rule 27 (statement -> while_block .)
    FOR             reduce using rule 27 (statement -> while_block .)
    READ            reduce using rule 27 (statement -> while_block .)
    STRING          reduce using rule 27 (statement -> while_block .)
    NEW             reduce using rule 27 (statement -> while_block .)
    ID              reduce using rule 27 (statement -> while_block .)
    THIS            reduce using rule 27 (statement -> while_block .)
    (               reduce using rule 27 (statement -> while_block .)
    FLOAT           reduce using rule 27 (statement -> while_block .)
    INT             reduce using rule 27 (statement -> while_block .)
    $end            reduce using rule 27 (statement -> while_block .)
    }               reduce using rule 27 (statement -> while_block .)
    RETURN          reduce using rule 27 (statement -> while_block .)


state 57

    (40) expr -> exp . ;

    ;               shift and go to state 111


state 58

    (89) number -> INT .

    *               reduce using rule 89 (number -> INT .)
    /               reduce using rule 89 (number -> INT .)
    +               reduce using rule 89 (number -> INT .)
    -               reduce using rule 89 (number -> INT .)
    <               reduce using rule 89 (number -> INT .)
    >               reduce using rule 89 (number -> INT .)
    EQ              reduce using rule 89 (number -> INT .)
    NE              reduce using rule 89 (number -> INT .)
    LE              reduce using rule 89 (number -> INT .)
    GE              reduce using rule 89 (number -> INT .)
    AND             reduce using rule 89 (number -> INT .)
    OR              reduce using rule 89 (number -> INT .)
    )               reduce using rule 89 (number -> INT .)
    ;               reduce using rule 89 (number -> INT .)
    ,               reduce using rule 89 (number -> INT .)
    FOR_TO          reduce using rule 89 (number -> INT .)
    {               reduce using rule 89 (number -> INT .)
    SKIP            reduce using rule 89 (number -> INT .)


state 59

    (43) exp -> assign .

    ;               reduce using rule 43 (exp -> assign .)
    )               reduce using rule 43 (exp -> assign .)
    ,               reduce using rule 43 (exp -> assign .)


state 60

    (16) function -> # ID neg_lookup . : return_type params scope_function func_block

    :               shift and go to state 112


state 61

    (105) neg_lookup -> empty .

    :               reduce using rule 105 (neg_lookup -> empty .)


state 62

    (8) params -> ( attrs . )

    )               shift and go to state 113


state 63

    (31) attr -> ID . : type
    (32) attr -> ID . : stack_type

    :               shift and go to state 114


state 64

    (10) attrs -> empty .

    )               reduce using rule 10 (attrs -> empty .)


state 65

    (9) attrs -> attr . attrs_alt
    (11) attrs_alt -> . , attr attrs_alt
    (12) attrs_alt -> . empty
    (100) empty -> .

    ,               shift and go to state 115
    )               reduce using rule 100 (empty -> .)

    empty                          shift and go to state 116
    attrs_alt                      shift and go to state 117

state 66

    (5) class -> @ ID inheritance params scope_class . class_block
    (13) class_block -> . { functions }

    {               shift and go to state 119

    class_block                    shift and go to state 118

state 67

    (102) scope_class -> empty .

    {               reduce using rule 102 (scope_class -> empty .)


state 68

    (104) check_class -> empty .

    >               reduce using rule 104 (check_class -> empty .)
    (               reduce using rule 104 (check_class -> empty .)
    ,               reduce using rule 104 (check_class -> empty .)
    )               reduce using rule 104 (check_class -> empty .)
    ;               reduce using rule 104 (check_class -> empty .)
    =               reduce using rule 104 (check_class -> empty .)


state 69

    (6) inheritance -> < ID check_class . >

    >               shift and go to state 120


state 70

    (88) number -> FLOAT empty .

    *               reduce using rule 88 (number -> FLOAT empty .)
    /               reduce using rule 88 (number -> FLOAT empty .)
    +               reduce using rule 88 (number -> FLOAT empty .)
    -               reduce using rule 88 (number -> FLOAT empty .)
    <               reduce using rule 88 (number -> FLOAT empty .)
    >               reduce using rule 88 (number -> FLOAT empty .)
    EQ              reduce using rule 88 (number -> FLOAT empty .)
    NE              reduce using rule 88 (number -> FLOAT empty .)
    LE              reduce using rule 88 (number -> FLOAT empty .)
    GE              reduce using rule 88 (number -> FLOAT empty .)
    AND             reduce using rule 88 (number -> FLOAT empty .)
    OR              reduce using rule 88 (number -> FLOAT empty .)
    )               reduce using rule 88 (number -> FLOAT empty .)
    ;               reduce using rule 88 (number -> FLOAT empty .)
    ,               reduce using rule 88 (number -> FLOAT empty .)
    FOR_TO          reduce using rule 88 (number -> FLOAT empty .)
    {               reduce using rule 88 (number -> FLOAT empty .)
    SKIP            reduce using rule 88 (number -> FLOAT empty .)


state 71

    (47) read -> READ ( . )

    )               shift and go to state 121


state 72

    (97) while_block -> WHILE ( . leave_breadcrumb exp exp_evaluation ) block
    (108) leave_breadcrumb -> . empty
    (100) empty -> .

    READ            reduce using rule 100 (empty -> .)
    STRING          reduce using rule 100 (empty -> .)
    NEW             reduce using rule 100 (empty -> .)
    ID              reduce using rule 100 (empty -> .)
    THIS            reduce using rule 100 (empty -> .)
    $               reduce using rule 100 (empty -> .)
    (               reduce using rule 100 (empty -> .)
    FLOAT           reduce using rule 100 (empty -> .)
    INT             reduce using rule 100 (empty -> .)

    empty                          shift and go to state 123
    leave_breadcrumb               shift and go to state 122

state 73

    (52) new -> NEW constructor_call .

    ;               reduce using rule 52 (new -> NEW constructor_call .)
    )               reduce using rule 52 (new -> NEW constructor_call .)
    ,               reduce using rule 52 (new -> NEW constructor_call .)


state 74

    (53) constructor_call -> ID . ( args )

    (               shift and go to state 124


state 75

    (39) print_stmt -> PRINT ( . exp ) ;
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (30) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    $               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    prop                           shift and go to state 33
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    read                           shift and go to state 37
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 125
    term                           shift and go to state 52
    exp                            shift and go to state 126
    assign                         shift and go to state 59

state 76

    (90) call -> prop ( . args )
    (91) args -> . exp args_aux
    (92) args -> . empty
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (100) empty -> .
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (30) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    )               reduce using rule 100 (empty -> .)
    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    $               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    prop                           shift and go to state 33
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    empty                          shift and go to state 127
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    read                           shift and go to state 37
    math_comp                      shift and go to state 40
    args                           shift and go to state 128
    declaration                    shift and go to state 125
    term                           shift and go to state 52
    exp                            shift and go to state 129
    assign                         shift and go to state 59

state 77

    (65) math_comp_alt -> comparison_op . math_exp new_quad
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 36
    THIS            shift and go to state 55
    ID              shift and go to state 89
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    term                           shift and go to state 52
    prop                           shift and go to state 88
    call                           shift and go to state 38
    math_exp                       shift and go to state 130
    factor                         shift and go to state 48
    number                         shift and go to state 27

state 78

    (71) comparison_op -> LE .

    (               reduce using rule 71 (comparison_op -> LE .)
    THIS            reduce using rule 71 (comparison_op -> LE .)
    ID              reduce using rule 71 (comparison_op -> LE .)
    FLOAT           reduce using rule 71 (comparison_op -> LE .)
    INT             reduce using rule 71 (comparison_op -> LE .)


state 79

    (70) comparison_op -> NE .

    (               reduce using rule 70 (comparison_op -> NE .)
    THIS            reduce using rule 70 (comparison_op -> NE .)
    ID              reduce using rule 70 (comparison_op -> NE .)
    FLOAT           reduce using rule 70 (comparison_op -> NE .)
    INT             reduce using rule 70 (comparison_op -> NE .)


state 80

    (64) math_comp -> math_exp math_comp_alt .

    AND             reduce using rule 64 (math_comp -> math_exp math_comp_alt .)
    OR              reduce using rule 64 (math_comp -> math_exp math_comp_alt .)
    )               reduce using rule 64 (math_comp -> math_exp math_comp_alt .)
    ,               reduce using rule 64 (math_comp -> math_exp math_comp_alt .)
    ;               reduce using rule 64 (math_comp -> math_exp math_comp_alt .)


state 81

    (72) comparison_op -> GE .

    (               reduce using rule 72 (comparison_op -> GE .)
    THIS            reduce using rule 72 (comparison_op -> GE .)
    ID              reduce using rule 72 (comparison_op -> GE .)
    FLOAT           reduce using rule 72 (comparison_op -> GE .)
    INT             reduce using rule 72 (comparison_op -> GE .)


state 82

    (69) comparison_op -> EQ .

    (               reduce using rule 69 (comparison_op -> EQ .)
    THIS            reduce using rule 69 (comparison_op -> EQ .)
    ID              reduce using rule 69 (comparison_op -> EQ .)
    FLOAT           reduce using rule 69 (comparison_op -> EQ .)
    INT             reduce using rule 69 (comparison_op -> EQ .)


state 83

    (67) comparison_op -> < .

    (               reduce using rule 67 (comparison_op -> < .)
    THIS            reduce using rule 67 (comparison_op -> < .)
    ID              reduce using rule 67 (comparison_op -> < .)
    FLOAT           reduce using rule 67 (comparison_op -> < .)
    INT             reduce using rule 67 (comparison_op -> < .)


state 84

    (66) math_comp_alt -> empty .

    AND             reduce using rule 66 (math_comp_alt -> empty .)
    OR              reduce using rule 66 (math_comp_alt -> empty .)
    ;               reduce using rule 66 (math_comp_alt -> empty .)
    )               reduce using rule 66 (math_comp_alt -> empty .)
    ,               reduce using rule 66 (math_comp_alt -> empty .)


state 85

    (68) comparison_op -> > .

    (               reduce using rule 68 (comparison_op -> > .)
    THIS            reduce using rule 68 (comparison_op -> > .)
    ID              reduce using rule 68 (comparison_op -> > .)
    FLOAT           reduce using rule 68 (comparison_op -> > .)
    INT             reduce using rule 68 (comparison_op -> > .)


state 86

    (30) declaration -> $ attr .

    =               reduce using rule 30 (declaration -> $ attr .)
    ;               reduce using rule 30 (declaration -> $ attr .)


state 87

    (84) factor -> ( math_or . )

    )               shift and go to state 131


state 88

    (81) factor -> prop .
    (90) call -> prop . ( args )

    *               reduce using rule 81 (factor -> prop .)
    /               reduce using rule 81 (factor -> prop .)
    +               reduce using rule 81 (factor -> prop .)
    -               reduce using rule 81 (factor -> prop .)
    <               reduce using rule 81 (factor -> prop .)
    >               reduce using rule 81 (factor -> prop .)
    EQ              reduce using rule 81 (factor -> prop .)
    NE              reduce using rule 81 (factor -> prop .)
    LE              reduce using rule 81 (factor -> prop .)
    GE              reduce using rule 81 (factor -> prop .)
    AND             reduce using rule 81 (factor -> prop .)
    OR              reduce using rule 81 (factor -> prop .)
    ;               reduce using rule 81 (factor -> prop .)
    )               reduce using rule 81 (factor -> prop .)
    ,               reduce using rule 81 (factor -> prop .)
    (               shift and go to state 76


state 89

    (86) prop -> ID . . ID
    (87) prop -> ID .

    .               shift and go to state 132
    (               reduce using rule 87 (prop -> ID .)
    *               reduce using rule 87 (prop -> ID .)
    /               reduce using rule 87 (prop -> ID .)
    +               reduce using rule 87 (prop -> ID .)
    -               reduce using rule 87 (prop -> ID .)
    <               reduce using rule 87 (prop -> ID .)
    >               reduce using rule 87 (prop -> ID .)
    EQ              reduce using rule 87 (prop -> ID .)
    NE              reduce using rule 87 (prop -> ID .)
    LE              reduce using rule 87 (prop -> ID .)
    GE              reduce using rule 87 (prop -> ID .)
    AND             reduce using rule 87 (prop -> ID .)
    OR              reduce using rule 87 (prop -> ID .)
    ;               reduce using rule 87 (prop -> ID .)
    )               reduce using rule 87 (prop -> ID .)
    ,               reduce using rule 87 (prop -> ID .)


state 90

    (22) statements -> statement statements .

    $end            reduce using rule 22 (statements -> statement statements .)
    }               reduce using rule 22 (statements -> statement statements .)
    RETURN          reduce using rule 22 (statements -> statement statements .)


state 91

    (62) math_and_alt -> AND . math_comp new_quad math_and_alt
    (64) math_comp -> . math_exp math_comp_alt
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 36
    THIS            shift and go to state 55
    ID              shift and go to state 89
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    term                           shift and go to state 52
    math_comp                      shift and go to state 133
    number                         shift and go to state 27
    prop                           shift and go to state 88
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48

state 92

    (61) math_and -> math_comp math_and_alt .

    OR              reduce using rule 61 (math_and -> math_comp math_and_alt .)
    ,               reduce using rule 61 (math_and -> math_comp math_and_alt .)
    )               reduce using rule 61 (math_and -> math_comp math_and_alt .)
    ;               reduce using rule 61 (math_and -> math_comp math_and_alt .)


state 93

    (63) math_and_alt -> empty .

    OR              reduce using rule 63 (math_and_alt -> empty .)
    ;               reduce using rule 63 (math_and_alt -> empty .)
    )               reduce using rule 63 (math_and_alt -> empty .)
    ,               reduce using rule 63 (math_and_alt -> empty .)


state 94

    (48) assign -> var = . exp
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (30) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    $               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    prop                           shift and go to state 33
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    read                           shift and go to state 37
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 125
    term                           shift and go to state 52
    exp                            shift and go to state 134
    assign                         shift and go to state 59

state 95

    (58) math_or -> math_and math_or_alt .

    ;               reduce using rule 58 (math_or -> math_and math_or_alt .)
    )               reduce using rule 58 (math_or -> math_and math_or_alt .)
    ,               reduce using rule 58 (math_or -> math_and math_or_alt .)


state 96

    (60) math_or_alt -> empty .

    ;               reduce using rule 60 (math_or_alt -> empty .)
    )               reduce using rule 60 (math_or_alt -> empty .)
    ,               reduce using rule 60 (math_or_alt -> empty .)


state 97

    (59) math_or_alt -> OR . math_and new_quad math_or_alt
    (61) math_and -> . math_comp math_and_alt
    (64) math_comp -> . math_exp math_comp_alt
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 36
    THIS            shift and go to state 55
    ID              shift and go to state 89
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    term                           shift and go to state 52
    math_comp                      shift and go to state 40
    number                         shift and go to state 27
    prop                           shift and go to state 88
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    math_and                       shift and go to state 135

state 98

    (98) for_block -> FOR number . FOR_TO number SKIP number block

    FOR_TO          shift and go to state 136


state 99

    (77) term -> factor term_alt .

    +               reduce using rule 77 (term -> factor term_alt .)
    -               reduce using rule 77 (term -> factor term_alt .)
    <               reduce using rule 77 (term -> factor term_alt .)
    >               reduce using rule 77 (term -> factor term_alt .)
    EQ              reduce using rule 77 (term -> factor term_alt .)
    NE              reduce using rule 77 (term -> factor term_alt .)
    LE              reduce using rule 77 (term -> factor term_alt .)
    GE              reduce using rule 77 (term -> factor term_alt .)
    AND             reduce using rule 77 (term -> factor term_alt .)
    OR              reduce using rule 77 (term -> factor term_alt .)
    ;               reduce using rule 77 (term -> factor term_alt .)
    )               reduce using rule 77 (term -> factor term_alt .)
    ,               reduce using rule 77 (term -> factor term_alt .)


state 100

    (78) term_alt -> * . factor new_quad term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 36
    THIS            shift and go to state 55
    ID              shift and go to state 89
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    number                         shift and go to state 27
    prop                           shift and go to state 88
    call                           shift and go to state 38
    factor                         shift and go to state 137

state 101

    (79) term_alt -> / . factor new_quad term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 36
    THIS            shift and go to state 55
    ID              shift and go to state 89
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    number                         shift and go to state 27
    prop                           shift and go to state 88
    call                           shift and go to state 38
    factor                         shift and go to state 138

state 102

    (80) term_alt -> empty .

    +               reduce using rule 80 (term_alt -> empty .)
    -               reduce using rule 80 (term_alt -> empty .)
    <               reduce using rule 80 (term_alt -> empty .)
    >               reduce using rule 80 (term_alt -> empty .)
    EQ              reduce using rule 80 (term_alt -> empty .)
    NE              reduce using rule 80 (term_alt -> empty .)
    LE              reduce using rule 80 (term_alt -> empty .)
    GE              reduce using rule 80 (term_alt -> empty .)
    AND             reduce using rule 80 (term_alt -> empty .)
    OR              reduce using rule 80 (term_alt -> empty .)
    ;               reduce using rule 80 (term_alt -> empty .)
    )               reduce using rule 80 (term_alt -> empty .)
    ,               reduce using rule 80 (term_alt -> empty .)


state 103

    (24) statement -> declaration ; .

    $               reduce using rule 24 (statement -> declaration ; .)
    PRINT           reduce using rule 24 (statement -> declaration ; .)
    IF              reduce using rule 24 (statement -> declaration ; .)
    WHILE           reduce using rule 24 (statement -> declaration ; .)
    FOR             reduce using rule 24 (statement -> declaration ; .)
    READ            reduce using rule 24 (statement -> declaration ; .)
    STRING          reduce using rule 24 (statement -> declaration ; .)
    NEW             reduce using rule 24 (statement -> declaration ; .)
    ID              reduce using rule 24 (statement -> declaration ; .)
    THIS            reduce using rule 24 (statement -> declaration ; .)
    (               reduce using rule 24 (statement -> declaration ; .)
    FLOAT           reduce using rule 24 (statement -> declaration ; .)
    INT             reduce using rule 24 (statement -> declaration ; .)
    $end            reduce using rule 24 (statement -> declaration ; .)
    }               reduce using rule 24 (statement -> declaration ; .)
    RETURN          reduce using rule 24 (statement -> declaration ; .)


state 104

    (54) stack_call -> ID . . stack_method
    (86) prop -> ID . . ID
    (55) stack_method -> . POP ( )
    (56) stack_method -> . PUSH ( exp )
    (57) stack_method -> . PEEK ( )

    ID              shift and go to state 143
    POP             shift and go to state 141
    PUSH            shift and go to state 142
    PEEK            shift and go to state 139

    stack_method                   shift and go to state 140

state 105

    (95) if_block -> IF ( . exp exp_evaluation ) block
    (96) if_block -> IF ( . exp exp_evaluation ) block after_if_block ELSE block
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (30) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    $               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    prop                           shift and go to state 33
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    read                           shift and go to state 37
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 125
    term                           shift and go to state 52
    exp                            shift and go to state 144
    assign                         shift and go to state 59

state 106

    (73) math_exp -> term math_exp_alt .

    <               reduce using rule 73 (math_exp -> term math_exp_alt .)
    >               reduce using rule 73 (math_exp -> term math_exp_alt .)
    EQ              reduce using rule 73 (math_exp -> term math_exp_alt .)
    NE              reduce using rule 73 (math_exp -> term math_exp_alt .)
    LE              reduce using rule 73 (math_exp -> term math_exp_alt .)
    GE              reduce using rule 73 (math_exp -> term math_exp_alt .)
    AND             reduce using rule 73 (math_exp -> term math_exp_alt .)
    OR              reduce using rule 73 (math_exp -> term math_exp_alt .)
    )               reduce using rule 73 (math_exp -> term math_exp_alt .)
    ;               reduce using rule 73 (math_exp -> term math_exp_alt .)
    ,               reduce using rule 73 (math_exp -> term math_exp_alt .)


state 107

    (75) math_exp_alt -> - . term new_quad math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 36
    THIS            shift and go to state 55
    ID              shift and go to state 89
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    term                           shift and go to state 145
    number                         shift and go to state 27
    prop                           shift and go to state 88
    call                           shift and go to state 38
    factor                         shift and go to state 48

state 108

    (74) math_exp_alt -> + . term new_quad math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    (               shift and go to state 36
    THIS            shift and go to state 55
    ID              shift and go to state 89
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    term                           shift and go to state 146
    number                         shift and go to state 27
    prop                           shift and go to state 88
    call                           shift and go to state 38
    factor                         shift and go to state 48

state 109

    (76) math_exp_alt -> empty .

    <               reduce using rule 76 (math_exp_alt -> empty .)
    >               reduce using rule 76 (math_exp_alt -> empty .)
    EQ              reduce using rule 76 (math_exp_alt -> empty .)
    NE              reduce using rule 76 (math_exp_alt -> empty .)
    LE              reduce using rule 76 (math_exp_alt -> empty .)
    GE              reduce using rule 76 (math_exp_alt -> empty .)
    AND             reduce using rule 76 (math_exp_alt -> empty .)
    OR              reduce using rule 76 (math_exp_alt -> empty .)
    ;               reduce using rule 76 (math_exp_alt -> empty .)
    )               reduce using rule 76 (math_exp_alt -> empty .)
    ,               reduce using rule 76 (math_exp_alt -> empty .)


state 110

    (85) prop -> THIS . . ID

    ID              shift and go to state 147


state 111

    (40) expr -> exp ; .

    $               reduce using rule 40 (expr -> exp ; .)
    PRINT           reduce using rule 40 (expr -> exp ; .)
    IF              reduce using rule 40 (expr -> exp ; .)
    WHILE           reduce using rule 40 (expr -> exp ; .)
    FOR             reduce using rule 40 (expr -> exp ; .)
    READ            reduce using rule 40 (expr -> exp ; .)
    STRING          reduce using rule 40 (expr -> exp ; .)
    NEW             reduce using rule 40 (expr -> exp ; .)
    ID              reduce using rule 40 (expr -> exp ; .)
    THIS            reduce using rule 40 (expr -> exp ; .)
    (               reduce using rule 40 (expr -> exp ; .)
    FLOAT           reduce using rule 40 (expr -> exp ; .)
    INT             reduce using rule 40 (expr -> exp ; .)
    $end            reduce using rule 40 (expr -> exp ; .)
    }               reduce using rule 40 (expr -> exp ; .)
    RETURN          reduce using rule 40 (expr -> exp ; .)


state 112

    (16) function -> # ID neg_lookup : . return_type params scope_function func_block
    (17) return_type -> . VOID
    (18) return_type -> . type
    (33) type -> . INT_TYPE
    (34) type -> . FLOAT_TYPE
    (35) type -> . STRING_TYPE
    (36) type -> . BOOLEAN_TYPE
    (37) type -> . ID check_class

    VOID            shift and go to state 149
    INT_TYPE        shift and go to state 152
    FLOAT_TYPE      shift and go to state 148
    STRING_TYPE     shift and go to state 151
    BOOLEAN_TYPE    shift and go to state 150
    ID              shift and go to state 155

    return_type                    shift and go to state 153
    type                           shift and go to state 154

state 113

    (8) params -> ( attrs ) .

    {               reduce using rule 8 (params -> ( attrs ) .)


state 114

    (31) attr -> ID : . type
    (32) attr -> ID : . stack_type
    (33) type -> . INT_TYPE
    (34) type -> . FLOAT_TYPE
    (35) type -> . STRING_TYPE
    (36) type -> . BOOLEAN_TYPE
    (37) type -> . ID check_class
    (38) stack_type -> . STACK ( type )

    INT_TYPE        shift and go to state 152
    FLOAT_TYPE      shift and go to state 148
    STRING_TYPE     shift and go to state 151
    BOOLEAN_TYPE    shift and go to state 150
    ID              shift and go to state 155
    STACK           shift and go to state 157

    type                           shift and go to state 158
    stack_type                     shift and go to state 156

state 115

    (11) attrs_alt -> , . attr attrs_alt
    (31) attr -> . ID : type
    (32) attr -> . ID : stack_type

    ID              shift and go to state 63

    attr                           shift and go to state 159

state 116

    (12) attrs_alt -> empty .

    )               reduce using rule 12 (attrs_alt -> empty .)


state 117

    (9) attrs -> attr attrs_alt .

    )               reduce using rule 9 (attrs -> attr attrs_alt .)


state 118

    (5) class -> @ ID inheritance params scope_class class_block .

    @               reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    #               reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    $               reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    PRINT           reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    IF              reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    WHILE           reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    FOR             reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    READ            reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    STRING          reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    NEW             reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    ID              reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    THIS            reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    (               reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    FLOAT           reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    INT             reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)
    $end            reduce using rule 5 (class -> @ ID inheritance params scope_class class_block .)


state 119

    (13) class_block -> { . functions }
    (14) functions -> . function functions
    (15) functions -> . empty
    (16) function -> . # ID neg_lookup : return_type params scope_function func_block
    (100) empty -> .

    #               shift and go to state 9
    }               reduce using rule 100 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 160
    empty                          shift and go to state 10

state 120

    (6) inheritance -> < ID check_class > .

    (               reduce using rule 6 (inheritance -> < ID check_class > .)


state 121

    (47) read -> READ ( ) .

    )               reduce using rule 47 (read -> READ ( ) .)
    ;               reduce using rule 47 (read -> READ ( ) .)
    ,               reduce using rule 47 (read -> READ ( ) .)


state 122

    (97) while_block -> WHILE ( leave_breadcrumb . exp exp_evaluation ) block
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (30) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    $               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    prop                           shift and go to state 33
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    read                           shift and go to state 37
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 125
    term                           shift and go to state 52
    exp                            shift and go to state 161
    assign                         shift and go to state 59

state 123

    (108) leave_breadcrumb -> empty .

    READ            reduce using rule 108 (leave_breadcrumb -> empty .)
    STRING          reduce using rule 108 (leave_breadcrumb -> empty .)
    NEW             reduce using rule 108 (leave_breadcrumb -> empty .)
    ID              reduce using rule 108 (leave_breadcrumb -> empty .)
    THIS            reduce using rule 108 (leave_breadcrumb -> empty .)
    $               reduce using rule 108 (leave_breadcrumb -> empty .)
    (               reduce using rule 108 (leave_breadcrumb -> empty .)
    FLOAT           reduce using rule 108 (leave_breadcrumb -> empty .)
    INT             reduce using rule 108 (leave_breadcrumb -> empty .)


state 124

    (53) constructor_call -> ID ( . args )
    (91) args -> . exp args_aux
    (92) args -> . empty
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (100) empty -> .
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (30) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    )               reduce using rule 100 (empty -> .)
    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    $               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    prop                           shift and go to state 33
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    empty                          shift and go to state 127
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    read                           shift and go to state 37
    math_comp                      shift and go to state 40
    args                           shift and go to state 162
    declaration                    shift and go to state 125
    term                           shift and go to state 52
    exp                            shift and go to state 129
    assign                         shift and go to state 59

state 125

    (51) var -> declaration .

    =               reduce using rule 51 (var -> declaration .)


state 126

    (39) print_stmt -> PRINT ( exp . ) ;

    )               shift and go to state 163


state 127

    (92) args -> empty .

    )               reduce using rule 92 (args -> empty .)


state 128

    (90) call -> prop ( args . )

    )               shift and go to state 164


state 129

    (91) args -> exp . args_aux
    (93) args_aux -> . , exp args_aux
    (94) args_aux -> . empty
    (100) empty -> .

    ,               shift and go to state 167
    )               reduce using rule 100 (empty -> .)

    args_aux                       shift and go to state 165
    empty                          shift and go to state 166

state 130

    (65) math_comp_alt -> comparison_op math_exp . new_quad
    (101) new_quad -> . empty
    (100) empty -> .

    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    new_quad                       shift and go to state 168
    empty                          shift and go to state 169

state 131

    (84) factor -> ( math_or ) .

    *               reduce using rule 84 (factor -> ( math_or ) .)
    /               reduce using rule 84 (factor -> ( math_or ) .)
    +               reduce using rule 84 (factor -> ( math_or ) .)
    -               reduce using rule 84 (factor -> ( math_or ) .)
    <               reduce using rule 84 (factor -> ( math_or ) .)
    >               reduce using rule 84 (factor -> ( math_or ) .)
    EQ              reduce using rule 84 (factor -> ( math_or ) .)
    NE              reduce using rule 84 (factor -> ( math_or ) .)
    LE              reduce using rule 84 (factor -> ( math_or ) .)
    GE              reduce using rule 84 (factor -> ( math_or ) .)
    AND             reduce using rule 84 (factor -> ( math_or ) .)
    OR              reduce using rule 84 (factor -> ( math_or ) .)
    ;               reduce using rule 84 (factor -> ( math_or ) .)
    )               reduce using rule 84 (factor -> ( math_or ) .)
    ,               reduce using rule 84 (factor -> ( math_or ) .)


state 132

    (86) prop -> ID . . ID

    ID              shift and go to state 143


state 133

    (62) math_and_alt -> AND math_comp . new_quad math_and_alt
    (101) new_quad -> . empty
    (100) empty -> .

    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    new_quad                       shift and go to state 170
    empty                          shift and go to state 169

state 134

    (48) assign -> var = exp .

    ;               reduce using rule 48 (assign -> var = exp .)
    )               reduce using rule 48 (assign -> var = exp .)
    ,               reduce using rule 48 (assign -> var = exp .)


state 135

    (59) math_or_alt -> OR math_and . new_quad math_or_alt
    (101) new_quad -> . empty
    (100) empty -> .

    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    new_quad                       shift and go to state 171
    empty                          shift and go to state 169

state 136

    (98) for_block -> FOR number FOR_TO . number SKIP number block
    (88) number -> . FLOAT empty
    (89) number -> . INT

    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    number                         shift and go to state 172

state 137

    (78) term_alt -> * factor . new_quad term_alt
    (101) new_quad -> . empty
    (100) empty -> .

    *               reduce using rule 100 (empty -> .)
    /               reduce using rule 100 (empty -> .)
    +               reduce using rule 100 (empty -> .)
    -               reduce using rule 100 (empty -> .)
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    new_quad                       shift and go to state 173
    empty                          shift and go to state 169

state 138

    (79) term_alt -> / factor . new_quad term_alt
    (101) new_quad -> . empty
    (100) empty -> .

    *               reduce using rule 100 (empty -> .)
    /               reduce using rule 100 (empty -> .)
    +               reduce using rule 100 (empty -> .)
    -               reduce using rule 100 (empty -> .)
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    new_quad                       shift and go to state 174
    empty                          shift and go to state 169

state 139

    (57) stack_method -> PEEK . ( )

    (               shift and go to state 175


state 140

    (54) stack_call -> ID . stack_method .

    )               reduce using rule 54 (stack_call -> ID . stack_method .)
    ;               reduce using rule 54 (stack_call -> ID . stack_method .)
    ,               reduce using rule 54 (stack_call -> ID . stack_method .)


state 141

    (55) stack_method -> POP . ( )

    (               shift and go to state 176


state 142

    (56) stack_method -> PUSH . ( exp )

    (               shift and go to state 177


state 143

    (86) prop -> ID . ID .

    (               reduce using rule 86 (prop -> ID . ID .)
    *               reduce using rule 86 (prop -> ID . ID .)
    /               reduce using rule 86 (prop -> ID . ID .)
    +               reduce using rule 86 (prop -> ID . ID .)
    -               reduce using rule 86 (prop -> ID . ID .)
    <               reduce using rule 86 (prop -> ID . ID .)
    >               reduce using rule 86 (prop -> ID . ID .)
    EQ              reduce using rule 86 (prop -> ID . ID .)
    NE              reduce using rule 86 (prop -> ID . ID .)
    LE              reduce using rule 86 (prop -> ID . ID .)
    GE              reduce using rule 86 (prop -> ID . ID .)
    AND             reduce using rule 86 (prop -> ID . ID .)
    OR              reduce using rule 86 (prop -> ID . ID .)
    ;               reduce using rule 86 (prop -> ID . ID .)
    )               reduce using rule 86 (prop -> ID . ID .)
    ,               reduce using rule 86 (prop -> ID . ID .)
    =               reduce using rule 86 (prop -> ID . ID .)


state 144

    (95) if_block -> IF ( exp . exp_evaluation ) block
    (96) if_block -> IF ( exp . exp_evaluation ) block after_if_block ELSE block
    (106) exp_evaluation -> . empty
    (100) empty -> .

    )               reduce using rule 100 (empty -> .)

    exp_evaluation                 shift and go to state 179
    empty                          shift and go to state 178

state 145

    (75) math_exp_alt -> - term . new_quad math_exp_alt
    (101) new_quad -> . empty
    (100) empty -> .

    +               reduce using rule 100 (empty -> .)
    -               reduce using rule 100 (empty -> .)
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    new_quad                       shift and go to state 180
    empty                          shift and go to state 169

state 146

    (74) math_exp_alt -> + term . new_quad math_exp_alt
    (101) new_quad -> . empty
    (100) empty -> .

    +               reduce using rule 100 (empty -> .)
    -               reduce using rule 100 (empty -> .)
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    new_quad                       shift and go to state 181
    empty                          shift and go to state 169

state 147

    (85) prop -> THIS . ID .

    (               reduce using rule 85 (prop -> THIS . ID .)
    *               reduce using rule 85 (prop -> THIS . ID .)
    /               reduce using rule 85 (prop -> THIS . ID .)
    +               reduce using rule 85 (prop -> THIS . ID .)
    -               reduce using rule 85 (prop -> THIS . ID .)
    <               reduce using rule 85 (prop -> THIS . ID .)
    >               reduce using rule 85 (prop -> THIS . ID .)
    EQ              reduce using rule 85 (prop -> THIS . ID .)
    NE              reduce using rule 85 (prop -> THIS . ID .)
    LE              reduce using rule 85 (prop -> THIS . ID .)
    GE              reduce using rule 85 (prop -> THIS . ID .)
    AND             reduce using rule 85 (prop -> THIS . ID .)
    OR              reduce using rule 85 (prop -> THIS . ID .)
    ;               reduce using rule 85 (prop -> THIS . ID .)
    )               reduce using rule 85 (prop -> THIS . ID .)
    ,               reduce using rule 85 (prop -> THIS . ID .)
    =               reduce using rule 85 (prop -> THIS . ID .)


state 148

    (34) type -> FLOAT_TYPE .

    (               reduce using rule 34 (type -> FLOAT_TYPE .)
    )               reduce using rule 34 (type -> FLOAT_TYPE .)
    ,               reduce using rule 34 (type -> FLOAT_TYPE .)
    ;               reduce using rule 34 (type -> FLOAT_TYPE .)
    =               reduce using rule 34 (type -> FLOAT_TYPE .)


state 149

    (17) return_type -> VOID .

    (               reduce using rule 17 (return_type -> VOID .)


state 150

    (36) type -> BOOLEAN_TYPE .

    (               reduce using rule 36 (type -> BOOLEAN_TYPE .)
    )               reduce using rule 36 (type -> BOOLEAN_TYPE .)
    ,               reduce using rule 36 (type -> BOOLEAN_TYPE .)
    ;               reduce using rule 36 (type -> BOOLEAN_TYPE .)
    =               reduce using rule 36 (type -> BOOLEAN_TYPE .)


state 151

    (35) type -> STRING_TYPE .

    (               reduce using rule 35 (type -> STRING_TYPE .)
    )               reduce using rule 35 (type -> STRING_TYPE .)
    ,               reduce using rule 35 (type -> STRING_TYPE .)
    ;               reduce using rule 35 (type -> STRING_TYPE .)
    =               reduce using rule 35 (type -> STRING_TYPE .)


state 152

    (33) type -> INT_TYPE .

    (               reduce using rule 33 (type -> INT_TYPE .)
    )               reduce using rule 33 (type -> INT_TYPE .)
    ,               reduce using rule 33 (type -> INT_TYPE .)
    ;               reduce using rule 33 (type -> INT_TYPE .)
    =               reduce using rule 33 (type -> INT_TYPE .)


state 153

    (16) function -> # ID neg_lookup : return_type . params scope_function func_block
    (8) params -> . ( attrs )

    (               shift and go to state 19

    params                         shift and go to state 182

state 154

    (18) return_type -> type .

    (               reduce using rule 18 (return_type -> type .)


state 155

    (37) type -> ID . check_class
    (104) check_class -> . empty
    (100) empty -> .

    (               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    =               reduce using rule 100 (empty -> .)

    empty                          shift and go to state 68
    check_class                    shift and go to state 183

state 156

    (32) attr -> ID : stack_type .

    ,               reduce using rule 32 (attr -> ID : stack_type .)
    )               reduce using rule 32 (attr -> ID : stack_type .)
    ;               reduce using rule 32 (attr -> ID : stack_type .)
    =               reduce using rule 32 (attr -> ID : stack_type .)


state 157

    (38) stack_type -> STACK . ( type )

    (               shift and go to state 184


state 158

    (31) attr -> ID : type .

    ,               reduce using rule 31 (attr -> ID : type .)
    )               reduce using rule 31 (attr -> ID : type .)
    ;               reduce using rule 31 (attr -> ID : type .)
    =               reduce using rule 31 (attr -> ID : type .)


state 159

    (11) attrs_alt -> , attr . attrs_alt
    (11) attrs_alt -> . , attr attrs_alt
    (12) attrs_alt -> . empty
    (100) empty -> .

    ,               shift and go to state 115
    )               reduce using rule 100 (empty -> .)

    empty                          shift and go to state 116
    attrs_alt                      shift and go to state 185

state 160

    (13) class_block -> { functions . }

    }               shift and go to state 186


state 161

    (97) while_block -> WHILE ( leave_breadcrumb exp . exp_evaluation ) block
    (106) exp_evaluation -> . empty
    (100) empty -> .

    )               reduce using rule 100 (empty -> .)

    exp_evaluation                 shift and go to state 187
    empty                          shift and go to state 178

state 162

    (53) constructor_call -> ID ( args . )

    )               shift and go to state 188


state 163

    (39) print_stmt -> PRINT ( exp ) . ;

    ;               shift and go to state 189


state 164

    (90) call -> prop ( args ) .

    *               reduce using rule 90 (call -> prop ( args ) .)
    /               reduce using rule 90 (call -> prop ( args ) .)
    +               reduce using rule 90 (call -> prop ( args ) .)
    -               reduce using rule 90 (call -> prop ( args ) .)
    <               reduce using rule 90 (call -> prop ( args ) .)
    >               reduce using rule 90 (call -> prop ( args ) .)
    EQ              reduce using rule 90 (call -> prop ( args ) .)
    NE              reduce using rule 90 (call -> prop ( args ) .)
    LE              reduce using rule 90 (call -> prop ( args ) .)
    GE              reduce using rule 90 (call -> prop ( args ) .)
    AND             reduce using rule 90 (call -> prop ( args ) .)
    OR              reduce using rule 90 (call -> prop ( args ) .)
    ;               reduce using rule 90 (call -> prop ( args ) .)
    ,               reduce using rule 90 (call -> prop ( args ) .)
    )               reduce using rule 90 (call -> prop ( args ) .)


state 165

    (91) args -> exp args_aux .

    )               reduce using rule 91 (args -> exp args_aux .)


state 166

    (94) args_aux -> empty .

    )               reduce using rule 94 (args_aux -> empty .)


state 167

    (93) args_aux -> , . exp args_aux
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (30) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    $               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    prop                           shift and go to state 33
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    read                           shift and go to state 37
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 125
    term                           shift and go to state 52
    exp                            shift and go to state 190
    assign                         shift and go to state 59

state 168

    (65) math_comp_alt -> comparison_op math_exp new_quad .

    AND             reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)
    OR              reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)
    ;               reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)
    )               reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)
    ,               reduce using rule 65 (math_comp_alt -> comparison_op math_exp new_quad .)


state 169

    (101) new_quad -> empty .

    +               reduce using rule 101 (new_quad -> empty .)
    -               reduce using rule 101 (new_quad -> empty .)
    <               reduce using rule 101 (new_quad -> empty .)
    >               reduce using rule 101 (new_quad -> empty .)
    EQ              reduce using rule 101 (new_quad -> empty .)
    NE              reduce using rule 101 (new_quad -> empty .)
    LE              reduce using rule 101 (new_quad -> empty .)
    GE              reduce using rule 101 (new_quad -> empty .)
    AND             reduce using rule 101 (new_quad -> empty .)
    OR              reduce using rule 101 (new_quad -> empty .)
    ;               reduce using rule 101 (new_quad -> empty .)
    )               reduce using rule 101 (new_quad -> empty .)
    ,               reduce using rule 101 (new_quad -> empty .)
    *               reduce using rule 101 (new_quad -> empty .)
    /               reduce using rule 101 (new_quad -> empty .)


state 170

    (62) math_and_alt -> AND math_comp new_quad . math_and_alt
    (62) math_and_alt -> . AND math_comp new_quad math_and_alt
    (63) math_and_alt -> . empty
    (100) empty -> .

    AND             shift and go to state 91
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    math_and_alt                   shift and go to state 191
    empty                          shift and go to state 93

state 171

    (59) math_or_alt -> OR math_and new_quad . math_or_alt
    (59) math_or_alt -> . OR math_and new_quad math_or_alt
    (60) math_or_alt -> . empty
    (100) empty -> .

    OR              shift and go to state 97
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    math_or_alt                    shift and go to state 192
    empty                          shift and go to state 96

state 172

    (98) for_block -> FOR number FOR_TO number . SKIP number block

    SKIP            shift and go to state 193


state 173

    (78) term_alt -> * factor new_quad . term_alt
    (78) term_alt -> . * factor new_quad term_alt
    (79) term_alt -> . / factor new_quad term_alt
    (80) term_alt -> . empty
    (100) empty -> .

    *               shift and go to state 100
    /               shift and go to state 101
    +               reduce using rule 100 (empty -> .)
    -               reduce using rule 100 (empty -> .)
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    empty                          shift and go to state 102
    term_alt                       shift and go to state 194

state 174

    (79) term_alt -> / factor new_quad . term_alt
    (78) term_alt -> . * factor new_quad term_alt
    (79) term_alt -> . / factor new_quad term_alt
    (80) term_alt -> . empty
    (100) empty -> .

    *               shift and go to state 100
    /               shift and go to state 101
    +               reduce using rule 100 (empty -> .)
    -               reduce using rule 100 (empty -> .)
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    empty                          shift and go to state 102
    term_alt                       shift and go to state 195

state 175

    (57) stack_method -> PEEK ( . )

    )               shift and go to state 196


state 176

    (55) stack_method -> POP ( . )

    )               shift and go to state 197


state 177

    (56) stack_method -> PUSH ( . exp )
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (30) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    $               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    prop                           shift and go to state 33
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    read                           shift and go to state 37
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 125
    term                           shift and go to state 52
    exp                            shift and go to state 198
    assign                         shift and go to state 59

state 178

    (106) exp_evaluation -> empty .

    )               reduce using rule 106 (exp_evaluation -> empty .)


state 179

    (95) if_block -> IF ( exp exp_evaluation . ) block
    (96) if_block -> IF ( exp exp_evaluation . ) block after_if_block ELSE block

    )               shift and go to state 199


state 180

    (75) math_exp_alt -> - term new_quad . math_exp_alt
    (74) math_exp_alt -> . + term new_quad math_exp_alt
    (75) math_exp_alt -> . - term new_quad math_exp_alt
    (76) math_exp_alt -> . empty
    (100) empty -> .

    +               shift and go to state 108
    -               shift and go to state 107
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    math_exp_alt                   shift and go to state 200
    empty                          shift and go to state 109

state 181

    (74) math_exp_alt -> + term new_quad . math_exp_alt
    (74) math_exp_alt -> . + term new_quad math_exp_alt
    (75) math_exp_alt -> . - term new_quad math_exp_alt
    (76) math_exp_alt -> . empty
    (100) empty -> .

    +               shift and go to state 108
    -               shift and go to state 107
    <               reduce using rule 100 (empty -> .)
    >               reduce using rule 100 (empty -> .)
    EQ              reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    LE              reduce using rule 100 (empty -> .)
    GE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    ;               reduce using rule 100 (empty -> .)
    )               reduce using rule 100 (empty -> .)
    ,               reduce using rule 100 (empty -> .)

    math_exp_alt                   shift and go to state 201
    empty                          shift and go to state 109

state 182

    (16) function -> # ID neg_lookup : return_type params . scope_function func_block
    (103) scope_function -> . empty
    (100) empty -> .

    {               reduce using rule 100 (empty -> .)

    scope_function                 shift and go to state 202
    empty                          shift and go to state 203

state 183

    (37) type -> ID check_class .

    (               reduce using rule 37 (type -> ID check_class .)
    )               reduce using rule 37 (type -> ID check_class .)
    ,               reduce using rule 37 (type -> ID check_class .)
    ;               reduce using rule 37 (type -> ID check_class .)
    =               reduce using rule 37 (type -> ID check_class .)


state 184

    (38) stack_type -> STACK ( . type )
    (33) type -> . INT_TYPE
    (34) type -> . FLOAT_TYPE
    (35) type -> . STRING_TYPE
    (36) type -> . BOOLEAN_TYPE
    (37) type -> . ID check_class

    INT_TYPE        shift and go to state 152
    FLOAT_TYPE      shift and go to state 148
    STRING_TYPE     shift and go to state 151
    BOOLEAN_TYPE    shift and go to state 150
    ID              shift and go to state 155

    type                           shift and go to state 204

state 185

    (11) attrs_alt -> , attr attrs_alt .

    )               reduce using rule 11 (attrs_alt -> , attr attrs_alt .)


state 186

    (13) class_block -> { functions } .

    @               reduce using rule 13 (class_block -> { functions } .)
    #               reduce using rule 13 (class_block -> { functions } .)
    $               reduce using rule 13 (class_block -> { functions } .)
    PRINT           reduce using rule 13 (class_block -> { functions } .)
    IF              reduce using rule 13 (class_block -> { functions } .)
    WHILE           reduce using rule 13 (class_block -> { functions } .)
    FOR             reduce using rule 13 (class_block -> { functions } .)
    READ            reduce using rule 13 (class_block -> { functions } .)
    STRING          reduce using rule 13 (class_block -> { functions } .)
    NEW             reduce using rule 13 (class_block -> { functions } .)
    ID              reduce using rule 13 (class_block -> { functions } .)
    THIS            reduce using rule 13 (class_block -> { functions } .)
    (               reduce using rule 13 (class_block -> { functions } .)
    FLOAT           reduce using rule 13 (class_block -> { functions } .)
    INT             reduce using rule 13 (class_block -> { functions } .)
    $end            reduce using rule 13 (class_block -> { functions } .)


state 187

    (97) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation . ) block

    )               shift and go to state 205


state 188

    (53) constructor_call -> ID ( args ) .

    ;               reduce using rule 53 (constructor_call -> ID ( args ) .)
    )               reduce using rule 53 (constructor_call -> ID ( args ) .)
    ,               reduce using rule 53 (constructor_call -> ID ( args ) .)


state 189

    (39) print_stmt -> PRINT ( exp ) ; .

    $               reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    PRINT           reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    IF              reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    WHILE           reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    FOR             reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    READ            reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    STRING          reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    NEW             reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    ID              reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    THIS            reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    (               reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    FLOAT           reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    INT             reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    $end            reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    }               reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)
    RETURN          reduce using rule 39 (print_stmt -> PRINT ( exp ) ; .)


state 190

    (93) args_aux -> , exp . args_aux
    (93) args_aux -> . , exp args_aux
    (94) args_aux -> . empty
    (100) empty -> .

    ,               shift and go to state 167
    )               reduce using rule 100 (empty -> .)

    args_aux                       shift and go to state 206
    empty                          shift and go to state 166

state 191

    (62) math_and_alt -> AND math_comp new_quad math_and_alt .

    OR              reduce using rule 62 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ;               reduce using rule 62 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    )               reduce using rule 62 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ,               reduce using rule 62 (math_and_alt -> AND math_comp new_quad math_and_alt .)


state 192

    (59) math_or_alt -> OR math_and new_quad math_or_alt .

    ;               reduce using rule 59 (math_or_alt -> OR math_and new_quad math_or_alt .)
    )               reduce using rule 59 (math_or_alt -> OR math_and new_quad math_or_alt .)
    ,               reduce using rule 59 (math_or_alt -> OR math_and new_quad math_or_alt .)


state 193

    (98) for_block -> FOR number FOR_TO number SKIP . number block
    (88) number -> . FLOAT empty
    (89) number -> . INT

    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    number                         shift and go to state 207

state 194

    (78) term_alt -> * factor new_quad term_alt .

    +               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    -               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    <               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    >               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    EQ              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    NE              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    LE              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    GE              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    AND             reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    OR              reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    ;               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    )               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)
    ,               reduce using rule 78 (term_alt -> * factor new_quad term_alt .)


state 195

    (79) term_alt -> / factor new_quad term_alt .

    +               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    -               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    <               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    >               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    EQ              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    NE              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    LE              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    GE              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    AND             reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    OR              reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    ;               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    )               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)
    ,               reduce using rule 79 (term_alt -> / factor new_quad term_alt .)


state 196

    (57) stack_method -> PEEK ( ) .

    ;               reduce using rule 57 (stack_method -> PEEK ( ) .)
    )               reduce using rule 57 (stack_method -> PEEK ( ) .)
    ,               reduce using rule 57 (stack_method -> PEEK ( ) .)


state 197

    (55) stack_method -> POP ( ) .

    ;               reduce using rule 55 (stack_method -> POP ( ) .)
    )               reduce using rule 55 (stack_method -> POP ( ) .)
    ,               reduce using rule 55 (stack_method -> POP ( ) .)


state 198

    (56) stack_method -> PUSH ( exp . )

    )               shift and go to state 208


state 199

    (95) if_block -> IF ( exp exp_evaluation ) . block
    (96) if_block -> IF ( exp exp_evaluation ) . block after_if_block ELSE block
    (99) block -> . { statements }

    {               shift and go to state 209

    block                          shift and go to state 210

state 200

    (75) math_exp_alt -> - term new_quad math_exp_alt .

    <               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    >               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    EQ              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    NE              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    LE              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    GE              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    AND             reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    OR              reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    ;               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    )               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)
    ,               reduce using rule 75 (math_exp_alt -> - term new_quad math_exp_alt .)


state 201

    (74) math_exp_alt -> + term new_quad math_exp_alt .

    <               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    >               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    EQ              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    NE              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    LE              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    GE              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    AND             reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    OR              reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    ;               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    )               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)
    ,               reduce using rule 74 (math_exp_alt -> + term new_quad math_exp_alt .)


state 202

    (16) function -> # ID neg_lookup : return_type params scope_function . func_block
    (19) func_block -> . { statements return }

    {               shift and go to state 212

    func_block                     shift and go to state 211

state 203

    (103) scope_function -> empty .

    {               reduce using rule 103 (scope_function -> empty .)


state 204

    (38) stack_type -> STACK ( type . )

    )               shift and go to state 213


state 205

    (97) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) . block
    (99) block -> . { statements }

    {               shift and go to state 209

    block                          shift and go to state 214

state 206

    (93) args_aux -> , exp args_aux .

    )               reduce using rule 93 (args_aux -> , exp args_aux .)


state 207

    (98) for_block -> FOR number FOR_TO number SKIP number . block
    (99) block -> . { statements }

    {               shift and go to state 209

    block                          shift and go to state 215

state 208

    (56) stack_method -> PUSH ( exp ) .

    ;               reduce using rule 56 (stack_method -> PUSH ( exp ) .)
    )               reduce using rule 56 (stack_method -> PUSH ( exp ) .)
    ,               reduce using rule 56 (stack_method -> PUSH ( exp ) .)


state 209

    (99) block -> { . statements }
    (22) statements -> . statement statements
    (23) statements -> . empty
    (24) statement -> . declaration ;
    (25) statement -> . print_stmt
    (26) statement -> . if_block
    (27) statement -> . while_block
    (28) statement -> . for_block
    (29) statement -> . expr
    (100) empty -> .
    (30) declaration -> . $ attr
    (39) print_stmt -> . PRINT ( exp ) ;
    (95) if_block -> . IF ( exp exp_evaluation ) block
    (96) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (97) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (98) for_block -> . FOR number FOR_TO number SKIP number block
    (40) expr -> . exp ;
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    }               reduce using rule 100 (empty -> .)
    $               shift and go to state 35
    PRINT           shift and go to state 31
    IF              shift and go to state 51
    WHILE           shift and go to state 28
    FOR             shift and go to state 46
    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    for_block                      shift and go to state 23
    statements                     shift and go to state 216
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    math_exp                       shift and go to state 34
    prop                           shift and go to state 33
    read                           shift and go to state 37
    call                           shift and go to state 38
    statement                      shift and go to state 39
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    empty                          shift and go to state 43
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    print_stmt                     shift and go to state 47
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 49
    term                           shift and go to state 52
    expr                           shift and go to state 53
    if_block                       shift and go to state 54
    while_block                    shift and go to state 56
    exp                            shift and go to state 57
    assign                         shift and go to state 59

state 210

    (95) if_block -> IF ( exp exp_evaluation ) block .
    (96) if_block -> IF ( exp exp_evaluation ) block . after_if_block ELSE block
    (107) after_if_block -> . empty
    (100) empty -> .

    $               reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    PRINT           reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    IF              reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    WHILE           reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    FOR             reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    READ            reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    STRING          reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    NEW             reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    ID              reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    THIS            reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    (               reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    FLOAT           reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    INT             reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    $end            reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    }               reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    RETURN          reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block .)
    ELSE            reduce using rule 100 (empty -> .)

    empty                          shift and go to state 218
    after_if_block                 shift and go to state 217

state 211

    (16) function -> # ID neg_lookup : return_type params scope_function func_block .

    #               reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $               reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    PRINT           reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    IF              reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    WHILE           reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FOR             reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    READ            reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    STRING          reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    NEW             reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    ID              reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    THIS            reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    (               reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FLOAT           reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    INT             reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $end            reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    }               reduce using rule 16 (function -> # ID neg_lookup : return_type params scope_function func_block .)


state 212

    (19) func_block -> { . statements return }
    (22) statements -> . statement statements
    (23) statements -> . empty
    (24) statement -> . declaration ;
    (25) statement -> . print_stmt
    (26) statement -> . if_block
    (27) statement -> . while_block
    (28) statement -> . for_block
    (29) statement -> . expr
    (100) empty -> .
    (30) declaration -> . $ attr
    (39) print_stmt -> . PRINT ( exp ) ;
    (95) if_block -> . IF ( exp exp_evaluation ) block
    (96) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (97) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (98) for_block -> . FOR number FOR_TO number SKIP number block
    (40) expr -> . exp ;
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    RETURN          reduce using rule 100 (empty -> .)
    }               reduce using rule 100 (empty -> .)
    $               shift and go to state 35
    PRINT           shift and go to state 31
    IF              shift and go to state 51
    WHILE           shift and go to state 28
    FOR             shift and go to state 46
    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    for_block                      shift and go to state 23
    statements                     shift and go to state 219
    number                         shift and go to state 27
    math_and                       shift and go to state 44
    stack_call                     shift and go to state 32
    math_exp                       shift and go to state 34
    prop                           shift and go to state 33
    read                           shift and go to state 37
    call                           shift and go to state 38
    statement                      shift and go to state 39
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    empty                          shift and go to state 43
    string                         shift and go to state 45
    print_stmt                     shift and go to state 47
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 49
    term                           shift and go to state 52
    expr                           shift and go to state 53
    if_block                       shift and go to state 54
    while_block                    shift and go to state 56
    exp                            shift and go to state 57
    assign                         shift and go to state 59

state 213

    (38) stack_type -> STACK ( type ) .

    ,               reduce using rule 38 (stack_type -> STACK ( type ) .)
    )               reduce using rule 38 (stack_type -> STACK ( type ) .)
    ;               reduce using rule 38 (stack_type -> STACK ( type ) .)
    =               reduce using rule 38 (stack_type -> STACK ( type ) .)


state 214

    (97) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .

    $               reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    PRINT           reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    IF              reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    WHILE           reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    FOR             reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    READ            reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    STRING          reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    NEW             reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    ID              reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    THIS            reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    (               reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    FLOAT           reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    INT             reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    $end            reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    }               reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    RETURN          reduce using rule 97 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)


state 215

    (98) for_block -> FOR number FOR_TO number SKIP number block .

    $               reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    PRINT           reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    IF              reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    WHILE           reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    FOR             reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    READ            reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    STRING          reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    NEW             reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    ID              reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    THIS            reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    (               reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    FLOAT           reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    INT             reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    RETURN          reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    }               reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)
    $end            reduce using rule 98 (for_block -> FOR number FOR_TO number SKIP number block .)


state 216

    (99) block -> { statements . }

    }               shift and go to state 220


state 217

    (96) if_block -> IF ( exp exp_evaluation ) block after_if_block . ELSE block

    ELSE            shift and go to state 221


state 218

    (107) after_if_block -> empty .

    ELSE            reduce using rule 107 (after_if_block -> empty .)


state 219

    (19) func_block -> { statements . return }
    (20) return -> . RETURN exp ;
    (21) return -> . empty
    (100) empty -> .

    RETURN          shift and go to state 223
    }               reduce using rule 100 (empty -> .)

    return                         shift and go to state 222
    empty                          shift and go to state 224

state 220

    (99) block -> { statements } .

    $               reduce using rule 99 (block -> { statements } .)
    PRINT           reduce using rule 99 (block -> { statements } .)
    IF              reduce using rule 99 (block -> { statements } .)
    WHILE           reduce using rule 99 (block -> { statements } .)
    FOR             reduce using rule 99 (block -> { statements } .)
    READ            reduce using rule 99 (block -> { statements } .)
    STRING          reduce using rule 99 (block -> { statements } .)
    NEW             reduce using rule 99 (block -> { statements } .)
    ID              reduce using rule 99 (block -> { statements } .)
    THIS            reduce using rule 99 (block -> { statements } .)
    (               reduce using rule 99 (block -> { statements } .)
    FLOAT           reduce using rule 99 (block -> { statements } .)
    INT             reduce using rule 99 (block -> { statements } .)
    $end            reduce using rule 99 (block -> { statements } .)
    }               reduce using rule 99 (block -> { statements } .)
    RETURN          reduce using rule 99 (block -> { statements } .)
    ELSE            reduce using rule 99 (block -> { statements } .)


state 221

    (96) if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE . block
    (99) block -> . { statements }

    {               shift and go to state 209

    block                          shift and go to state 225

state 222

    (19) func_block -> { statements return . }

    }               shift and go to state 226


state 223

    (20) return -> RETURN . exp ;
    (41) exp -> . read
    (42) exp -> . math_or
    (43) exp -> . assign
    (44) exp -> . string
    (45) exp -> . new
    (46) exp -> . stack_call
    (47) read -> . READ ( )
    (58) math_or -> . math_and math_or_alt
    (48) assign -> . var = exp
    (49) string -> . STRING
    (52) new -> . NEW constructor_call
    (54) stack_call -> . ID . stack_method
    (61) math_and -> . math_comp math_and_alt
    (50) var -> . prop
    (51) var -> . declaration
    (64) math_comp -> . math_exp math_comp_alt
    (85) prop -> . THIS . ID
    (86) prop -> . ID . ID
    (87) prop -> . ID
    (30) declaration -> . $ attr
    (73) math_exp -> . term math_exp_alt
    (77) term -> . factor term_alt
    (81) factor -> . prop
    (82) factor -> . number
    (83) factor -> . call
    (84) factor -> . ( math_or )
    (88) number -> . FLOAT empty
    (89) number -> . INT
    (90) call -> . prop ( args )

    READ            shift and go to state 26
    STRING          shift and go to state 29
    NEW             shift and go to state 30
    ID              shift and go to state 50
    THIS            shift and go to state 55
    $               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 24
    INT             shift and go to state 58

    math_or                        shift and go to state 22
    number                         shift and go to state 27
    stack_call                     shift and go to state 32
    prop                           shift and go to state 33
    call                           shift and go to state 38
    math_exp                       shift and go to state 34
    factor                         shift and go to state 48
    var                            shift and go to state 41
    new                            shift and go to state 42
    math_and                       shift and go to state 44
    string                         shift and go to state 45
    read                           shift and go to state 37
    math_comp                      shift and go to state 40
    declaration                    shift and go to state 125
    term                           shift and go to state 52
    exp                            shift and go to state 227
    assign                         shift and go to state 59

state 224

    (21) return -> empty .

    }               reduce using rule 21 (return -> empty .)


state 225

    (96) if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .

    $               reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    PRINT           reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    IF              reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    WHILE           reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    FOR             reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    READ            reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    STRING          reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    NEW             reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    ID              reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    THIS            reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    (               reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    FLOAT           reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    INT             reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    $end            reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    }               reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    RETURN          reduce using rule 96 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)


state 226

    (19) func_block -> { statements return } .

    #               reduce using rule 19 (func_block -> { statements return } .)
    $               reduce using rule 19 (func_block -> { statements return } .)
    PRINT           reduce using rule 19 (func_block -> { statements return } .)
    IF              reduce using rule 19 (func_block -> { statements return } .)
    WHILE           reduce using rule 19 (func_block -> { statements return } .)
    FOR             reduce using rule 19 (func_block -> { statements return } .)
    READ            reduce using rule 19 (func_block -> { statements return } .)
    STRING          reduce using rule 19 (func_block -> { statements return } .)
    NEW             reduce using rule 19 (func_block -> { statements return } .)
    ID              reduce using rule 19 (func_block -> { statements return } .)
    THIS            reduce using rule 19 (func_block -> { statements return } .)
    (               reduce using rule 19 (func_block -> { statements return } .)
    FLOAT           reduce using rule 19 (func_block -> { statements return } .)
    INT             reduce using rule 19 (func_block -> { statements return } .)
    $end            reduce using rule 19 (func_block -> { statements return } .)
    }               reduce using rule 19 (func_block -> { statements return } .)


state 227

    (20) return -> RETURN exp . ;

    ;               shift and go to state 228


state 228

    (20) return -> RETURN exp ; .

    }               reduce using rule 20 (return -> RETURN exp ; .)

