Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> classes functions vars statements
Rule 2     vars -> var vars
Rule 3     vars -> empty
Rule 4     var -> $ attr init ;
Rule 5     attr -> ID : type
Rule 6     init -> = exp
Rule 7     init -> empty
Rule 8     type -> INT_TYPE
Rule 9     type -> FLOAT_TYPE
Rule 10    type -> STRING_TYPE
Rule 11    type -> BOOLEAN_TYPE
Rule 12    type -> STACK
Rule 13    type -> ID
Rule 14    return_type -> VOID
Rule 15    return_type -> type
Rule 16    classes -> class classes
Rule 17    classes -> empty
Rule 18    class -> @ ID inheritance open_class class_block
Rule 19    inheritance -> < ID >
Rule 20    inheritance -> empty
Rule 21    class_block -> { vars constructor functions }
Rule 22    constructor -> ~ ID params func_block
Rule 23    constructor -> empty
Rule 24    functions -> scope_function function functions
Rule 25    functions -> empty
Rule 26    function -> # ID : return_type params func_block
Rule 27    params -> ( attrs )
Rule 28    attrs -> attr attrs_alt
Rule 29    attrs -> empty
Rule 30    attrs_alt -> , attr attrs_alt
Rule 31    attrs_alt -> empty
Rule 32    func_block -> { vars statements }
Rule 33    statements -> statement
Rule 34    statements -> empty
Rule 35    statement -> if_block
Rule 36    statement -> while_block
Rule 37    statement -> for_block
Rule 38    statement -> print_stmt
Rule 39    statement -> expr
Rule 40    statement -> return
Rule 41    assign -> prop = expr
Rule 42    assign -> prop = NEW ID
Rule 43    prop -> THIS . ID
Rule 44    prop -> ID . ID
Rule 45    prop -> ID
Rule 46    if_block -> IF ( exp ) block
Rule 47    if_block -> IF ( exp ) block ELSE block
Rule 48    while_block -> WHILE ( exp ) block
Rule 49    for_block -> FOR number FOR_TO number SKIP number block
Rule 50    print_stmt -> PRINT ( exp ) ;
Rule 51    return -> RETURN exp ;
Rule 52    return -> RETURN ;
Rule 53    block -> { statements }
Rule 54    number -> FLOAT
Rule 55    number -> INT
Rule 56    expr -> exp ;
Rule 57    exp -> read
Rule 58    exp -> logic_exp
Rule 59    exp -> assign
Rule 60    read -> READ ( string )
Rule 61    string -> ID
Rule 62    string -> STRING
Rule 63    math_exp -> term math_exp_alt
Rule 64    math_exp_alt -> + term math_exp_alt
Rule 65    math_exp_alt -> - term math_exp_alt
Rule 66    math_exp_alt -> empty
Rule 67    term -> factor term_alt
Rule 68    term_alt -> * factor term_alt
Rule 69    term_alt -> / factor term_alt
Rule 70    term_alt -> empty
Rule 71    factor -> ID
Rule 72    factor -> number
Rule 73    factor -> call
Rule 74    factor -> ( math_exp )
Rule 75    logic_exp -> log_a logic_exp_alt
Rule 76    logic_exp_alt -> OR log_a logic_exp_alt
Rule 77    logic_exp_alt -> empty
Rule 78    log_a -> log_b log_a_alt
Rule 79    log_a_alt -> AND log_b log_a_alt
Rule 80    log_a_alt -> empty
Rule 81    log_b -> ( logic_exp )
Rule 82    log_b -> bool
Rule 83    log_b -> comparison
Rule 84    bool -> TRUE
Rule 85    bool -> FALSE
Rule 86    comparison -> math_exp comparison_op math_exp
Rule 87    comparison -> math_exp
Rule 88    comparison_op -> <
Rule 89    comparison_op -> >
Rule 90    comparison_op -> EQ
Rule 91    comparison_op -> NE
Rule 92    call -> prop ( args )
Rule 93    call -> stack_call ( args )
Rule 94    args -> exp args_aux
Rule 95    args -> empty
Rule 96    args_aux -> , exp args_aux
Rule 97    args_aux -> empty
Rule 98    stack_call -> prop stack_method
Rule 99    stack_method -> POP
Rule 100   stack_method -> PUSH
Rule 101   stack_method -> PEEK
Rule 102   empty -> <empty>

Terminals, with rules where they appear

#                    : 26
$                    : 4
(                    : 27 46 47 48 50 60 74 81 92 93
)                    : 27 46 47 48 50 60 74 81 92 93
*                    : 68
+                    : 64
,                    : 30 96
-                    : 65
.                    : 43 44
/                    : 69
:                    : 5 26
;                    : 4 50 51 52 56
<                    : 19 88
=                    : 6 41 42
>            