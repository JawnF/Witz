Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> classes functions statements
Rule 2     classes -> class classes
Rule 3     classes -> empty
Rule 4     class -> @ ID inheritance params scope_class store_attributes class_block
Rule 5     inheritance -> < ID check_class >
Rule 6     inheritance -> empty
Rule 7     params -> ( attrs )
Rule 8     attrs -> attr attrs_alt
Rule 9     attrs -> empty
Rule 10    attrs_alt -> , attr attrs_alt
Rule 11    attrs_alt -> empty
Rule 12    class_block -> { functions }
Rule 13    functions -> function functions
Rule 14    functions -> empty
Rule 15    function -> # ID neg_lookup : return_type params scope_function func_block
Rule 16    return_type -> VOID
Rule 17    return_type -> type
Rule 18    func_block -> { statements return }
Rule 19    return -> RETURN exp ;
Rule 20    return -> empty
Rule 21    statements -> statement statements
Rule 22    statements -> empty
Rule 23    statement -> declaration
Rule 24    statement -> print_stmt
Rule 25    statement -> if_block
Rule 26    statement -> while_block
Rule 27    statement -> for_block
Rule 28    statement -> expr
Rule 29    declaration -> $ attr
Rule 30    attr -> ID : type
Rule 31    attr -> ID : stack_type
Rule 32    type -> INT_TYPE
Rule 33    type -> FLOAT_TYPE
Rule 34    type -> STRING_TYPE
Rule 35    type -> BOOLEAN_TYPE
Rule 36    type -> ID check_class
Rule 37    stack_type -> STACK ( type )
Rule 38    print_stmt -> PRINT ( exp ) ;
Rule 39    expr -> exp ;
Rule 40    exp -> read
Rule 41    exp -> math_or
Rule 42    exp -> assign
Rule 43    exp -> string
Rule 44    exp -> new
Rule 45    exp -> stack_call
Rule 46    read -> READ ( )
Rule 47    assign -> var = exp
Rule 48    string -> STRING
Rule 49    var -> prop
Rule 50    var -> declaration
Rule 51    new -> NEW constructor_call
Rule 52    constructor_call -> ID ( args )
Rule 53    stack_call -> ID . stack_method
Rule 54    stack_method -> POP ( )
Rule 55    stack_method -> PUSH ( prop )
Rule 56    stack_method -> PEEK ( )
Rule 57    math_or -> math_and math_or_alt
Rule 58    math_or_alt -> OR math_and new_quad math_or_alt
Rule 59    math_or_alt -> empty
Rule 60    math_and -> math_comp math_and_alt
Rule 61    math_and_alt -> AND math_comp new_quad math_and_alt
Rule 62    math_and_alt -> empty
Rule 63    math_comp -> math_exp math_comp_alt
Rule 64    math_comp_alt -> comparison_op math_exp new_quad
Rule 65    math_comp_alt -> empty
Rule 66    comparison_op -> <
Rule 67    comparison_op -> >
Rule 68    comparison_op -> EQ
Rule 69    comparison_op -> NE
Rule 70    comparison_op -> LE
Rule 71    comparison_op -> GE
Rule 72    math_exp -> term math_exp_alt
Rule 73    math_exp_alt -> + term new_quad math_exp_alt
Rule 74    math_exp_alt -> - term new_quad math_exp_alt
Rule 75    math_exp_alt -> empty
Rule 76    term -> factor term_alt
Rule 77    term_alt -> * factor new_quad term_alt
Rule 78    term_alt -> / factor new_quad term_alt
Rule 79    term_alt -> empty
Rule 80    factor -> prop
Rule 81    factor -> number
Rule 82    factor -> call
Rule 83    factor -> ( math_or )
Rule 84    prop -> THIS . ID
Rule 85    prop -> ID . ID
Rule 86    prop -> ID
Rule 87    number -> FLOAT empty
Rule 88    number -> INT
Rule 89    call -> prop ( args )
Rule 90    args -> exp args_aux
Rule 91    args -> empty
Rule 92    args_aux -> , exp args_aux
Rule 93    args_aux -> empty
Rule 94    if_block -> IF ( exp exp_evaluation ) block
Rule 95    if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block
Rule 96    while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block
Rule 97    for_block -> FOR number FOR_TO number SKIP number block
Rule 98    block -> { statements }
Rule 99    empty -> <empty>
Rule 100   new_quad -> empty
Rule 101   scope_class -> empty
Rule 102   scope_function -> empty
Rule 103   check_class -> empty
Rule 104   neg_lookup -> empty
Rule 105   store_attributes -> empty
Rule 106   exp_evaluation -> empty
Rule 107   after_if_block -> empty
Rule 108   leave_breadcrumb -> empty

Terminals, with rules where they appear

#                    : 15
$                    : 29
(                    : 7 37 38 46 52 54 55 56 83 89 94 95 96
)                    : 7 37 38 46 52 54 55 56 83 89 94 95 96
*                    : 77
+                    : 73
,                    : 10 92
-                    : 74
.                    : 53 84 85
/                    : 78
:                    : 15 30 31
;                    : 19 38 39
<                    : 5 66
=                    : 47
>                    : 5 67
@                    : 4
AND                  : 61
BOOLEAN_TYPE         : 35
ELSE                 : 95
EQ                   : 68
FLOAT                : 87
FLOAT_TYPE           : 33
FOR                  : 97
FOR_TO               : 97
GE                   : 71
ID                   : 4 5 15 30 31 36 52 53 84 85 85 86
IF                   : 94 95
INT                  : 88
INT_TYPE             : 32
LE                   : 70
NE                   : 69
NEW                  : 51
OR                   : 58
PEEK                 : 56
POP                  : 54
PRINT                : 38
PUSH                 : 55
READ                 : 46
RETURN               : 19
SKIP                 : 97
STACK                : 37
STRING               : 48
STRING_TYPE          : 34
THIS                 : 84
VOID                 : 16
WHILE                : 96
error                : 
{                    : 12 18 98
}                    : 12 18 98

Nonterminals, with rules where they appear

after_if_block       : 95
args                 : 52 89
args_aux             : 90 92
assign               : 42
attr                 : 8 10 29
attrs                : 7
attrs_alt            : 8 10
block                : 94 95 95 96 97
call                 : 82
check_class          : 5 36
class                : 2
class_block          : 4
classes              : 1 2
comparison_op        : 64
constructor_call     : 51
declaration          : 23 50
empty                : 3 6 9 11 14 20 22 59 62 65 75 79 87 91 93 100 101 102 103 104 105 106 107 108
exp                  : 19 38 39 47 90 92 94 95 96
exp_evaluation       : 94 95 96
expr                 : 28
factor               : 76 77 78
for_block            : 27
func_block           : 15
function             : 13
functions            : 1 12 13
if_block             : 25
inheritance          : 4
leave_breadcrumb     : 96
math_and             : 57 58
math_and_alt         : 60 61
math_comp            : 60 61
math_comp_alt        : 63
math_exp             : 63 64
math_exp_alt         : 72 73 74
math_or              : 41 83
math_or_alt          : 57 58
neg_lookup           : 15
new                  : 44
new_quad             : 58 61 64 73 74 77 78
number               : 81 97 97 97
params               : 4 15
print_stmt           : 24
program              : 0
prop                 : 49 55 80 89
read                 : 40
return               : 18
return_type          : 15
scope_class          : 4
scope_function       : 15
stack_call           : 45
stack_method         : 53
stack_type           : 31
statement            : 21
statements           : 1 18 21 98
store_attributes     : 4
string               : 43
term                 : 72 73 74
term_alt             : 76 77 78
type                 : 17 30 37
var                  : 47
while_block          : 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . classes functions statements
    (2) classes -> . class classes
    (3) classes -> . empty
    (4) class -> . @ ID inheritance params scope_class store_attributes class_block
    (99) empty -> .

    @               shift and go to state 2
    #               reduce using rule 99 (empty -> .)
    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    FOR             reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)

    program                        shift and go to state 1
    classes                        shift and go to state 3
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (4) class -> @ . ID inheritance params scope_class store_attributes class_block

    ID              shift and go to state 6


state 3

    (1) program -> classes . functions statements
    (13) functions -> . function functions
    (14) functions -> . empty
    (15) function -> . # ID neg_lookup : return_type params scope_function func_block
    (99) empty -> .

    #               shift and go to state 9
    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    FOR             reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 8
    empty                          shift and go to state 10

state 4

    (2) classes -> class . classes
    (2) classes -> . class classes
    (3) classes -> . empty
    (4) class -> . @ ID inheritance params scope_class store_attributes class_block
    (99) empty -> .

    @               shift and go to state 2
    #               reduce using rule 99 (empty -> .)
    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    FOR             reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)

    classes                        shift and go to state 11
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 5

    (3) classes -> empty .

    #               reduce using rule 3 (classes -> empty .)
    $               reduce using rule 3 (classes -> empty .)
    PRINT           reduce using rule 3 (classes -> empty .)
    IF              reduce using rule 3 (classes -> empty .)
    WHILE           reduce using rule 3 (classes -> empty .)
    FOR             reduce using rule 3 (classes -> empty .)
    READ            reduce using rule 3 (classes -> empty .)
    STRING          reduce using rule 3 (classes -> empty .)
    NEW             reduce using rule 3 (classes -> empty .)
    ID              reduce using rule 3 (classes -> empty .)
    THIS            reduce using rule 3 (classes -> empty .)
    (               reduce using rule 3 (classes -> empty .)
    FLOAT           reduce using rule 3 (classes -> empty .)
    INT             reduce using rule 3 (classes -> empty .)
    $end            reduce using rule 3 (classes -> empty .)


state 6

    (4) class -> @ ID . inheritance params scope_class store_attributes class_block
    (5) inheritance -> . < ID check_class >
    (6) inheritance -> . empty
    (99) empty -> .

    <               shift and go to state 13
    (               reduce using rule 99 (empty -> .)

    inheritance                    shift and go to state 12
    empty                          shift and go to state 14

state 7

    (13) functions -> function . functions
    (13) functions -> . function functions
    (14) functions -> . empty
    (15) function -> . # ID neg_lookup : return_type params scope_function func_block
    (99) empty -> .

    #               shift and go to state 9
    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    FOR             reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)
    }               reduce using rule 99 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 15
    empty                          shift and go to state 10

state 8

    (1) program -> classes functions . statements
    (21) statements -> . statement statements
    (22) statements -> . empty
    (23) statement -> . declaration
    (24) statement -> . print_stmt
    (25) statement -> . if_block
    (26) statement -> . while_block
    (27) statement -> . for_block
    (28) statement -> . expr
    (99) empty -> .
    (29) declaration -> . $ attr
    (38) print_stmt -> . PRINT ( exp ) ;
    (94) if_block -> . IF ( exp exp_evaluation ) block
    (95) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (96) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (97) for_block -> . FOR number FOR_TO number SKIP number block
    (39) expr -> . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    $end            reduce using rule 99 (empty -> .)
    $               shift and go to state 29
    PRINT           shift and go to state 25
    IF              shift and go to state 45
    WHILE           shift and go to state 22
    FOR             shift and go to state 40
    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    for_block                      shift and go to state 17
    statements                     shift and go to state 19
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    math_exp                       shift and go to state 28
    prop                           shift and go to state 27
    read                           shift and go to state 31
    call                           shift and go to state 32
    statement                      shift and go to state 33
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    empty                          shift and go to state 37
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    print_stmt                     shift and go to state 41
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 43
    term                           shift and go to state 46
    expr                           shift and go to state 47
    if_block                       shift and go to state 48
    while_block                    shift and go to state 50
    exp                            shift and go to state 51
    assign                         shift and go to state 53

state 9

    (15) function -> # . ID neg_lookup : return_type params scope_function func_block

    ID              shift and go to state 54


state 10

    (14) functions -> empty .

    $               reduce using rule 14 (functions -> empty .)
    PRINT           reduce using rule 14 (functions -> empty .)
    IF              reduce using rule 14 (functions -> empty .)
    WHILE           reduce using rule 14 (functions -> empty .)
    FOR             reduce using rule 14 (functions -> empty .)
    READ            reduce using rule 14 (functions -> empty .)
    STRING          reduce using rule 14 (functions -> empty .)
    NEW             reduce using rule 14 (functions -> empty .)
    ID              reduce using rule 14 (functions -> empty .)
    THIS            reduce using rule 14 (functions -> empty .)
    (               reduce using rule 14 (functions -> empty .)
    FLOAT           reduce using rule 14 (functions -> empty .)
    INT             reduce using rule 14 (functions -> empty .)
    $end            reduce using rule 14 (functions -> empty .)
    }               reduce using rule 14 (functions -> empty .)


state 11

    (2) classes -> class classes .

    #               reduce using rule 2 (classes -> class classes .)
    $               reduce using rule 2 (classes -> class classes .)
    PRINT           reduce using rule 2 (classes -> class classes .)
    IF              reduce using rule 2 (classes -> class classes .)
    WHILE           reduce using rule 2 (classes -> class classes .)
    FOR             reduce using rule 2 (classes -> class classes .)
    READ            reduce using rule 2 (classes -> class classes .)
    STRING          reduce using rule 2 (classes -> class classes .)
    NEW             reduce using rule 2 (classes -> class classes .)
    ID              reduce using rule 2 (classes -> class classes .)
    THIS            reduce using rule 2 (classes -> class classes .)
    (               reduce using rule 2 (classes -> class classes .)
    FLOAT           reduce using rule 2 (classes -> class classes .)
    INT             reduce using rule 2 (classes -> class classes .)
    $end            reduce using rule 2 (classes -> class classes .)


state 12

    (4) class -> @ ID inheritance . params scope_class store_attributes class_block
    (7) params -> . ( attrs )

    (               shift and go to state 55

    params                         shift and go to state 56

state 13

    (5) inheritance -> < . ID check_class >

    ID              shift and go to state 57


state 14

    (6) inheritance -> empty .

    (               reduce using rule 6 (inheritance -> empty .)


state 15

    (13) functions -> function functions .

    $               reduce using rule 13 (functions -> function functions .)
    PRINT           reduce using rule 13 (functions -> function functions .)
    IF              reduce using rule 13 (functions -> function functions .)
    WHILE           reduce using rule 13 (functions -> function functions .)
    FOR             reduce using rule 13 (functions -> function functions .)
    READ            reduce using rule 13 (functions -> function functions .)
    STRING          reduce using rule 13 (functions -> function functions .)
    NEW             reduce using rule 13 (functions -> function functions .)
    ID              reduce using rule 13 (functions -> function functions .)
    THIS            reduce using rule 13 (functions -> function functions .)
    (               reduce using rule 13 (functions -> function functions .)
    FLOAT           reduce using rule 13 (functions -> function functions .)
    INT             reduce using rule 13 (functions -> function functions .)
    $end            reduce using rule 13 (functions -> function functions .)
    }               reduce using rule 13 (functions -> function functions .)


state 16

    (41) exp -> math_or .

    ;               reduce using rule 41 (exp -> math_or .)
    )               reduce using rule 41 (exp -> math_or .)
    ,               reduce using rule 41 (exp -> math_or .)


state 17

    (27) statement -> for_block .

    $               reduce using rule 27 (statement -> for_block .)
    PRINT           reduce using rule 27 (statement -> for_block .)
    IF              reduce using rule 27 (statement -> for_block .)
    WHILE           reduce using rule 27 (statement -> for_block .)
    FOR             reduce using rule 27 (statement -> for_block .)
    READ            reduce using rule 27 (statement -> for_block .)
    STRING          reduce using rule 27 (statement -> for_block .)
    NEW             reduce using rule 27 (statement -> for_block .)
    ID              reduce using rule 27 (statement -> for_block .)
    THIS            reduce using rule 27 (statement -> for_block .)
    (               reduce using rule 27 (statement -> for_block .)
    FLOAT           reduce using rule 27 (statement -> for_block .)
    INT             reduce using rule 27 (statement -> for_block .)
    }               reduce using rule 27 (statement -> for_block .)
    $end            reduce using rule 27 (statement -> for_block .)
    RETURN          reduce using rule 27 (statement -> for_block .)


state 18

    (87) number -> FLOAT . empty
    (99) empty -> .

    *               reduce using rule 99 (empty -> .)
    /               reduce using rule 99 (empty -> .)
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    FOR_TO          reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)
    SKIP            reduce using rule 99 (empty -> .)
    {               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 58

state 19

    (1) program -> classes functions statements .

    $end            reduce using rule 1 (program -> classes functions statements .)


state 20

    (46) read -> READ . ( )

    (               shift and go to state 59


state 21

    (81) factor -> number .

    *               reduce using rule 81 (factor -> number .)
    /               reduce using rule 81 (factor -> number .)
    +               reduce using rule 81 (factor -> number .)
    -               reduce using rule 81 (factor -> number .)
    <               reduce using rule 81 (factor -> number .)
    >               reduce using rule 81 (factor -> number .)
    EQ              reduce using rule 81 (factor -> number .)
    NE              reduce using rule 81 (factor -> number .)
    LE              reduce using rule 81 (factor -> number .)
    GE              reduce using rule 81 (factor -> number .)
    AND             reduce using rule 81 (factor -> number .)
    OR              reduce using rule 81 (factor -> number .)
    ;               reduce using rule 81 (factor -> number .)
    )               reduce using rule 81 (factor -> number .)
    ,               reduce using rule 81 (factor -> number .)


state 22

    (96) while_block -> WHILE . ( leave_breadcrumb exp exp_evaluation ) block

    (               shift and go to state 60


state 23

    (48) string -> STRING .

    ;               reduce using rule 48 (string -> STRING .)
    ,               reduce using rule 48 (string -> STRING .)
    )               reduce using rule 48 (string -> STRING .)


state 24

    (51) new -> NEW . constructor_call
    (52) constructor_call -> . ID ( args )

    ID              shift and go to state 62

    constructor_call               shift and go to state 61

state 25

    (38) print_stmt -> PRINT . ( exp ) ;

    (               shift and go to state 63


state 26

    (45) exp -> stack_call .

    ;               reduce using rule 45 (exp -> stack_call .)
    )               reduce using rule 45 (exp -> stack_call .)
    ,               reduce using rule 45 (exp -> stack_call .)


state 27

    (49) var -> prop .
    (80) factor -> prop .
    (89) call -> prop . ( args )

    =               reduce using rule 49 (var -> prop .)
    *               reduce using rule 80 (factor -> prop .)
    /               reduce using rule 80 (factor -> prop .)
    +               reduce using rule 80 (factor -> prop .)
    -               reduce using rule 80 (factor -> prop .)
    <               reduce using rule 80 (factor -> prop .)
    >               reduce using rule 80 (factor -> prop .)
    EQ              reduce using rule 80 (factor -> prop .)
    NE              reduce using rule 80 (factor -> prop .)
    LE              reduce using rule 80 (factor -> prop .)
    GE              reduce using rule 80 (factor -> prop .)
    AND             reduce using rule 80 (factor -> prop .)
    OR              reduce using rule 80 (factor -> prop .)
    ;               reduce using rule 80 (factor -> prop .)
    )               reduce using rule 80 (factor -> prop .)
    ,               reduce using rule 80 (factor -> prop .)
    (               shift and go to state 64


state 28

    (63) math_comp -> math_exp . math_comp_alt
    (64) math_comp_alt -> . comparison_op math_exp new_quad
    (65) math_comp_alt -> . empty
    (66) comparison_op -> . <
    (67) comparison_op -> . >
    (68) comparison_op -> . EQ
    (69) comparison_op -> . NE
    (70) comparison_op -> . LE
    (71) comparison_op -> . GE
    (99) empty -> .

    <               shift and go to state 71
    >               shift and go to state 73
    EQ              shift and go to state 70
    NE              shift and go to state 67
    LE              shift and go to state 66
    GE              shift and go to state 69
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_comp_alt                  shift and go to state 68
    comparison_op                  shift and go to state 65
    empty                          shift and go to state 72

state 29

    (29) declaration -> $ . attr
    (30) attr -> . ID : type
    (31) attr -> . ID : stack_type

    ID              shift and go to state 75

    attr                           shift and go to state 74

state 30

    (83) factor -> ( . math_or )
    (57) math_or -> . math_and math_or_alt
    (60) math_and -> . math_comp math_and_alt
    (63) math_comp -> . math_exp math_comp_alt
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    (               shift and go to state 30
    THIS            shift and go to state 49
    ID              shift and go to state 78
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 76
    term                           shift and go to state 46
    math_and                       shift and go to state 38
    math_comp                      shift and go to state 34
    number                         shift and go to state 21
    prop                           shift and go to state 77
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42

state 31

    (40) exp -> read .

    ;               reduce using rule 40 (exp -> read .)
    )               reduce using rule 40 (exp -> read .)
    ,               reduce using rule 40 (exp -> read .)


state 32

    (82) factor -> call .

    *               reduce using rule 82 (factor -> call .)
    /               reduce using rule 82 (factor -> call .)
    +               reduce using rule 82 (factor -> call .)
    -               reduce using rule 82 (factor -> call .)
    <               reduce using rule 82 (factor -> call .)
    >               reduce using rule 82 (factor -> call .)
    EQ              reduce using rule 82 (factor -> call .)
    NE              reduce using rule 82 (factor -> call .)
    LE              reduce using rule 82 (factor -> call .)
    GE              reduce using rule 82 (factor -> call .)
    AND             reduce using rule 82 (factor -> call .)
    OR              reduce using rule 82 (factor -> call .)
    ;               reduce using rule 82 (factor -> call .)
    )               reduce using rule 82 (factor -> call .)
    ,               reduce using rule 82 (factor -> call .)


state 33

    (21) statements -> statement . statements
    (21) statements -> . statement statements
    (22) statements -> . empty
    (23) statement -> . declaration
    (24) statement -> . print_stmt
    (25) statement -> . if_block
    (26) statement -> . while_block
    (27) statement -> . for_block
    (28) statement -> . expr
    (99) empty -> .
    (29) declaration -> . $ attr
    (38) print_stmt -> . PRINT ( exp ) ;
    (94) if_block -> . IF ( exp exp_evaluation ) block
    (95) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (96) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (97) for_block -> . FOR number FOR_TO number SKIP number block
    (39) expr -> . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    $end            reduce using rule 99 (empty -> .)
    }               reduce using rule 99 (empty -> .)
    RETURN          reduce using rule 99 (empty -> .)
    $               shift and go to state 29
    PRINT           shift and go to state 25
    IF              shift and go to state 45
    WHILE           shift and go to state 22
    FOR             shift and go to state 40
    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    for_block                      shift and go to state 17
    statements                     shift and go to state 79
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    math_exp                       shift and go to state 28
    prop                           shift and go to state 27
    read                           shift and go to state 31
    call                           shift and go to state 32
    statement                      shift and go to state 33
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    empty                          shift and go to state 37
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    print_stmt                     shift and go to state 41
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 43
    term                           shift and go to state 46
    expr                           shift and go to state 47
    if_block                       shift and go to state 48
    while_block                    shift and go to state 50
    exp                            shift and go to state 51
    assign                         shift and go to state 53

state 34

    (60) math_and -> math_comp . math_and_alt
    (61) math_and_alt -> . AND math_comp new_quad math_and_alt
    (62) math_and_alt -> . empty
    (99) empty -> .

    AND             shift and go to state 80
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_and_alt                   shift and go to state 81
    empty                          shift and go to state 82

state 35

    (47) assign -> var . = exp

    =               shift and go to state 83


state 36

    (44) exp -> new .

    ;               reduce using rule 44 (exp -> new .)
    )               reduce using rule 44 (exp -> new .)
    ,               reduce using rule 44 (exp -> new .)


state 37

    (22) statements -> empty .

    $end            reduce using rule 22 (statements -> empty .)
    }               reduce using rule 22 (statements -> empty .)
    RETURN          reduce using rule 22 (statements -> empty .)


state 38

    (57) math_or -> math_and . math_or_alt
    (58) math_or_alt -> . OR math_and new_quad math_or_alt
    (59) math_or_alt -> . empty
    (99) empty -> .

    OR              shift and go to state 86
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_or_alt                    shift and go to state 84
    empty                          shift and go to state 85

state 39

    (43) exp -> string .

    ;               reduce using rule 43 (exp -> string .)
    )               reduce using rule 43 (exp -> string .)
    ,               reduce using rule 43 (exp -> string .)


state 40

    (97) for_block -> FOR . number FOR_TO number SKIP number block
    (87) number -> . FLOAT empty
    (88) number -> . INT

    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    number                         shift and go to state 87

state 41

    (24) statement -> print_stmt .

    $               reduce using rule 24 (statement -> print_stmt .)
    PRINT           reduce using rule 24 (statement -> print_stmt .)
    IF              reduce using rule 24 (statement -> print_stmt .)
    WHILE           reduce using rule 24 (statement -> print_stmt .)
    FOR             reduce using rule 24 (statement -> print_stmt .)
    READ            reduce using rule 24 (statement -> print_stmt .)
    STRING          reduce using rule 24 (statement -> print_stmt .)
    NEW             reduce using rule 24 (statement -> print_stmt .)
    ID              reduce using rule 24 (statement -> print_stmt .)
    THIS            reduce using rule 24 (statement -> print_stmt .)
    (               reduce using rule 24 (statement -> print_stmt .)
    FLOAT           reduce using rule 24 (statement -> print_stmt .)
    INT             reduce using rule 24 (statement -> print_stmt .)
    }               reduce using rule 24 (statement -> print_stmt .)
    $end            reduce using rule 24 (statement -> print_stmt .)
    RETURN          reduce using rule 24 (statement -> print_stmt .)


state 42

    (76) term -> factor . term_alt
    (77) term_alt -> . * factor new_quad term_alt
    (78) term_alt -> . / factor new_quad term_alt
    (79) term_alt -> . empty
    (99) empty -> .

    *               shift and go to state 89
    /               shift and go to state 90
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 91
    term_alt                       shift and go to state 88

state 43

    (23) statement -> declaration .
    (50) var -> declaration .

    $               reduce using rule 23 (statement -> declaration .)
    PRINT           reduce using rule 23 (statement -> declaration .)
    IF              reduce using rule 23 (statement -> declaration .)
    WHILE           reduce using rule 23 (statement -> declaration .)
    FOR             reduce using rule 23 (statement -> declaration .)
    READ            reduce using rule 23 (statement -> declaration .)
    STRING          reduce using rule 23 (statement -> declaration .)
    NEW             reduce using rule 23 (statement -> declaration .)
    ID              reduce using rule 23 (statement -> declaration .)
    THIS            reduce using rule 23 (statement -> declaration .)
    (               reduce using rule 23 (statement -> declaration .)
    FLOAT           reduce using rule 23 (statement -> declaration .)
    INT             reduce using rule 23 (statement -> declaration .)
    }               reduce using rule 23 (statement -> declaration .)
    $end            reduce using rule 23 (statement -> declaration .)
    RETURN          reduce using rule 23 (statement -> declaration .)
    =               reduce using rule 50 (var -> declaration .)


state 44

    (53) stack_call -> ID . . stack_method
    (85) prop -> ID . . ID
    (86) prop -> ID .

    .               shift and go to state 92
    (               reduce using rule 86 (prop -> ID .)
    =               reduce using rule 86 (prop -> ID .)
    *               reduce using rule 86 (prop -> ID .)
    /               reduce using rule 86 (prop -> ID .)
    +               reduce using rule 86 (prop -> ID .)
    -               reduce using rule 86 (prop -> ID .)
    <               reduce using rule 86 (prop -> ID .)
    >               reduce using rule 86 (prop -> ID .)
    EQ              reduce using rule 86 (prop -> ID .)
    NE              reduce using rule 86 (prop -> ID .)
    LE              reduce using rule 86 (prop -> ID .)
    GE              reduce using rule 86 (prop -> ID .)
    AND             reduce using rule 86 (prop -> ID .)
    OR              reduce using rule 86 (prop -> ID .)
    ;               reduce using rule 86 (prop -> ID .)
    ,               reduce using rule 86 (prop -> ID .)
    )               reduce using rule 86 (prop -> ID .)


state 45

    (94) if_block -> IF . ( exp exp_evaluation ) block
    (95) if_block -> IF . ( exp exp_evaluation ) block after_if_block ELSE block

    (               shift and go to state 93


state 46

    (72) math_exp -> term . math_exp_alt
    (73) math_exp_alt -> . + term new_quad math_exp_alt
    (74) math_exp_alt -> . - term new_quad math_exp_alt
    (75) math_exp_alt -> . empty
    (99) empty -> .

    +               shift and go to state 96
    -               shift and go to state 95
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_exp_alt                   shift and go to state 94
    empty                          shift and go to state 97

state 47

    (28) statement -> expr .

    $               reduce using rule 28 (statement -> expr .)
    PRINT           reduce using rule 28 (statement -> expr .)
    IF              reduce using rule 28 (statement -> expr .)
    WHILE           reduce using rule 28 (statement -> expr .)
    FOR             reduce using rule 28 (statement -> expr .)
    READ            reduce using rule 28 (statement -> expr .)
    STRING          reduce using rule 28 (statement -> expr .)
    NEW             reduce using rule 28 (statement -> expr .)
    ID              reduce using rule 28 (statement -> expr .)
    THIS            reduce using rule 28 (statement -> expr .)
    (               reduce using rule 28 (statement -> expr .)
    FLOAT           reduce using rule 28 (statement -> expr .)
    INT             reduce using rule 28 (statement -> expr .)
    }               reduce using rule 28 (statement -> expr .)
    $end            reduce using rule 28 (statement -> expr .)
    RETURN          reduce using rule 28 (statement -> expr .)


state 48

    (25) statement -> if_block .

    $               reduce using rule 25 (statement -> if_block .)
    PRINT           reduce using rule 25 (statement -> if_block .)
    IF              reduce using rule 25 (statement -> if_block .)
    WHILE           reduce using rule 25 (statement -> if_block .)
    FOR             reduce using rule 25 (statement -> if_block .)
    READ            reduce using rule 25 (statement -> if_block .)
    STRING          reduce using rule 25 (statement -> if_block .)
    NEW             reduce using rule 25 (statement -> if_block .)
    ID              reduce using rule 25 (statement -> if_block .)
    THIS            reduce using rule 25 (statement -> if_block .)
    (               reduce using rule 25 (statement -> if_block .)
    FLOAT           reduce using rule 25 (statement -> if_block .)
    INT             reduce using rule 25 (statement -> if_block .)
    }               reduce using rule 25 (statement -> if_block .)
    $end            reduce using rule 25 (statement -> if_block .)
    RETURN          reduce using rule 25 (statement -> if_block .)


state 49

    (84) prop -> THIS . . ID

    .               shift and go to state 98


state 50

    (26) statement -> while_block .

    $               reduce using rule 26 (statement -> while_block .)
    PRINT           reduce using rule 26 (statement -> while_block .)
    IF              reduce using rule 26 (statement -> while_block .)
    WHILE           reduce using rule 26 (statement -> while_block .)
    FOR             reduce using rule 26 (statement -> while_block .)
    READ            reduce using rule 26 (statement -> while_block .)
    STRING          reduce using rule 26 (statement -> while_block .)
    NEW             reduce using rule 26 (statement -> while_block .)
    ID              reduce using rule 26 (statement -> while_block .)
    THIS            reduce using rule 26 (statement -> while_block .)
    (               reduce using rule 26 (statement -> while_block .)
    FLOAT           reduce using rule 26 (statement -> while_block .)
    INT             reduce using rule 26 (statement -> while_block .)
    }               reduce using rule 26 (statement -> while_block .)
    $end            reduce using rule 26 (statement -> while_block .)
    RETURN          reduce using rule 26 (statement -> while_block .)


state 51

    (39) expr -> exp . ;

    ;               shift and go to state 99


state 52

    (88) number -> INT .

    *               reduce using rule 88 (number -> INT .)
    /               reduce using rule 88 (number -> INT .)
    +               reduce using rule 88 (number -> INT .)
    -               reduce using rule 88 (number -> INT .)
    <               reduce using rule 88 (number -> INT .)
    >               reduce using rule 88 (number -> INT .)
    EQ              reduce using rule 88 (number -> INT .)
    NE              reduce using rule 88 (number -> INT .)
    LE              reduce using rule 88 (number -> INT .)
    GE              reduce using rule 88 (number -> INT .)
    AND             reduce using rule 88 (number -> INT .)
    OR              reduce using rule 88 (number -> INT .)
    ;               reduce using rule 88 (number -> INT .)
    )               reduce using rule 88 (number -> INT .)
    ,               reduce using rule 88 (number -> INT .)
    SKIP            reduce using rule 88 (number -> INT .)
    FOR_TO          reduce using rule 88 (number -> INT .)
    {               reduce using rule 88 (number -> INT .)


state 53

    (42) exp -> assign .

    ;               reduce using rule 42 (exp -> assign .)
    )               reduce using rule 42 (exp -> assign .)
    ,               reduce using rule 42 (exp -> assign .)


state 54

    (15) function -> # ID . neg_lookup : return_type params scope_function func_block
    (104) neg_lookup -> . empty
    (99) empty -> .

    :               reduce using rule 99 (empty -> .)

    neg_lookup                     shift and go to state 100
    empty                          shift and go to state 101

state 55

    (7) params -> ( . attrs )
    (8) attrs -> . attr attrs_alt
    (9) attrs -> . empty
    (30) attr -> . ID : type
    (31) attr -> . ID : stack_type
    (99) empty -> .

    ID              shift and go to state 75
    )               reduce using rule 99 (empty -> .)

    attrs                          shift and go to state 102
    attr                           shift and go to state 104
    empty                          shift and go to state 103

state 56

    (4) class -> @ ID inheritance params . scope_class store_attributes class_block
    (101) scope_class -> . empty
    (99) empty -> .

    {               reduce using rule 99 (empty -> .)

    scope_class                    shift and go to state 105
    empty                          shift and go to state 106

state 57

    (5) inheritance -> < ID . check_class >
    (103) check_class -> . empty
    (99) empty -> .

    >               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 107
    check_class                    shift and go to state 108

state 58

    (87) number -> FLOAT empty .

    *               reduce using rule 87 (number -> FLOAT empty .)
    /               reduce using rule 87 (number -> FLOAT empty .)
    +               reduce using rule 87 (number -> FLOAT empty .)
    -               reduce using rule 87 (number -> FLOAT empty .)
    <               reduce using rule 87 (number -> FLOAT empty .)
    >               reduce using rule 87 (number -> FLOAT empty .)
    EQ              reduce using rule 87 (number -> FLOAT empty .)
    NE              reduce using rule 87 (number -> FLOAT empty .)
    LE              reduce using rule 87 (number -> FLOAT empty .)
    GE              reduce using rule 87 (number -> FLOAT empty .)
    AND             reduce using rule 87 (number -> FLOAT empty .)
    OR              reduce using rule 87 (number -> FLOAT empty .)
    ;               reduce using rule 87 (number -> FLOAT empty .)
    )               reduce using rule 87 (number -> FLOAT empty .)
    ,               reduce using rule 87 (number -> FLOAT empty .)
    SKIP            reduce using rule 87 (number -> FLOAT empty .)
    FOR_TO          reduce using rule 87 (number -> FLOAT empty .)
    {               reduce using rule 87 (number -> FLOAT empty .)


state 59

    (46) read -> READ ( . )

    )               shift and go to state 109


state 60

    (96) while_block -> WHILE ( . leave_breadcrumb exp exp_evaluation ) block
    (108) leave_breadcrumb -> . empty
    (99) empty -> .

    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    $               reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)

    empty                          shift and go to state 111
    leave_breadcrumb               shift and go to state 110

state 61

    (51) new -> NEW constructor_call .

    ;               reduce using rule 51 (new -> NEW constructor_call .)
    )               reduce using rule 51 (new -> NEW constructor_call .)
    ,               reduce using rule 51 (new -> NEW constructor_call .)


state 62

    (52) constructor_call -> ID . ( args )

    (               shift and go to state 112


state 63

    (38) print_stmt -> PRINT ( . exp ) ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (29) declaration -> . $ attr
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    $               shift and go to state 29
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    prop                           shift and go to state 27
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    read                           shift and go to state 31
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 113
    term                           shift and go to state 46
    exp                            shift and go to state 114
    assign                         shift and go to state 53

state 64

    (89) call -> prop ( . args )
    (90) args -> . exp args_aux
    (91) args -> . empty
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (99) empty -> .
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (29) declaration -> . $ attr
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    )               reduce using rule 99 (empty -> .)
    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    $               shift and go to state 29
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    prop                           shift and go to state 27
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    empty                          shift and go to state 115
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    read                           shift and go to state 31
    math_comp                      shift and go to state 34
    args                           shift and go to state 116
    declaration                    shift and go to state 113
    term                           shift and go to state 46
    exp                            shift and go to state 117
    assign                         shift and go to state 53

state 65

    (64) math_comp_alt -> comparison_op . math_exp new_quad
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    (               shift and go to state 30
    THIS            shift and go to state 49
    ID              shift and go to state 78
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    term                           shift and go to state 46
    prop                           shift and go to state 77
    call                           shift and go to state 32
    math_exp                       shift and go to state 118
    factor                         shift and go to state 42
    number                         shift and go to state 21

state 66

    (70) comparison_op -> LE .

    (               reduce using rule 70 (comparison_op -> LE .)
    THIS            reduce using rule 70 (comparison_op -> LE .)
    ID              reduce using rule 70 (comparison_op -> LE .)
    FLOAT           reduce using rule 70 (comparison_op -> LE .)
    INT             reduce using rule 70 (comparison_op -> LE .)


state 67

    (69) comparison_op -> NE .

    (               reduce using rule 69 (comparison_op -> NE .)
    THIS            reduce using rule 69 (comparison_op -> NE .)
    ID              reduce using rule 69 (comparison_op -> NE .)
    FLOAT           reduce using rule 69 (comparison_op -> NE .)
    INT             reduce using rule 69 (comparison_op -> NE .)


state 68

    (63) math_comp -> math_exp math_comp_alt .

    AND             reduce using rule 63 (math_comp -> math_exp math_comp_alt .)
    OR              reduce using rule 63 (math_comp -> math_exp math_comp_alt .)
    ;               reduce using rule 63 (math_comp -> math_exp math_comp_alt .)
    )               reduce using rule 63 (math_comp -> math_exp math_comp_alt .)
    ,               reduce using rule 63 (math_comp -> math_exp math_comp_alt .)


state 69

    (71) comparison_op -> GE .

    (               reduce using rule 71 (comparison_op -> GE .)
    THIS            reduce using rule 71 (comparison_op -> GE .)
    ID              reduce using rule 71 (comparison_op -> GE .)
    FLOAT           reduce using rule 71 (comparison_op -> GE .)
    INT             reduce using rule 71 (comparison_op -> GE .)


state 70

    (68) comparison_op -> EQ .

    (               reduce using rule 68 (comparison_op -> EQ .)
    THIS            reduce using rule 68 (comparison_op -> EQ .)
    ID              reduce using rule 68 (comparison_op -> EQ .)
    FLOAT           reduce using rule 68 (comparison_op -> EQ .)
    INT             reduce using rule 68 (comparison_op -> EQ .)


state 71

    (66) comparison_op -> < .

    (               reduce using rule 66 (comparison_op -> < .)
    THIS            reduce using rule 66 (comparison_op -> < .)
    ID              reduce using rule 66 (comparison_op -> < .)
    FLOAT           reduce using rule 66 (comparison_op -> < .)
    INT             reduce using rule 66 (comparison_op -> < .)


state 72

    (65) math_comp_alt -> empty .

    AND             reduce using rule 65 (math_comp_alt -> empty .)
    OR              reduce using rule 65 (math_comp_alt -> empty .)
    ;               reduce using rule 65 (math_comp_alt -> empty .)
    )               reduce using rule 65 (math_comp_alt -> empty .)
    ,               reduce using rule 65 (math_comp_alt -> empty .)


state 73

    (67) comparison_op -> > .

    (               reduce using rule 67 (comparison_op -> > .)
    THIS            reduce using rule 67 (comparison_op -> > .)
    ID              reduce using rule 67 (comparison_op -> > .)
    FLOAT           reduce using rule 67 (comparison_op -> > .)
    INT             reduce using rule 67 (comparison_op -> > .)


state 74

    (29) declaration -> $ attr .

    =               reduce using rule 29 (declaration -> $ attr .)
    $               reduce using rule 29 (declaration -> $ attr .)
    PRINT           reduce using rule 29 (declaration -> $ attr .)
    IF              reduce using rule 29 (declaration -> $ attr .)
    WHILE           reduce using rule 29 (declaration -> $ attr .)
    FOR             reduce using rule 29 (declaration -> $ attr .)
    READ            reduce using rule 29 (declaration -> $ attr .)
    STRING          reduce using rule 29 (declaration -> $ attr .)
    NEW             reduce using rule 29 (declaration -> $ attr .)
    ID              reduce using rule 29 (declaration -> $ attr .)
    THIS            reduce using rule 29 (declaration -> $ attr .)
    (               reduce using rule 29 (declaration -> $ attr .)
    FLOAT           reduce using rule 29 (declaration -> $ attr .)
    INT             reduce using rule 29 (declaration -> $ attr .)
    RETURN          reduce using rule 29 (declaration -> $ attr .)
    }               reduce using rule 29 (declaration -> $ attr .)
    $end            reduce using rule 29 (declaration -> $ attr .)


state 75

    (30) attr -> ID . : type
    (31) attr -> ID . : stack_type

    :               shift and go to state 119


state 76

    (83) factor -> ( math_or . )

    )               shift and go to state 120


state 77

    (80) factor -> prop .
    (89) call -> prop . ( args )

    *               reduce using rule 80 (factor -> prop .)
    /               reduce using rule 80 (factor -> prop .)
    +               reduce using rule 80 (factor -> prop .)
    -               reduce using rule 80 (factor -> prop .)
    <               reduce using rule 80 (factor -> prop .)
    >               reduce using rule 80 (factor -> prop .)
    EQ              reduce using rule 80 (factor -> prop .)
    NE              reduce using rule 80 (factor -> prop .)
    LE              reduce using rule 80 (factor -> prop .)
    GE              reduce using rule 80 (factor -> prop .)
    AND             reduce using rule 80 (factor -> prop .)
    OR              reduce using rule 80 (factor -> prop .)
    ;               reduce using rule 80 (factor -> prop .)
    )               reduce using rule 80 (factor -> prop .)
    ,               reduce using rule 80 (factor -> prop .)
    (               shift and go to state 64


state 78

    (85) prop -> ID . . ID
    (86) prop -> ID .

    .               shift and go to state 121
    (               reduce using rule 86 (prop -> ID .)
    *               reduce using rule 86 (prop -> ID .)
    /               reduce using rule 86 (prop -> ID .)
    +               reduce using rule 86 (prop -> ID .)
    -               reduce using rule 86 (prop -> ID .)
    <               reduce using rule 86 (prop -> ID .)
    >               reduce using rule 86 (prop -> ID .)
    EQ              reduce using rule 86 (prop -> ID .)
    NE              reduce using rule 86 (prop -> ID .)
    LE              reduce using rule 86 (prop -> ID .)
    GE              reduce using rule 86 (prop -> ID .)
    AND             reduce using rule 86 (prop -> ID .)
    OR              reduce using rule 86 (prop -> ID .)
    )               reduce using rule 86 (prop -> ID .)
    ;               reduce using rule 86 (prop -> ID .)
    ,               reduce using rule 86 (prop -> ID .)


state 79

    (21) statements -> statement statements .

    $end            reduce using rule 21 (statements -> statement statements .)
    }               reduce using rule 21 (statements -> statement statements .)
    RETURN          reduce using rule 21 (statements -> statement statements .)


state 80

    (61) math_and_alt -> AND . math_comp new_quad math_and_alt
    (63) math_comp -> . math_exp math_comp_alt
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    (               shift and go to state 30
    THIS            shift and go to state 49
    ID              shift and go to state 78
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    term                           shift and go to state 46
    math_comp                      shift and go to state 122
    number                         shift and go to state 21
    prop                           shift and go to state 77
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42

state 81

    (60) math_and -> math_comp math_and_alt .

    OR              reduce using rule 60 (math_and -> math_comp math_and_alt .)
    ,               reduce using rule 60 (math_and -> math_comp math_and_alt .)
    )               reduce using rule 60 (math_and -> math_comp math_and_alt .)
    ;               reduce using rule 60 (math_and -> math_comp math_and_alt .)


state 82

    (62) math_and_alt -> empty .

    OR              reduce using rule 62 (math_and_alt -> empty .)
    ;               reduce using rule 62 (math_and_alt -> empty .)
    )               reduce using rule 62 (math_and_alt -> empty .)
    ,               reduce using rule 62 (math_and_alt -> empty .)


state 83

    (47) assign -> var = . exp
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (29) declaration -> . $ attr
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    $               shift and go to state 29
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    prop                           shift and go to state 27
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    read                           shift and go to state 31
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 113
    term                           shift and go to state 46
    exp                            shift and go to state 123
    assign                         shift and go to state 53

state 84

    (57) math_or -> math_and math_or_alt .

    ;               reduce using rule 57 (math_or -> math_and math_or_alt .)
    ,               reduce using rule 57 (math_or -> math_and math_or_alt .)
    )               reduce using rule 57 (math_or -> math_and math_or_alt .)


state 85

    (59) math_or_alt -> empty .

    ;               reduce using rule 59 (math_or_alt -> empty .)
    )               reduce using rule 59 (math_or_alt -> empty .)
    ,               reduce using rule 59 (math_or_alt -> empty .)


state 86

    (58) math_or_alt -> OR . math_and new_quad math_or_alt
    (60) math_and -> . math_comp math_and_alt
    (63) math_comp -> . math_exp math_comp_alt
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    (               shift and go to state 30
    THIS            shift and go to state 49
    ID              shift and go to state 78
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    term                           shift and go to state 46
    math_comp                      shift and go to state 34
    number                         shift and go to state 21
    prop                           shift and go to state 77
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42
    math_and                       shift and go to state 124

state 87

    (97) for_block -> FOR number . FOR_TO number SKIP number block

    FOR_TO          shift and go to state 125


state 88

    (76) term -> factor term_alt .

    +               reduce using rule 76 (term -> factor term_alt .)
    -               reduce using rule 76 (term -> factor term_alt .)
    <               reduce using rule 76 (term -> factor term_alt .)
    >               reduce using rule 76 (term -> factor term_alt .)
    EQ              reduce using rule 76 (term -> factor term_alt .)
    NE              reduce using rule 76 (term -> factor term_alt .)
    LE              reduce using rule 76 (term -> factor term_alt .)
    GE              reduce using rule 76 (term -> factor term_alt .)
    AND             reduce using rule 76 (term -> factor term_alt .)
    OR              reduce using rule 76 (term -> factor term_alt .)
    )               reduce using rule 76 (term -> factor term_alt .)
    ;               reduce using rule 76 (term -> factor term_alt .)
    ,               reduce using rule 76 (term -> factor term_alt .)


state 89

    (77) term_alt -> * . factor new_quad term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    (               shift and go to state 30
    THIS            shift and go to state 49
    ID              shift and go to state 78
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    number                         shift and go to state 21
    prop                           shift and go to state 77
    call                           shift and go to state 32
    factor                         shift and go to state 126

state 90

    (78) term_alt -> / . factor new_quad term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    (               shift and go to state 30
    THIS            shift and go to state 49
    ID              shift and go to state 78
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    number                         shift and go to state 21
    prop                           shift and go to state 77
    call                           shift and go to state 32
    factor                         shift and go to state 127

state 91

    (79) term_alt -> empty .

    +               reduce using rule 79 (term_alt -> empty .)
    -               reduce using rule 79 (term_alt -> empty .)
    <               reduce using rule 79 (term_alt -> empty .)
    >               reduce using rule 79 (term_alt -> empty .)
    EQ              reduce using rule 79 (term_alt -> empty .)
    NE              reduce using rule 79 (term_alt -> empty .)
    LE              reduce using rule 79 (term_alt -> empty .)
    GE              reduce using rule 79 (term_alt -> empty .)
    AND             reduce using rule 79 (term_alt -> empty .)
    OR              reduce using rule 79 (term_alt -> empty .)
    ;               reduce using rule 79 (term_alt -> empty .)
    )               reduce using rule 79 (term_alt -> empty .)
    ,               reduce using rule 79 (term_alt -> empty .)


state 92

    (53) stack_call -> ID . . stack_method
    (85) prop -> ID . . ID
    (54) stack_method -> . POP ( )
    (55) stack_method -> . PUSH ( prop )
    (56) stack_method -> . PEEK ( )

    ID              shift and go to state 132
    POP             shift and go to state 130
    PUSH            shift and go to state 131
    PEEK            shift and go to state 128

    stack_method                   shift and go to state 129

state 93

    (94) if_block -> IF ( . exp exp_evaluation ) block
    (95) if_block -> IF ( . exp exp_evaluation ) block after_if_block ELSE block
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (29) declaration -> . $ attr
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    $               shift and go to state 29
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    prop                           shift and go to state 27
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    read                           shift and go to state 31
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 113
    term                           shift and go to state 46
    exp                            shift and go to state 133
    assign                         shift and go to state 53

state 94

    (72) math_exp -> term math_exp_alt .

    <               reduce using rule 72 (math_exp -> term math_exp_alt .)
    >               reduce using rule 72 (math_exp -> term math_exp_alt .)
    EQ              reduce using rule 72 (math_exp -> term math_exp_alt .)
    NE              reduce using rule 72 (math_exp -> term math_exp_alt .)
    LE              reduce using rule 72 (math_exp -> term math_exp_alt .)
    GE              reduce using rule 72 (math_exp -> term math_exp_alt .)
    AND             reduce using rule 72 (math_exp -> term math_exp_alt .)
    OR              reduce using rule 72 (math_exp -> term math_exp_alt .)
    ;               reduce using rule 72 (math_exp -> term math_exp_alt .)
    )               reduce using rule 72 (math_exp -> term math_exp_alt .)
    ,               reduce using rule 72 (math_exp -> term math_exp_alt .)


state 95

    (74) math_exp_alt -> - . term new_quad math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    (               shift and go to state 30
    THIS            shift and go to state 49
    ID              shift and go to state 78
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    term                           shift and go to state 134
    number                         shift and go to state 21
    prop                           shift and go to state 77
    call                           shift and go to state 32
    factor                         shift and go to state 42

state 96

    (73) math_exp_alt -> + . term new_quad math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    (               shift and go to state 30
    THIS            shift and go to state 49
    ID              shift and go to state 78
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    term                           shift and go to state 135
    number                         shift and go to state 21
    prop                           shift and go to state 77
    call                           shift and go to state 32
    factor                         shift and go to state 42

state 97

    (75) math_exp_alt -> empty .

    <               reduce using rule 75 (math_exp_alt -> empty .)
    >               reduce using rule 75 (math_exp_alt -> empty .)
    EQ              reduce using rule 75 (math_exp_alt -> empty .)
    NE              reduce using rule 75 (math_exp_alt -> empty .)
    LE              reduce using rule 75 (math_exp_alt -> empty .)
    GE              reduce using rule 75 (math_exp_alt -> empty .)
    AND             reduce using rule 75 (math_exp_alt -> empty .)
    OR              reduce using rule 75 (math_exp_alt -> empty .)
    ;               reduce using rule 75 (math_exp_alt -> empty .)
    )               reduce using rule 75 (math_exp_alt -> empty .)
    ,               reduce using rule 75 (math_exp_alt -> empty .)


state 98

    (84) prop -> THIS . . ID

    ID              shift and go to state 136


state 99

    (39) expr -> exp ; .

    $               reduce using rule 39 (expr -> exp ; .)
    PRINT           reduce using rule 39 (expr -> exp ; .)
    IF              reduce using rule 39 (expr -> exp ; .)
    WHILE           reduce using rule 39 (expr -> exp ; .)
    FOR             reduce using rule 39 (expr -> exp ; .)
    READ            reduce using rule 39 (expr -> exp ; .)
    STRING          reduce using rule 39 (expr -> exp ; .)
    NEW             reduce using rule 39 (expr -> exp ; .)
    ID              reduce using rule 39 (expr -> exp ; .)
    THIS            reduce using rule 39 (expr -> exp ; .)
    (               reduce using rule 39 (expr -> exp ; .)
    FLOAT           reduce using rule 39 (expr -> exp ; .)
    INT             reduce using rule 39 (expr -> exp ; .)
    $end            reduce using rule 39 (expr -> exp ; .)
    }               reduce using rule 39 (expr -> exp ; .)
    RETURN          reduce using rule 39 (expr -> exp ; .)


state 100

    (15) function -> # ID neg_lookup . : return_type params scope_function func_block

    :               shift and go to state 137


state 101

    (104) neg_lookup -> empty .

    :               reduce using rule 104 (neg_lookup -> empty .)


state 102

    (7) params -> ( attrs . )

    )               shift and go to state 138


state 103

    (9) attrs -> empty .

    )               reduce using rule 9 (attrs -> empty .)


state 104

    (8) attrs -> attr . attrs_alt
    (10) attrs_alt -> . , attr attrs_alt
    (11) attrs_alt -> . empty
    (99) empty -> .

    ,               shift and go to state 139
    )               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 140
    attrs_alt                      shift and go to state 141

state 105

    (4) class -> @ ID inheritance params scope_class . store_attributes class_block
    (105) store_attributes -> . empty
    (99) empty -> .

    {               reduce using rule 99 (empty -> .)

    store_attributes               shift and go to state 142
    empty                          shift and go to state 143

state 106

    (101) scope_class -> empty .

    {               reduce using rule 101 (scope_class -> empty .)


state 107

    (103) check_class -> empty .

    $               reduce using rule 103 (check_class -> empty .)
    PRINT           reduce using rule 103 (check_class -> empty .)
    IF              reduce using rule 103 (check_class -> empty .)
    WHILE           reduce using rule 103 (check_class -> empty .)
    FOR             reduce using rule 103 (check_class -> empty .)
    READ            reduce using rule 103 (check_class -> empty .)
    STRING          reduce using rule 103 (check_class -> empty .)
    NEW             reduce using rule 103 (check_class -> empty .)
    ID              reduce using rule 103 (check_class -> empty .)
    THIS            reduce using rule 103 (check_class -> empty .)
    (               reduce using rule 103 (check_class -> empty .)
    FLOAT           reduce using rule 103 (check_class -> empty .)
    INT             reduce using rule 103 (check_class -> empty .)
    $end            reduce using rule 103 (check_class -> empty .)
    =               reduce using rule 103 (check_class -> empty .)
    }               reduce using rule 103 (check_class -> empty .)
    RETURN          reduce using rule 103 (check_class -> empty .)
    ,               reduce using rule 103 (check_class -> empty .)
    )               reduce using rule 103 (check_class -> empty .)
    >               reduce using rule 103 (check_class -> empty .)


state 108

    (5) inheritance -> < ID check_class . >

    >               shift and go to state 144


state 109

    (46) read -> READ ( ) .

    ,               reduce using rule 46 (read -> READ ( ) .)
    )               reduce using rule 46 (read -> READ ( ) .)
    ;               reduce using rule 46 (read -> READ ( ) .)


state 110

    (96) while_block -> WHILE ( leave_breadcrumb . exp exp_evaluation ) block
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (29) declaration -> . $ attr
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    $               shift and go to state 29
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    prop                           shift and go to state 27
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    read                           shift and go to state 31
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 113
    term                           shift and go to state 46
    exp                            shift and go to state 145
    assign                         shift and go to state 53

state 111

    (108) leave_breadcrumb -> empty .

    READ            reduce using rule 108 (leave_breadcrumb -> empty .)
    STRING          reduce using rule 108 (leave_breadcrumb -> empty .)
    NEW             reduce using rule 108 (leave_breadcrumb -> empty .)
    ID              reduce using rule 108 (leave_breadcrumb -> empty .)
    THIS            reduce using rule 108 (leave_breadcrumb -> empty .)
    $               reduce using rule 108 (leave_breadcrumb -> empty .)
    (               reduce using rule 108 (leave_breadcrumb -> empty .)
    FLOAT           reduce using rule 108 (leave_breadcrumb -> empty .)
    INT             reduce using rule 108 (leave_breadcrumb -> empty .)


state 112

    (52) constructor_call -> ID ( . args )
    (90) args -> . exp args_aux
    (91) args -> . empty
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (99) empty -> .
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (29) declaration -> . $ attr
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    )               reduce using rule 99 (empty -> .)
    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    $               shift and go to state 29
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    prop                           shift and go to state 27
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    empty                          shift and go to state 115
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    read                           shift and go to state 31
    math_comp                      shift and go to state 34
    args                           shift and go to state 146
    declaration                    shift and go to state 113
    term                           shift and go to state 46
    exp                            shift and go to state 117
    assign                         shift and go to state 53

state 113

    (50) var -> declaration .

    =               reduce using rule 50 (var -> declaration .)


state 114

    (38) print_stmt -> PRINT ( exp . ) ;

    )               shift and go to state 147


state 115

    (91) args -> empty .

    )               reduce using rule 91 (args -> empty .)


state 116

    (89) call -> prop ( args . )

    )               shift and go to state 148


state 117

    (90) args -> exp . args_aux
    (92) args_aux -> . , exp args_aux
    (93) args_aux -> . empty
    (99) empty -> .

    ,               shift and go to state 151
    )               reduce using rule 99 (empty -> .)

    args_aux                       shift and go to state 149
    empty                          shift and go to state 150

state 118

    (64) math_comp_alt -> comparison_op math_exp . new_quad
    (100) new_quad -> . empty
    (99) empty -> .

    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 152
    empty                          shift and go to state 153

state 119

    (30) attr -> ID : . type
    (31) attr -> ID : . stack_type
    (32) type -> . INT_TYPE
    (33) type -> . FLOAT_TYPE
    (34) type -> . STRING_TYPE
    (35) type -> . BOOLEAN_TYPE
    (36) type -> . ID check_class
    (37) stack_type -> . STACK ( type )

    INT_TYPE        shift and go to state 159
    FLOAT_TYPE      shift and go to state 155
    STRING_TYPE     shift and go to state 157
    BOOLEAN_TYPE    shift and go to state 156
    ID              shift and go to state 161
    STACK           shift and go to state 158

    type                           shift and go to state 160
    stack_type                     shift and go to state 154

state 120

    (83) factor -> ( math_or ) .

    *               reduce using rule 83 (factor -> ( math_or ) .)
    /               reduce using rule 83 (factor -> ( math_or ) .)
    +               reduce using rule 83 (factor -> ( math_or ) .)
    -               reduce using rule 83 (factor -> ( math_or ) .)
    <               reduce using rule 83 (factor -> ( math_or ) .)
    >               reduce using rule 83 (factor -> ( math_or ) .)
    EQ              reduce using rule 83 (factor -> ( math_or ) .)
    NE              reduce using rule 83 (factor -> ( math_or ) .)
    LE              reduce using rule 83 (factor -> ( math_or ) .)
    GE              reduce using rule 83 (factor -> ( math_or ) .)
    AND             reduce using rule 83 (factor -> ( math_or ) .)
    OR              reduce using rule 83 (factor -> ( math_or ) .)
    ;               reduce using rule 83 (factor -> ( math_or ) .)
    )               reduce using rule 83 (factor -> ( math_or ) .)
    ,               reduce using rule 83 (factor -> ( math_or ) .)


state 121

    (85) prop -> ID . . ID

    ID              shift and go to state 132


state 122

    (61) math_and_alt -> AND math_comp . new_quad math_and_alt
    (100) new_quad -> . empty
    (99) empty -> .

    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 162
    empty                          shift and go to state 153

state 123

    (47) assign -> var = exp .

    ;               reduce using rule 47 (assign -> var = exp .)
    )               reduce using rule 47 (assign -> var = exp .)
    ,               reduce using rule 47 (assign -> var = exp .)


state 124

    (58) math_or_alt -> OR math_and . new_quad math_or_alt
    (100) new_quad -> . empty
    (99) empty -> .

    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 163
    empty                          shift and go to state 153

state 125

    (97) for_block -> FOR number FOR_TO . number SKIP number block
    (87) number -> . FLOAT empty
    (88) number -> . INT

    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    number                         shift and go to state 164

state 126

    (77) term_alt -> * factor . new_quad term_alt
    (100) new_quad -> . empty
    (99) empty -> .

    *               reduce using rule 99 (empty -> .)
    /               reduce using rule 99 (empty -> .)
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 165
    empty                          shift and go to state 153

state 127

    (78) term_alt -> / factor . new_quad term_alt
    (100) new_quad -> . empty
    (99) empty -> .

    *               reduce using rule 99 (empty -> .)
    /               reduce using rule 99 (empty -> .)
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 166
    empty                          shift and go to state 153

state 128

    (56) stack_method -> PEEK . ( )

    (               shift and go to state 167


state 129

    (53) stack_call -> ID . stack_method .

    ,               reduce using rule 53 (stack_call -> ID . stack_method .)
    )               reduce using rule 53 (stack_call -> ID . stack_method .)
    ;               reduce using rule 53 (stack_call -> ID . stack_method .)


state 130

    (54) stack_method -> POP . ( )

    (               shift and go to state 168


state 131

    (55) stack_method -> PUSH . ( prop )

    (               shift and go to state 169


state 132

    (85) prop -> ID . ID .

    (               reduce using rule 85 (prop -> ID . ID .)
    *               reduce using rule 85 (prop -> ID . ID .)
    /               reduce using rule 85 (prop -> ID . ID .)
    +               reduce using rule 85 (prop -> ID . ID .)
    -               reduce using rule 85 (prop -> ID . ID .)
    <               reduce using rule 85 (prop -> ID . ID .)
    >               reduce using rule 85 (prop -> ID . ID .)
    EQ              reduce using rule 85 (prop -> ID . ID .)
    NE              reduce using rule 85 (prop -> ID . ID .)
    LE              reduce using rule 85 (prop -> ID . ID .)
    GE              reduce using rule 85 (prop -> ID . ID .)
    AND             reduce using rule 85 (prop -> ID . ID .)
    OR              reduce using rule 85 (prop -> ID . ID .)
    )               reduce using rule 85 (prop -> ID . ID .)
    =               reduce using rule 85 (prop -> ID . ID .)
    ;               reduce using rule 85 (prop -> ID . ID .)
    ,               reduce using rule 85 (prop -> ID . ID .)


state 133

    (94) if_block -> IF ( exp . exp_evaluation ) block
    (95) if_block -> IF ( exp . exp_evaluation ) block after_if_block ELSE block
    (106) exp_evaluation -> . empty
    (99) empty -> .

    )               reduce using rule 99 (empty -> .)

    exp_evaluation                 shift and go to state 171
    empty                          shift and go to state 170

state 134

    (74) math_exp_alt -> - term . new_quad math_exp_alt
    (100) new_quad -> . empty
    (99) empty -> .

    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 172
    empty                          shift and go to state 153

state 135

    (73) math_exp_alt -> + term . new_quad math_exp_alt
    (100) new_quad -> . empty
    (99) empty -> .

    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    new_quad                       shift and go to state 173
    empty                          shift and go to state 153

state 136

    (84) prop -> THIS . ID .

    (               reduce using rule 84 (prop -> THIS . ID .)
    *               reduce using rule 84 (prop -> THIS . ID .)
    /               reduce using rule 84 (prop -> THIS . ID .)
    +               reduce using rule 84 (prop -> THIS . ID .)
    -               reduce using rule 84 (prop -> THIS . ID .)
    <               reduce using rule 84 (prop -> THIS . ID .)
    >               reduce using rule 84 (prop -> THIS . ID .)
    EQ              reduce using rule 84 (prop -> THIS . ID .)
    NE              reduce using rule 84 (prop -> THIS . ID .)
    LE              reduce using rule 84 (prop -> THIS . ID .)
    GE              reduce using rule 84 (prop -> THIS . ID .)
    AND             reduce using rule 84 (prop -> THIS . ID .)
    OR              reduce using rule 84 (prop -> THIS . ID .)
    )               reduce using rule 84 (prop -> THIS . ID .)
    =               reduce using rule 84 (prop -> THIS . ID .)
    ;               reduce using rule 84 (prop -> THIS . ID .)
    ,               reduce using rule 84 (prop -> THIS . ID .)


state 137

    (15) function -> # ID neg_lookup : . return_type params scope_function func_block
    (16) return_type -> . VOID
    (17) return_type -> . type
    (32) type -> . INT_TYPE
    (33) type -> . FLOAT_TYPE
    (34) type -> . STRING_TYPE
    (35) type -> . BOOLEAN_TYPE
    (36) type -> . ID check_class

    VOID            shift and go to state 174
    INT_TYPE        shift and go to state 159
    FLOAT_TYPE      shift and go to state 155
    STRING_TYPE     shift and go to state 157
    BOOLEAN_TYPE    shift and go to state 156
    ID              shift and go to state 161

    return_type                    shift and go to state 175
    type                           shift and go to state 176

state 138

    (7) params -> ( attrs ) .

    {               reduce using rule 7 (params -> ( attrs ) .)


state 139

    (10) attrs_alt -> , . attr attrs_alt
    (30) attr -> . ID : type
    (31) attr -> . ID : stack_type

    ID              shift and go to state 75

    attr                           shift and go to state 177

state 140

    (11) attrs_alt -> empty .

    )               reduce using rule 11 (attrs_alt -> empty .)


state 141

    (8) attrs -> attr attrs_alt .

    )               reduce using rule 8 (attrs -> attr attrs_alt .)


state 142

    (4) class -> @ ID inheritance params scope_class store_attributes . class_block
    (12) class_block -> . { functions }

    {               shift and go to state 179

    class_block                    shift and go to state 178

state 143

    (105) store_attributes -> empty .

    {               reduce using rule 105 (store_attributes -> empty .)


state 144

    (5) inheritance -> < ID check_class > .

    (               reduce using rule 5 (inheritance -> < ID check_class > .)


state 145

    (96) while_block -> WHILE ( leave_breadcrumb exp . exp_evaluation ) block
    (106) exp_evaluation -> . empty
    (99) empty -> .

    )               reduce using rule 99 (empty -> .)

    exp_evaluation                 shift and go to state 180
    empty                          shift and go to state 170

state 146

    (52) constructor_call -> ID ( args . )

    )               shift and go to state 181


state 147

    (38) print_stmt -> PRINT ( exp ) . ;

    ;               shift and go to state 182


state 148

    (89) call -> prop ( args ) .

    *               reduce using rule 89 (call -> prop ( args ) .)
    /               reduce using rule 89 (call -> prop ( args ) .)
    +               reduce using rule 89 (call -> prop ( args ) .)
    -               reduce using rule 89 (call -> prop ( args ) .)
    <               reduce using rule 89 (call -> prop ( args ) .)
    >               reduce using rule 89 (call -> prop ( args ) .)
    EQ              reduce using rule 89 (call -> prop ( args ) .)
    NE              reduce using rule 89 (call -> prop ( args ) .)
    LE              reduce using rule 89 (call -> prop ( args ) .)
    GE              reduce using rule 89 (call -> prop ( args ) .)
    AND             reduce using rule 89 (call -> prop ( args ) .)
    OR              reduce using rule 89 (call -> prop ( args ) .)
    ;               reduce using rule 89 (call -> prop ( args ) .)
    )               reduce using rule 89 (call -> prop ( args ) .)
    ,               reduce using rule 89 (call -> prop ( args ) .)


state 149

    (90) args -> exp args_aux .

    )               reduce using rule 90 (args -> exp args_aux .)


state 150

    (93) args_aux -> empty .

    )               reduce using rule 93 (args_aux -> empty .)


state 151

    (92) args_aux -> , . exp args_aux
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (29) declaration -> . $ attr
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    $               shift and go to state 29
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    prop                           shift and go to state 27
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    read                           shift and go to state 31
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 113
    term                           shift and go to state 46
    exp                            shift and go to state 183
    assign                         shift and go to state 53

state 152

    (64) math_comp_alt -> comparison_op math_exp new_quad .

    AND             reduce using rule 64 (math_comp_alt -> comparison_op math_exp new_quad .)
    OR              reduce using rule 64 (math_comp_alt -> comparison_op math_exp new_quad .)
    ;               reduce using rule 64 (math_comp_alt -> comparison_op math_exp new_quad .)
    )               reduce using rule 64 (math_comp_alt -> comparison_op math_exp new_quad .)
    ,               reduce using rule 64 (math_comp_alt -> comparison_op math_exp new_quad .)


state 153

    (100) new_quad -> empty .

    +               reduce using rule 100 (new_quad -> empty .)
    -               reduce using rule 100 (new_quad -> empty .)
    <               reduce using rule 100 (new_quad -> empty .)
    >               reduce using rule 100 (new_quad -> empty .)
    EQ              reduce using rule 100 (new_quad -> empty .)
    NE              reduce using rule 100 (new_quad -> empty .)
    LE              reduce using rule 100 (new_quad -> empty .)
    GE              reduce using rule 100 (new_quad -> empty .)
    AND             reduce using rule 100 (new_quad -> empty .)
    OR              reduce using rule 100 (new_quad -> empty .)
    ;               reduce using rule 100 (new_quad -> empty .)
    )               reduce using rule 100 (new_quad -> empty .)
    ,               reduce using rule 100 (new_quad -> empty .)
    *               reduce using rule 100 (new_quad -> empty .)
    /               reduce using rule 100 (new_quad -> empty .)


state 154

    (31) attr -> ID : stack_type .

    $               reduce using rule 31 (attr -> ID : stack_type .)
    PRINT           reduce using rule 31 (attr -> ID : stack_type .)
    IF              reduce using rule 31 (attr -> ID : stack_type .)
    WHILE           reduce using rule 31 (attr -> ID : stack_type .)
    FOR             reduce using rule 31 (attr -> ID : stack_type .)
    READ            reduce using rule 31 (attr -> ID : stack_type .)
    STRING          reduce using rule 31 (attr -> ID : stack_type .)
    NEW             reduce using rule 31 (attr -> ID : stack_type .)
    ID              reduce using rule 31 (attr -> ID : stack_type .)
    THIS            reduce using rule 31 (attr -> ID : stack_type .)
    (               reduce using rule 31 (attr -> ID : stack_type .)
    FLOAT           reduce using rule 31 (attr -> ID : stack_type .)
    INT             reduce using rule 31 (attr -> ID : stack_type .)
    $end            reduce using rule 31 (attr -> ID : stack_type .)
    =               reduce using rule 31 (attr -> ID : stack_type .)
    }               reduce using rule 31 (attr -> ID : stack_type .)
    RETURN          reduce using rule 31 (attr -> ID : stack_type .)
    ,               reduce using rule 31 (attr -> ID : stack_type .)
    )               reduce using rule 31 (attr -> ID : stack_type .)


state 155

    (33) type -> FLOAT_TYPE .

    )               reduce using rule 33 (type -> FLOAT_TYPE .)
    $               reduce using rule 33 (type -> FLOAT_TYPE .)
    PRINT           reduce using rule 33 (type -> FLOAT_TYPE .)
    IF              reduce using rule 33 (type -> FLOAT_TYPE .)
    WHILE           reduce using rule 33 (type -> FLOAT_TYPE .)
    FOR             reduce using rule 33 (type -> FLOAT_TYPE .)
    READ            reduce using rule 33 (type -> FLOAT_TYPE .)
    STRING          reduce using rule 33 (type -> FLOAT_TYPE .)
    NEW             reduce using rule 33 (type -> FLOAT_TYPE .)
    ID              reduce using rule 33 (type -> FLOAT_TYPE .)
    THIS            reduce using rule 33 (type -> FLOAT_TYPE .)
    (               reduce using rule 33 (type -> FLOAT_TYPE .)
    FLOAT           reduce using rule 33 (type -> FLOAT_TYPE .)
    INT             reduce using rule 33 (type -> FLOAT_TYPE .)
    $end            reduce using rule 33 (type -> FLOAT_TYPE .)
    =               reduce using rule 33 (type -> FLOAT_TYPE .)
    }               reduce using rule 33 (type -> FLOAT_TYPE .)
    RETURN          reduce using rule 33 (type -> FLOAT_TYPE .)
    ,               reduce using rule 33 (type -> FLOAT_TYPE .)


state 156

    (35) type -> BOOLEAN_TYPE .

    )               reduce using rule 35 (type -> BOOLEAN_TYPE .)
    $               reduce using rule 35 (type -> BOOLEAN_TYPE .)
    PRINT           reduce using rule 35 (type -> BOOLEAN_TYPE .)
    IF              reduce using rule 35 (type -> BOOLEAN_TYPE .)
    WHILE           reduce using rule 35 (type -> BOOLEAN_TYPE .)
    FOR             reduce using rule 35 (type -> BOOLEAN_TYPE .)
    READ            reduce using rule 35 (type -> BOOLEAN_TYPE .)
    STRING          reduce using rule 35 (type -> BOOLEAN_TYPE .)
    NEW             reduce using rule 35 (type -> BOOLEAN_TYPE .)
    ID              reduce using rule 35 (type -> BOOLEAN_TYPE .)
    THIS            reduce using rule 35 (type -> BOOLEAN_TYPE .)
    (               reduce using rule 35 (type -> BOOLEAN_TYPE .)
    FLOAT           reduce using rule 35 (type -> BOOLEAN_TYPE .)
    INT             reduce using rule 35 (type -> BOOLEAN_TYPE .)
    $end            reduce using rule 35 (type -> BOOLEAN_TYPE .)
    =               reduce using rule 35 (type -> BOOLEAN_TYPE .)
    }               reduce using rule 35 (type -> BOOLEAN_TYPE .)
    RETURN          reduce using rule 35 (type -> BOOLEAN_TYPE .)
    ,               reduce using rule 35 (type -> BOOLEAN_TYPE .)


state 157

    (34) type -> STRING_TYPE .

    )               reduce using rule 34 (type -> STRING_TYPE .)
    $               reduce using rule 34 (type -> STRING_TYPE .)
    PRINT           reduce using rule 34 (type -> STRING_TYPE .)
    IF              reduce using rule 34 (type -> STRING_TYPE .)
    WHILE           reduce using rule 34 (type -> STRING_TYPE .)
    FOR             reduce using rule 34 (type -> STRING_TYPE .)
    READ            reduce using rule 34 (type -> STRING_TYPE .)
    STRING          reduce using rule 34 (type -> STRING_TYPE .)
    NEW             reduce using rule 34 (type -> STRING_TYPE .)
    ID              reduce using rule 34 (type -> STRING_TYPE .)
    THIS            reduce using rule 34 (type -> STRING_TYPE .)
    (               reduce using rule 34 (type -> STRING_TYPE .)
    FLOAT           reduce using rule 34 (type -> STRING_TYPE .)
    INT             reduce using rule 34 (type -> STRING_TYPE .)
    $end            reduce using rule 34 (type -> STRING_TYPE .)
    =               reduce using rule 34 (type -> STRING_TYPE .)
    }               reduce using rule 34 (type -> STRING_TYPE .)
    RETURN          reduce using rule 34 (type -> STRING_TYPE .)
    ,               reduce using rule 34 (type -> STRING_TYPE .)


state 158

    (37) stack_type -> STACK . ( type )

    (               shift and go to state 184


state 159

    (32) type -> INT_TYPE .

    )               reduce using rule 32 (type -> INT_TYPE .)
    $               reduce using rule 32 (type -> INT_TYPE .)
    PRINT           reduce using rule 32 (type -> INT_TYPE .)
    IF              reduce using rule 32 (type -> INT_TYPE .)
    WHILE           reduce using rule 32 (type -> INT_TYPE .)
    FOR             reduce using rule 32 (type -> INT_TYPE .)
    READ            reduce using rule 32 (type -> INT_TYPE .)
    STRING          reduce using rule 32 (type -> INT_TYPE .)
    NEW             reduce using rule 32 (type -> INT_TYPE .)
    ID              reduce using rule 32 (type -> INT_TYPE .)
    THIS            reduce using rule 32 (type -> INT_TYPE .)
    (               reduce using rule 32 (type -> INT_TYPE .)
    FLOAT           reduce using rule 32 (type -> INT_TYPE .)
    INT             reduce using rule 32 (type -> INT_TYPE .)
    $end            reduce using rule 32 (type -> INT_TYPE .)
    =               reduce using rule 32 (type -> INT_TYPE .)
    }               reduce using rule 32 (type -> INT_TYPE .)
    RETURN          reduce using rule 32 (type -> INT_TYPE .)
    ,               reduce using rule 32 (type -> INT_TYPE .)


state 160

    (30) attr -> ID : type .

    $               reduce using rule 30 (attr -> ID : type .)
    PRINT           reduce using rule 30 (attr -> ID : type .)
    IF              reduce using rule 30 (attr -> ID : type .)
    WHILE           reduce using rule 30 (attr -> ID : type .)
    FOR             reduce using rule 30 (attr -> ID : type .)
    READ            reduce using rule 30 (attr -> ID : type .)
    STRING          reduce using rule 30 (attr -> ID : type .)
    NEW             reduce using rule 30 (attr -> ID : type .)
    ID              reduce using rule 30 (attr -> ID : type .)
    THIS            reduce using rule 30 (attr -> ID : type .)
    (               reduce using rule 30 (attr -> ID : type .)
    FLOAT           reduce using rule 30 (attr -> ID : type .)
    INT             reduce using rule 30 (attr -> ID : type .)
    $end            reduce using rule 30 (attr -> ID : type .)
    =               reduce using rule 30 (attr -> ID : type .)
    }               reduce using rule 30 (attr -> ID : type .)
    RETURN          reduce using rule 30 (attr -> ID : type .)
    ,               reduce using rule 30 (attr -> ID : type .)
    )               reduce using rule 30 (attr -> ID : type .)


state 161

    (36) type -> ID . check_class
    (103) check_class -> . empty
    (99) empty -> .

    $               reduce using rule 99 (empty -> .)
    PRINT           reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    WHILE           reduce using rule 99 (empty -> .)
    FOR             reduce using rule 99 (empty -> .)
    READ            reduce using rule 99 (empty -> .)
    STRING          reduce using rule 99 (empty -> .)
    NEW             reduce using rule 99 (empty -> .)
    ID              reduce using rule 99 (empty -> .)
    THIS            reduce using rule 99 (empty -> .)
    (               reduce using rule 99 (empty -> .)
    FLOAT           reduce using rule 99 (empty -> .)
    INT             reduce using rule 99 (empty -> .)
    $end            reduce using rule 99 (empty -> .)
    =               reduce using rule 99 (empty -> .)
    }               reduce using rule 99 (empty -> .)
    RETURN          reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 107
    check_class                    shift and go to state 185

state 162

    (61) math_and_alt -> AND math_comp new_quad . math_and_alt
    (61) math_and_alt -> . AND math_comp new_quad math_and_alt
    (62) math_and_alt -> . empty
    (99) empty -> .

    AND             shift and go to state 80
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_and_alt                   shift and go to state 186
    empty                          shift and go to state 82

state 163

    (58) math_or_alt -> OR math_and new_quad . math_or_alt
    (58) math_or_alt -> . OR math_and new_quad math_or_alt
    (59) math_or_alt -> . empty
    (99) empty -> .

    OR              shift and go to state 86
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_or_alt                    shift and go to state 187
    empty                          shift and go to state 85

state 164

    (97) for_block -> FOR number FOR_TO number . SKIP number block

    SKIP            shift and go to state 188


state 165

    (77) term_alt -> * factor new_quad . term_alt
    (77) term_alt -> . * factor new_quad term_alt
    (78) term_alt -> . / factor new_quad term_alt
    (79) term_alt -> . empty
    (99) empty -> .

    *               shift and go to state 89
    /               shift and go to state 90
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 91
    term_alt                       shift and go to state 189

state 166

    (78) term_alt -> / factor new_quad . term_alt
    (77) term_alt -> . * factor new_quad term_alt
    (78) term_alt -> . / factor new_quad term_alt
    (79) term_alt -> . empty
    (99) empty -> .

    *               shift and go to state 89
    /               shift and go to state 90
    +               reduce using rule 99 (empty -> .)
    -               reduce using rule 99 (empty -> .)
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 91
    term_alt                       shift and go to state 190

state 167

    (56) stack_method -> PEEK ( . )

    )               shift and go to state 191


state 168

    (54) stack_method -> POP ( . )

    )               shift and go to state 192


state 169

    (55) stack_method -> PUSH ( . prop )
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID

    THIS            shift and go to state 49
    ID              shift and go to state 78

    prop                           shift and go to state 193

state 170

    (106) exp_evaluation -> empty .

    )               reduce using rule 106 (exp_evaluation -> empty .)


state 171

    (94) if_block -> IF ( exp exp_evaluation . ) block
    (95) if_block -> IF ( exp exp_evaluation . ) block after_if_block ELSE block

    )               shift and go to state 194


state 172

    (74) math_exp_alt -> - term new_quad . math_exp_alt
    (73) math_exp_alt -> . + term new_quad math_exp_alt
    (74) math_exp_alt -> . - term new_quad math_exp_alt
    (75) math_exp_alt -> . empty
    (99) empty -> .

    +               shift and go to state 96
    -               shift and go to state 95
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_exp_alt                   shift and go to state 195
    empty                          shift and go to state 97

state 173

    (73) math_exp_alt -> + term new_quad . math_exp_alt
    (73) math_exp_alt -> . + term new_quad math_exp_alt
    (74) math_exp_alt -> . - term new_quad math_exp_alt
    (75) math_exp_alt -> . empty
    (99) empty -> .

    +               shift and go to state 96
    -               shift and go to state 95
    <               reduce using rule 99 (empty -> .)
    >               reduce using rule 99 (empty -> .)
    EQ              reduce using rule 99 (empty -> .)
    NE              reduce using rule 99 (empty -> .)
    LE              reduce using rule 99 (empty -> .)
    GE              reduce using rule 99 (empty -> .)
    AND             reduce using rule 99 (empty -> .)
    OR              reduce using rule 99 (empty -> .)
    ;               reduce using rule 99 (empty -> .)
    )               reduce using rule 99 (empty -> .)
    ,               reduce using rule 99 (empty -> .)

    math_exp_alt                   shift and go to state 196
    empty                          shift and go to state 97

state 174

    (16) return_type -> VOID .

    (               reduce using rule 16 (return_type -> VOID .)


state 175

    (15) function -> # ID neg_lookup : return_type . params scope_function func_block
    (7) params -> . ( attrs )

    (               shift and go to state 55

    params                         shift and go to state 197

state 176

    (17) return_type -> type .

    (               reduce using rule 17 (return_type -> type .)


state 177

    (10) attrs_alt -> , attr . attrs_alt
    (10) attrs_alt -> . , attr attrs_alt
    (11) attrs_alt -> . empty
    (99) empty -> .

    ,               shift and go to state 139
    )               reduce using rule 99 (empty -> .)

    empty                          shift and go to state 140
    attrs_alt                      shift and go to state 198

state 178

    (4) class -> @ ID inheritance params scope_class store_attributes class_block .

    @               reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    #               reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    $               reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    PRINT           reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    IF              reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    WHILE           reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    FOR             reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    READ            reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    STRING          reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    NEW             reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    ID              reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    THIS            reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    (               reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    FLOAT           reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    INT             reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)
    $end            reduce using rule 4 (class -> @ ID inheritance params scope_class store_attributes class_block .)


state 179

    (12) class_block -> { . functions }
    (13) functions -> . function functions
    (14) functions -> . empty
    (15) function -> . # ID neg_lookup : return_type params scope_function func_block
    (99) empty -> .

    #               shift and go to state 9
    }               reduce using rule 99 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 199
    empty                          shift and go to state 10

state 180

    (96) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation . ) block

    )               shift and go to state 200


state 181

    (52) constructor_call -> ID ( args ) .

    ;               reduce using rule 52 (constructor_call -> ID ( args ) .)
    )               reduce using rule 52 (constructor_call -> ID ( args ) .)
    ,               reduce using rule 52 (constructor_call -> ID ( args ) .)


state 182

    (38) print_stmt -> PRINT ( exp ) ; .

    $               reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    PRINT           reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    IF              reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    WHILE           reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    FOR             reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    READ            reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    STRING          reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    NEW             reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    ID              reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    THIS            reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    (               reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    FLOAT           reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    INT             reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    }               reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    $end            reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)
    RETURN          reduce using rule 38 (print_stmt -> PRINT ( exp ) ; .)


state 183

    (92) args_aux -> , exp . args_aux
    (92) args_aux -> . , exp args_aux
    (93) args_aux -> . empty
    (99) empty -> .

    ,               shift and go to state 151
    )               reduce using rule 99 (empty -> .)

    args_aux                       shift and go to state 201
    empty                          shift and go to state 150

state 184

    (37) stack_type -> STACK ( . type )
    (32) type -> . INT_TYPE
    (33) type -> . FLOAT_TYPE
    (34) type -> . STRING_TYPE
    (35) type -> . BOOLEAN_TYPE
    (36) type -> . ID check_class

    INT_TYPE        shift and go to state 159
    FLOAT_TYPE      shift and go to state 155
    STRING_TYPE     shift and go to state 157
    BOOLEAN_TYPE    shift and go to state 156
    ID              shift and go to state 161

    type                           shift and go to state 202

state 185

    (36) type -> ID check_class .

    )               reduce using rule 36 (type -> ID check_class .)
    $               reduce using rule 36 (type -> ID check_class .)
    PRINT           reduce using rule 36 (type -> ID check_class .)
    IF              reduce using rule 36 (type -> ID check_class .)
    WHILE           reduce using rule 36 (type -> ID check_class .)
    FOR             reduce using rule 36 (type -> ID check_class .)
    READ            reduce using rule 36 (type -> ID check_class .)
    STRING          reduce using rule 36 (type -> ID check_class .)
    NEW             reduce using rule 36 (type -> ID check_class .)
    ID              reduce using rule 36 (type -> ID check_class .)
    THIS            reduce using rule 36 (type -> ID check_class .)
    (               reduce using rule 36 (type -> ID check_class .)
    FLOAT           reduce using rule 36 (type -> ID check_class .)
    INT             reduce using rule 36 (type -> ID check_class .)
    $end            reduce using rule 36 (type -> ID check_class .)
    =               reduce using rule 36 (type -> ID check_class .)
    }               reduce using rule 36 (type -> ID check_class .)
    RETURN          reduce using rule 36 (type -> ID check_class .)
    ,               reduce using rule 36 (type -> ID check_class .)


state 186

    (61) math_and_alt -> AND math_comp new_quad math_and_alt .

    OR              reduce using rule 61 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ;               reduce using rule 61 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    )               reduce using rule 61 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ,               reduce using rule 61 (math_and_alt -> AND math_comp new_quad math_and_alt .)


state 187

    (58) math_or_alt -> OR math_and new_quad math_or_alt .

    ;               reduce using rule 58 (math_or_alt -> OR math_and new_quad math_or_alt .)
    )               reduce using rule 58 (math_or_alt -> OR math_and new_quad math_or_alt .)
    ,               reduce using rule 58 (math_or_alt -> OR math_and new_quad math_or_alt .)


state 188

    (97) for_block -> FOR number FOR_TO number SKIP . number block
    (87) number -> . FLOAT empty
    (88) number -> . INT

    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    number                         shift and go to state 203

state 189

    (77) term_alt -> * factor new_quad term_alt .

    +               reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    -               reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    <               reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    >               reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    EQ              reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    NE              reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    LE              reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    GE              reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    AND             reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    OR              reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    ;               reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    )               reduce using rule 77 (term_alt -> * factor new_quad term_alt .)
    ,               reduce using rule 77 (term_alt -> * factor new_quad term_alt .)


state 190

    (78) term_alt -> / factor new_quad term_alt .

    +               reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    -               reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    <               reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    >               reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    EQ              reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    NE              reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    LE              reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    GE              reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    AND             reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    OR              reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    ;               reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    )               reduce using rule 78 (term_alt -> / factor new_quad term_alt .)
    ,               reduce using rule 78 (term_alt -> / factor new_quad term_alt .)


state 191

    (56) stack_method -> PEEK ( ) .

    ;               reduce using rule 56 (stack_method -> PEEK ( ) .)
    )               reduce using rule 56 (stack_method -> PEEK ( ) .)
    ,               reduce using rule 56 (stack_method -> PEEK ( ) .)


state 192

    (54) stack_method -> POP ( ) .

    ;               reduce using rule 54 (stack_method -> POP ( ) .)
    )               reduce using rule 54 (stack_method -> POP ( ) .)
    ,               reduce using rule 54 (stack_method -> POP ( ) .)


state 193

    (55) stack_method -> PUSH ( prop . )

    )               shift and go to state 204


state 194

    (94) if_block -> IF ( exp exp_evaluation ) . block
    (95) if_block -> IF ( exp exp_evaluation ) . block after_if_block ELSE block
    (98) block -> . { statements }

    {               shift and go to state 205

    block                          shift and go to state 206

state 195

    (74) math_exp_alt -> - term new_quad math_exp_alt .

    <               reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    >               reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    EQ              reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    NE              reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    LE              reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    GE              reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    AND             reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    OR              reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    ;               reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    )               reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)
    ,               reduce using rule 74 (math_exp_alt -> - term new_quad math_exp_alt .)


state 196

    (73) math_exp_alt -> + term new_quad math_exp_alt .

    <               reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    >               reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    EQ              reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    NE              reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    LE              reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    GE              reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    AND             reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    OR              reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    ;               reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    )               reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)
    ,               reduce using rule 73 (math_exp_alt -> + term new_quad math_exp_alt .)


state 197

    (15) function -> # ID neg_lookup : return_type params . scope_function func_block
    (102) scope_function -> . empty
    (99) empty -> .

    {               reduce using rule 99 (empty -> .)

    scope_function                 shift and go to state 207
    empty                          shift and go to state 208

state 198

    (10) attrs_alt -> , attr attrs_alt .

    )               reduce using rule 10 (attrs_alt -> , attr attrs_alt .)


state 199

    (12) class_block -> { functions . }

    }               shift and go to state 209


state 200

    (96) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) . block
    (98) block -> . { statements }

    {               shift and go to state 205

    block                          shift and go to state 210

state 201

    (92) args_aux -> , exp args_aux .

    )               reduce using rule 92 (args_aux -> , exp args_aux .)


state 202

    (37) stack_type -> STACK ( type . )

    )               shift and go to state 211


state 203

    (97) for_block -> FOR number FOR_TO number SKIP number . block
    (98) block -> . { statements }

    {               shift and go to state 205

    block                          shift and go to state 212

state 204

    (55) stack_method -> PUSH ( prop ) .

    ;               reduce using rule 55 (stack_method -> PUSH ( prop ) .)
    )               reduce using rule 55 (stack_method -> PUSH ( prop ) .)
    ,               reduce using rule 55 (stack_method -> PUSH ( prop ) .)


state 205

    (98) block -> { . statements }
    (21) statements -> . statement statements
    (22) statements -> . empty
    (23) statement -> . declaration
    (24) statement -> . print_stmt
    (25) statement -> . if_block
    (26) statement -> . while_block
    (27) statement -> . for_block
    (28) statement -> . expr
    (99) empty -> .
    (29) declaration -> . $ attr
    (38) print_stmt -> . PRINT ( exp ) ;
    (94) if_block -> . IF ( exp exp_evaluation ) block
    (95) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (96) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (97) for_block -> . FOR number FOR_TO number SKIP number block
    (39) expr -> . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    }               reduce using rule 99 (empty -> .)
    $               shift and go to state 29
    PRINT           shift and go to state 25
    IF              shift and go to state 45
    WHILE           shift and go to state 22
    FOR             shift and go to state 40
    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    for_block                      shift and go to state 17
    statements                     shift and go to state 213
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    math_exp                       shift and go to state 28
    prop                           shift and go to state 27
    read                           shift and go to state 31
    call                           shift and go to state 32
    statement                      shift and go to state 33
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    empty                          shift and go to state 37
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    print_stmt                     shift and go to state 41
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 43
    term                           shift and go to state 46
    expr                           shift and go to state 47
    if_block                       shift and go to state 48
    while_block                    shift and go to state 50
    exp                            shift and go to state 51
    assign                         shift and go to state 53

state 206

    (94) if_block -> IF ( exp exp_evaluation ) block .
    (95) if_block -> IF ( exp exp_evaluation ) block . after_if_block ELSE block
    (107) after_if_block -> . empty
    (99) empty -> .

    $               reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    PRINT           reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    IF              reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    WHILE           reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    FOR             reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    READ            reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    STRING          reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    NEW             reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    ID              reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    THIS            reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    (               reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    FLOAT           reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    INT             reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    $end            reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    }               reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    RETURN          reduce using rule 94 (if_block -> IF ( exp exp_evaluation ) block .)
    ELSE            reduce using rule 99 (empty -> .)

    empty                          shift and go to state 215
    after_if_block                 shift and go to state 214

state 207

    (15) function -> # ID neg_lookup : return_type params scope_function . func_block
    (18) func_block -> . { statements return }

    {               shift and go to state 217

    func_block                     shift and go to state 216

state 208

    (102) scope_function -> empty .

    {               reduce using rule 102 (scope_function -> empty .)


state 209

    (12) class_block -> { functions } .

    @               reduce using rule 12 (class_block -> { functions } .)
    #               reduce using rule 12 (class_block -> { functions } .)
    $               reduce using rule 12 (class_block -> { functions } .)
    PRINT           reduce using rule 12 (class_block -> { functions } .)
    IF              reduce using rule 12 (class_block -> { functions } .)
    WHILE           reduce using rule 12 (class_block -> { functions } .)
    FOR             reduce using rule 12 (class_block -> { functions } .)
    READ            reduce using rule 12 (class_block -> { functions } .)
    STRING          reduce using rule 12 (class_block -> { functions } .)
    NEW             reduce using rule 12 (class_block -> { functions } .)
    ID              reduce using rule 12 (class_block -> { functions } .)
    THIS            reduce using rule 12 (class_block -> { functions } .)
    (               reduce using rule 12 (class_block -> { functions } .)
    FLOAT           reduce using rule 12 (class_block -> { functions } .)
    INT             reduce using rule 12 (class_block -> { functions } .)
    $end            reduce using rule 12 (class_block -> { functions } .)


state 210

    (96) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .

    $               reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    PRINT           reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    IF              reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    WHILE           reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    FOR             reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    READ            reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    STRING          reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    NEW             reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    ID              reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    THIS            reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    (               reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    FLOAT           reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    INT             reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    $end            reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    }               reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    RETURN          reduce using rule 96 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)


state 211

    (37) stack_type -> STACK ( type ) .

    $               reduce using rule 37 (stack_type -> STACK ( type ) .)
    PRINT           reduce using rule 37 (stack_type -> STACK ( type ) .)
    IF              reduce using rule 37 (stack_type -> STACK ( type ) .)
    WHILE           reduce using rule 37 (stack_type -> STACK ( type ) .)
    FOR             reduce using rule 37 (stack_type -> STACK ( type ) .)
    READ            reduce using rule 37 (stack_type -> STACK ( type ) .)
    STRING          reduce using rule 37 (stack_type -> STACK ( type ) .)
    NEW             reduce using rule 37 (stack_type -> STACK ( type ) .)
    ID              reduce using rule 37 (stack_type -> STACK ( type ) .)
    THIS            reduce using rule 37 (stack_type -> STACK ( type ) .)
    (               reduce using rule 37 (stack_type -> STACK ( type ) .)
    FLOAT           reduce using rule 37 (stack_type -> STACK ( type ) .)
    INT             reduce using rule 37 (stack_type -> STACK ( type ) .)
    $end            reduce using rule 37 (stack_type -> STACK ( type ) .)
    =               reduce using rule 37 (stack_type -> STACK ( type ) .)
    }               reduce using rule 37 (stack_type -> STACK ( type ) .)
    RETURN          reduce using rule 37 (stack_type -> STACK ( type ) .)
    ,               reduce using rule 37 (stack_type -> STACK ( type ) .)
    )               reduce using rule 37 (stack_type -> STACK ( type ) .)


state 212

    (97) for_block -> FOR number FOR_TO number SKIP number block .

    $               reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    PRINT           reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    IF              reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    WHILE           reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    FOR             reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    READ            reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    STRING          reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    NEW             reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    ID              reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    THIS            reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    (               reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    FLOAT           reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    INT             reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    $end            reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    }               reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)
    RETURN          reduce using rule 97 (for_block -> FOR number FOR_TO number SKIP number block .)


state 213

    (98) block -> { statements . }

    }               shift and go to state 218


state 214

    (95) if_block -> IF ( exp exp_evaluation ) block after_if_block . ELSE block

    ELSE            shift and go to state 219


state 215

    (107) after_if_block -> empty .

    ELSE            reduce using rule 107 (after_if_block -> empty .)


state 216

    (15) function -> # ID neg_lookup : return_type params scope_function func_block .

    #               reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $               reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    PRINT           reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    IF              reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    WHILE           reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FOR             reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    READ            reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    STRING          reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    NEW             reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    ID              reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    THIS            reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    (               reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FLOAT           reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    INT             reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $end            reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    }               reduce using rule 15 (function -> # ID neg_lookup : return_type params scope_function func_block .)


state 217

    (18) func_block -> { . statements return }
    (21) statements -> . statement statements
    (22) statements -> . empty
    (23) statement -> . declaration
    (24) statement -> . print_stmt
    (25) statement -> . if_block
    (26) statement -> . while_block
    (27) statement -> . for_block
    (28) statement -> . expr
    (99) empty -> .
    (29) declaration -> . $ attr
    (38) print_stmt -> . PRINT ( exp ) ;
    (94) if_block -> . IF ( exp exp_evaluation ) block
    (95) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (96) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (97) for_block -> . FOR number FOR_TO number SKIP number block
    (39) expr -> . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    RETURN          reduce using rule 99 (empty -> .)
    }               reduce using rule 99 (empty -> .)
    $               shift and go to state 29
    PRINT           shift and go to state 25
    IF              shift and go to state 45
    WHILE           shift and go to state 22
    FOR             shift and go to state 40
    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    for_block                      shift and go to state 17
    statements                     shift and go to state 220
    number                         shift and go to state 21
    math_and                       shift and go to state 38
    stack_call                     shift and go to state 26
    math_exp                       shift and go to state 28
    prop                           shift and go to state 27
    read                           shift and go to state 31
    call                           shift and go to state 32
    statement                      shift and go to state 33
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    empty                          shift and go to state 37
    string                         shift and go to state 39
    print_stmt                     shift and go to state 41
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 43
    term                           shift and go to state 46
    expr                           shift and go to state 47
    if_block                       shift and go to state 48
    while_block                    shift and go to state 50
    exp                            shift and go to state 51
    assign                         shift and go to state 53

state 218

    (98) block -> { statements } .

    $               reduce using rule 98 (block -> { statements } .)
    PRINT           reduce using rule 98 (block -> { statements } .)
    IF              reduce using rule 98 (block -> { statements } .)
    WHILE           reduce using rule 98 (block -> { statements } .)
    FOR             reduce using rule 98 (block -> { statements } .)
    READ            reduce using rule 98 (block -> { statements } .)
    STRING          reduce using rule 98 (block -> { statements } .)
    NEW             reduce using rule 98 (block -> { statements } .)
    ID              reduce using rule 98 (block -> { statements } .)
    THIS            reduce using rule 98 (block -> { statements } .)
    (               reduce using rule 98 (block -> { statements } .)
    FLOAT           reduce using rule 98 (block -> { statements } .)
    INT             reduce using rule 98 (block -> { statements } .)
    $end            reduce using rule 98 (block -> { statements } .)
    }               reduce using rule 98 (block -> { statements } .)
    RETURN          reduce using rule 98 (block -> { statements } .)
    ELSE            reduce using rule 98 (block -> { statements } .)


state 219

    (95) if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE . block
    (98) block -> . { statements }

    {               shift and go to state 205

    block                          shift and go to state 221

state 220

    (18) func_block -> { statements . return }
    (19) return -> . RETURN exp ;
    (20) return -> . empty
    (99) empty -> .

    RETURN          shift and go to state 223
    }               reduce using rule 99 (empty -> .)

    return                         shift and go to state 222
    empty                          shift and go to state 224

state 221

    (95) if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .

    $               reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    PRINT           reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    IF              reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    WHILE           reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    FOR             reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    READ            reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    STRING          reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    NEW             reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    ID              reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    THIS            reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    (               reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    FLOAT           reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    INT             reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    $end            reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    }               reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    RETURN          reduce using rule 95 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)


state 222

    (18) func_block -> { statements return . }

    }               shift and go to state 225


state 223

    (19) return -> RETURN . exp ;
    (40) exp -> . read
    (41) exp -> . math_or
    (42) exp -> . assign
    (43) exp -> . string
    (44) exp -> . new
    (45) exp -> . stack_call
    (46) read -> . READ ( )
    (57) math_or -> . math_and math_or_alt
    (47) assign -> . var = exp
    (48) string -> . STRING
    (51) new -> . NEW constructor_call
    (53) stack_call -> . ID . stack_method
    (60) math_and -> . math_comp math_and_alt
    (49) var -> . prop
    (50) var -> . declaration
    (63) math_comp -> . math_exp math_comp_alt
    (84) prop -> . THIS . ID
    (85) prop -> . ID . ID
    (86) prop -> . ID
    (29) declaration -> . $ attr
    (72) math_exp -> . term math_exp_alt
    (76) term -> . factor term_alt
    (80) factor -> . prop
    (81) factor -> . number
    (82) factor -> . call
    (83) factor -> . ( math_or )
    (87) number -> . FLOAT empty
    (88) number -> . INT
    (89) call -> . prop ( args )

    READ            shift and go to state 20
    STRING          shift and go to state 23
    NEW             shift and go to state 24
    ID              shift and go to state 44
    THIS            shift and go to state 49
    $               shift and go to state 29
    (               shift and go to state 30
    FLOAT           shift and go to state 18
    INT             shift and go to state 52

    math_or                        shift and go to state 16
    number                         shift and go to state 21
    stack_call                     shift and go to state 26
    prop                           shift and go to state 27
    call                           shift and go to state 32
    math_exp                       shift and go to state 28
    factor                         shift and go to state 42
    var                            shift and go to state 35
    new                            shift and go to state 36
    math_and                       shift and go to state 38
    string                         shift and go to state 39
    read                           shift and go to state 31
    math_comp                      shift and go to state 34
    declaration                    shift and go to state 113
    term                           shift and go to state 46
    exp                            shift and go to state 226
    assign                         shift and go to state 53

state 224

    (20) return -> empty .

    }               reduce using rule 20 (return -> empty .)


state 225

    (18) func_block -> { statements return } .

    #               reduce using rule 18 (func_block -> { statements return } .)
    $               reduce using rule 18 (func_block -> { statements return } .)
    PRINT           reduce using rule 18 (func_block -> { statements return } .)
    IF              reduce using rule 18 (func_block -> { statements return } .)
    WHILE           reduce using rule 18 (func_block -> { statements return } .)
    FOR             reduce using rule 18 (func_block -> { statements return } .)
    READ            reduce using rule 18 (func_block -> { statements return } .)
    STRING          reduce using rule 18 (func_block -> { statements return } .)
    NEW             reduce using rule 18 (func_block -> { statements return } .)
    ID              reduce using rule 18 (func_block -> { statements return } .)
    THIS            reduce using rule 18 (func_block -> { statements return } .)
    (               reduce using rule 18 (func_block -> { statements return } .)
    FLOAT           reduce using rule 18 (func_block -> { statements return } .)
    INT             reduce using rule 18 (func_block -> { statements return } .)
    $end            reduce using rule 18 (func_block -> { statements return } .)
    }               reduce using rule 18 (func_block -> { statements return } .)


state 226

    (19) return -> RETURN exp . ;

    ;               shift and go to state 227


state 227

    (19) return -> RETURN exp ; .

    }               reduce using rule 19 (return -> RETURN exp ; .)

