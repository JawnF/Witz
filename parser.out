Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> classes functions statements
Rule 2     declaration -> $ attr
Rule 3     new -> NEW constructor_call
Rule 4     attr -> ID : type
Rule 5     var -> prop
Rule 6     var -> declaration
Rule 7     type -> INT_TYPE
Rule 8     type -> FLOAT_TYPE
Rule 9     type -> STRING_TYPE
Rule 10    type -> BOOLEAN_TYPE
Rule 11    type -> STACK
Rule 12    type -> ID check_class
Rule 13    return_type -> VOID
Rule 14    return_type -> type
Rule 15    classes -> class classes
Rule 16    classes -> empty
Rule 17    class -> @ ID inheritance class_attribute scope_class store_attributes class_block
Rule 18    inheritance -> < ID check_class >
Rule 19    inheritance -> empty
Rule 20    class_block -> { functions }
Rule 21    class_attribute -> ( attrs )
Rule 22    functions -> function functions
Rule 23    functions -> empty
Rule 24    function -> # ID neg_lookup : return_type params scope_function func_block
Rule 25    params -> ( attrs )
Rule 26    attrs -> attr attrs_alt
Rule 27    attrs -> empty
Rule 28    attrs_alt -> , attr attrs_alt
Rule 29    attrs_alt -> empty
Rule 30    func_block -> { statements return }
Rule 31    statements -> statement statements
Rule 32    statements -> empty
Rule 33    statement -> if_block
Rule 34    statement -> while_block
Rule 35    statement -> for_block
Rule 36    statement -> print_stmt
Rule 37    statement -> expr
Rule 38    assign -> var = exp
Rule 39    init -> <empty>
Rule 40    constructor_call -> ID ( args )
Rule 41    prop -> THIS . ID
Rule 42    prop -> ID . ID
Rule 43    prop -> ID
Rule 44    if_block -> IF ( exp exp_evaluation ) block
Rule 45    if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block
Rule 46    while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block
Rule 47    for_block -> FOR number FOR_TO number SKIP number block
Rule 48    print_stmt -> PRINT ( exp ) ;
Rule 49    return -> RETURN exp ;
Rule 50    return -> empty
Rule 51    block -> { statements }
Rule 52    number -> FLOAT empty
Rule 53    number -> INT
Rule 54    expr -> exp ;
Rule 55    exp -> read
Rule 56    exp -> math_or
Rule 57    exp -> assign
Rule 58    exp -> string
Rule 59    exp -> new
Rule 60    string -> STRING
Rule 61    read -> READ ( )
Rule 62    math_exp -> term math_exp_alt
Rule 63    math_exp_alt -> + term new_quad math_exp_alt
Rule 64    math_exp_alt -> - term new_quad math_exp_alt
Rule 65    math_exp_alt -> empty
Rule 66    term -> factor term_alt
Rule 67    term_alt -> * factor new_quad term_alt
Rule 68    term_alt -> / factor new_quad term_alt
Rule 69    term_alt -> empty
Rule 70    new_quad -> empty
Rule 71    factor -> id
Rule 72    factor -> number
Rule 73    factor -> call
Rule 74    factor -> ( math_or )
Rule 75    id -> ID
Rule 76    math_or -> math_and math_or_alt
Rule 77    math_or_alt -> OR math_and new_quad math_or_alt
Rule 78    math_or_alt -> empty
Rule 79    math_and -> math_comp math_and_alt
Rule 80    math_and_alt -> AND math_comp new_quad math_and_alt
Rule 81    math_and_alt -> empty
Rule 82    math_comp -> math_exp math_comp_alt
Rule 83    math_comp_alt -> comparison_op math_exp new_quad
Rule 84    math_comp_alt -> empty
Rule 85    comparison_op -> <
Rule 86    comparison_op -> >
Rule 87    comparison_op -> EQ
Rule 88    comparison_op -> NE
Rule 89    comparison_op -> LE
Rule 90    comparison_op -> GE
Rule 91    call -> prop ( args )
Rule 92    call -> stack_call
Rule 93    args -> exp args_aux
Rule 94    args -> empty
Rule 95    args_aux -> , exp args_aux
Rule 96    args_aux -> empty
Rule 97    stack_call -> ID . stack_method
Rule 98    stack_method -> POP ( )
Rule 99    stack_method -> PUSH ( id )
Rule 100   stack_method -> PEEK ( )
Rule 101   empty -> <empty>
Rule 102   scope_class -> empty
Rule 103   scope_function -> empty
Rule 104   scope_constructor -> empty
Rule 105   check_class -> empty
Rule 106   neg_lookup -> empty
Rule 107   store_attributes -> empty
Rule 108   exp_evaluation -> empty
Rule 109   after_if_block -> empty
Rule 110   leave_breadcrumb -> empty

Terminals, with rules where they appear

#                    : 24
$                    : 2
(                    : 21 25 40 44 45 46 48 61 74 91 98 99 100
)                    : 21 25 40 44 45 46 48 61 74 91 98 99 100
*                    : 67
+                    : 63
,                    : 28 95
-                    : 64
.                    : 41 42 97
/                    : 68
:                    : 4 24
;                    : 48 49 54
<                    : 18 85
=                    : 38
>                    : 18 86
@                    : 17
AND                  : 80
BOOLEAN_TYPE         : 10
ELSE                 : 45
EQ                   : 87
FLOAT                : 52
FLOAT_TYPE           : 8
FOR                  : 47
FOR_TO               : 47
GE                   : 90
ID                   : 4 12 17 18 24 40 41 42 42 43 75 97
IF                   : 44 45
INT                  : 53
INT_TYPE             : 7
LE                   : 89
NE                   : 88
NEW                  : 3
OR                   : 77
PEEK                 : 100
POP                  : 98
PRINT                : 48
PUSH                 : 99
READ                 : 61
RETURN               : 49
SKIP                 : 47
STACK                : 11
STRING               : 60
STRING_TYPE          : 9
THIS                 : 41
VOID                 : 13
WHILE                : 46
error                : 
{                    : 20 30 51
}                    : 20 30 51

Nonterminals, with rules where they appear

after_if_block       : 45
args                 : 40 91
args_aux             : 93 95
assign               : 57
attr                 : 2 26 28
attrs                : 21 25
attrs_alt            : 26 28
block                : 44 45 45 46 47
call                 : 73
check_class          : 12 18
class                : 15
class_attribute      : 17
class_block          : 17
classes              : 1 15
comparison_op        : 83
constructor_call     : 3
declaration          : 6
empty                : 16 19 23 27 29 32 50 52 65 69 70 78 81 84 94 96 102 103 104 105 106 107 108 109 110
exp                  : 38 44 45 46 48 49 54 93 95
exp_evaluation       : 44 45 46
expr                 : 37
factor               : 66 67 68
for_block            : 35
func_block           : 24
function             : 22
functions            : 1 20 22
id                   : 71 99
if_block             : 33
inheritance          : 17
init                 : 
leave_breadcrumb     : 46
math_and             : 76 77
math_and_alt         : 79 80
math_comp            : 79 80
math_comp_alt        : 82
math_exp             : 82 83
math_exp_alt         : 62 63 64
math_or              : 56 74
math_or_alt          : 76 77
neg_lookup           : 24
new                  : 59
new_quad             : 63 64 67 68 77 80 83
number               : 47 47 47 72
params               : 24
print_stmt           : 36
program              : 0
prop                 : 5 91
read                 : 55
return               : 30
return_type          : 24
scope_class          : 17
scope_constructor    : 
scope_function       : 24
stack_call           : 92
stack_method         : 97
statement            : 31
statements           : 1 30 31 51
store_attributes     : 17
string               : 58
term                 : 62 63 64
term_alt             : 66 67 68
type                 : 4 14
var                  : 38
while_block          : 34

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . classes functions statements
    (15) classes -> . class classes
    (16) classes -> . empty
    (17) class -> . @ ID inheritance class_attribute scope_class store_attributes class_block
    (101) empty -> .

    @               shift and go to state 5
    #               reduce using rule 101 (empty -> .)
    IF              reduce using rule 101 (empty -> .)
    WHILE           reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    PRINT           reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)
    STRING          reduce using rule 101 (empty -> .)
    NEW             reduce using rule 101 (empty -> .)
    THIS            reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    $               reduce using rule 101 (empty -> .)
    (               reduce using rule 101 (empty -> .)
    FLOAT           reduce using rule 101 (empty -> .)
    INT             reduce using rule 101 (empty -> .)
    $end            reduce using rule 101 (empty -> .)

    program                        shift and go to state 1
    classes                        shift and go to state 2
    class                          shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> classes . functions statements
    (22) functions -> . function functions
    (23) functions -> . empty
    (24) function -> . # ID neg_lookup : return_type params scope_function func_block
    (101) empty -> .

    #               shift and go to state 9
    IF              reduce using rule 101 (empty -> .)
    WHILE           reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    PRINT           reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)
    STRING          reduce using rule 101 (empty -> .)
    NEW             reduce using rule 101 (empty -> .)
    THIS            reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    $               reduce using rule 101 (empty -> .)
    (               reduce using rule 101 (empty -> .)
    FLOAT           reduce using rule 101 (empty -> .)
    INT             reduce using rule 101 (empty -> .)
    $end            reduce using rule 101 (empty -> .)

    functions                      shift and go to state 6
    function                       shift and go to state 7
    empty                          shift and go to state 8

state 3

    (15) classes -> class . classes
    (15) classes -> . class classes
    (16) classes -> . empty
    (17) class -> . @ ID inheritance class_attribute scope_class store_attributes class_block
    (101) empty -> .

    @               shift and go to state 5
    #               reduce using rule 101 (empty -> .)
    IF              reduce using rule 101 (empty -> .)
    WHILE           reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    PRINT           reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)
    STRING          reduce using rule 101 (empty -> .)
    NEW             reduce using rule 101 (empty -> .)
    THIS            reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    $               reduce using rule 101 (empty -> .)
    (               reduce using rule 101 (empty -> .)
    FLOAT           reduce using rule 101 (empty -> .)
    INT             reduce using rule 101 (empty -> .)
    $end            reduce using rule 101 (empty -> .)

    class                          shift and go to state 3
    classes                        shift and go to state 10
    empty                          shift and go to state 4

state 4

    (16) classes -> empty .

    #               reduce using rule 16 (classes -> empty .)
    IF              reduce using rule 16 (classes -> empty .)
    WHILE           reduce using rule 16 (classes -> empty .)
    FOR             reduce using rule 16 (classes -> empty .)
    PRINT           reduce using rule 16 (classes -> empty .)
    READ            reduce using rule 16 (classes -> empty .)
    STRING          reduce using rule 16 (classes -> empty .)
    NEW             reduce using rule 16 (classes -> empty .)
    THIS            reduce using rule 16 (classes -> empty .)
    ID              reduce using rule 16 (classes -> empty .)
    $               reduce using rule 16 (classes -> empty .)
    (               reduce using rule 16 (classes -> empty .)
    FLOAT           reduce using rule 16 (classes -> empty .)
    INT             reduce using rule 16 (classes -> empty .)
    $end            reduce using rule 16 (classes -> empty .)


state 5

    (17) class -> @ . ID inheritance class_attribute scope_class store_attributes class_block

    ID              shift and go to state 11


state 6

    (1) program -> classes functions . statements
    (31) statements -> . statement statements
    (32) statements -> . empty
    (33) statement -> . if_block
    (34) statement -> . while_block
    (35) statement -> . for_block
    (36) statement -> . print_stmt
    (37) statement -> . expr
    (101) empty -> .
    (44) if_block -> . IF ( exp exp_evaluation ) block
    (45) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (46) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (47) for_block -> . FOR number FOR_TO number SKIP number block
    (48) print_stmt -> . PRINT ( exp ) ;
    (54) expr -> . exp ;
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    $end            reduce using rule 101 (empty -> .)
    IF              shift and go to state 20
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    PRINT           shift and go to state 26
    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    statements                     shift and go to state 12
    statement                      shift and go to state 13
    empty                          shift and go to state 14
    if_block                       shift and go to state 15
    while_block                    shift and go to state 16
    for_block                      shift and go to state 17
    print_stmt                     shift and go to state 18
    expr                           shift and go to state 19
    exp                            shift and go to state 22
    number                         shift and go to state 25
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 7

    (22) functions -> function . functions
    (22) functions -> . function functions
    (23) functions -> . empty
    (24) function -> . # ID neg_lookup : return_type params scope_function func_block
    (101) empty -> .

    #               shift and go to state 9
    IF              reduce using rule 101 (empty -> .)
    WHILE           reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    PRINT           reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)
    STRING          reduce using rule 101 (empty -> .)
    NEW             reduce using rule 101 (empty -> .)
    THIS            reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    $               reduce using rule 101 (empty -> .)
    (               reduce using rule 101 (empty -> .)
    FLOAT           reduce using rule 101 (empty -> .)
    INT             reduce using rule 101 (empty -> .)
    $end            reduce using rule 101 (empty -> .)
    }               reduce using rule 101 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 51
    empty                          shift and go to state 8

state 8

    (23) functions -> empty .

    IF              reduce using rule 23 (functions -> empty .)
    WHILE           reduce using rule 23 (functions -> empty .)
    FOR             reduce using rule 23 (functions -> empty .)
    PRINT           reduce using rule 23 (functions -> empty .)
    READ            reduce using rule 23 (functions -> empty .)
    STRING          reduce using rule 23 (functions -> empty .)
    NEW             reduce using rule 23 (functions -> empty .)
    THIS            reduce using rule 23 (functions -> empty .)
    ID              reduce using rule 23 (functions -> empty .)
    $               reduce using rule 23 (functions -> empty .)
    (               reduce using rule 23 (functions -> empty .)
    FLOAT           reduce using rule 23 (functions -> empty .)
    INT             reduce using rule 23 (functions -> empty .)
    $end            reduce using rule 23 (functions -> empty .)
    }               reduce using rule 23 (functions -> empty .)


state 9

    (24) function -> # . ID neg_lookup : return_type params scope_function func_block

    ID              shift and go to state 52


state 10

    (15) classes -> class classes .

    #               reduce using rule 15 (classes -> class classes .)
    IF              reduce using rule 15 (classes -> class classes .)
    WHILE           reduce using rule 15 (classes -> class classes .)
    FOR             reduce using rule 15 (classes -> class classes .)
    PRINT           reduce using rule 15 (classes -> class classes .)
    READ            reduce using rule 15 (classes -> class classes .)
    STRING          reduce using rule 15 (classes -> class classes .)
    NEW             reduce using rule 15 (classes -> class classes .)
    THIS            reduce using rule 15 (classes -> class classes .)
    ID              reduce using rule 15 (classes -> class classes .)
    $               reduce using rule 15 (classes -> class classes .)
    (               reduce using rule 15 (classes -> class classes .)
    FLOAT           reduce using rule 15 (classes -> class classes .)
    INT             reduce using rule 15 (classes -> class classes .)
    $end            reduce using rule 15 (classes -> class classes .)


state 11

    (17) class -> @ ID . inheritance class_attribute scope_class store_attributes class_block
    (18) inheritance -> . < ID check_class >
    (19) inheritance -> . empty
    (101) empty -> .

    <               shift and go to state 54
    (               reduce using rule 101 (empty -> .)

    inheritance                    shift and go to state 53
    empty                          shift and go to state 55

state 12

    (1) program -> classes functions statements .

    $end            reduce using rule 1 (program -> classes functions statements .)


state 13

    (31) statements -> statement . statements
    (31) statements -> . statement statements
    (32) statements -> . empty
    (33) statement -> . if_block
    (34) statement -> . while_block
    (35) statement -> . for_block
    (36) statement -> . print_stmt
    (37) statement -> . expr
    (101) empty -> .
    (44) if_block -> . IF ( exp exp_evaluation ) block
    (45) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (46) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (47) for_block -> . FOR number FOR_TO number SKIP number block
    (48) print_stmt -> . PRINT ( exp ) ;
    (54) expr -> . exp ;
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    $end            reduce using rule 101 (empty -> .)
    }               reduce using rule 101 (empty -> .)
    RETURN          reduce using rule 101 (empty -> .)
    IF              shift and go to state 20
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    PRINT           shift and go to state 26
    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    statement                      shift and go to state 13
    statements                     shift and go to state 56
    empty                          shift and go to state 14
    if_block                       shift and go to state 15
    while_block                    shift and go to state 16
    for_block                      shift and go to state 17
    print_stmt                     shift and go to state 18
    expr                           shift and go to state 19
    exp                            shift and go to state 22
    number                         shift and go to state 25
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 14

    (32) statements -> empty .

    $end            reduce using rule 32 (statements -> empty .)
    }               reduce using rule 32 (statements -> empty .)
    RETURN          reduce using rule 32 (statements -> empty .)


state 15

    (33) statement -> if_block .

    IF              reduce using rule 33 (statement -> if_block .)
    WHILE           reduce using rule 33 (statement -> if_block .)
    FOR             reduce using rule 33 (statement -> if_block .)
    PRINT           reduce using rule 33 (statement -> if_block .)
    READ            reduce using rule 33 (statement -> if_block .)
    STRING          reduce using rule 33 (statement -> if_block .)
    NEW             reduce using rule 33 (statement -> if_block .)
    THIS            reduce using rule 33 (statement -> if_block .)
    ID              reduce using rule 33 (statement -> if_block .)
    $               reduce using rule 33 (statement -> if_block .)
    (               reduce using rule 33 (statement -> if_block .)
    FLOAT           reduce using rule 33 (statement -> if_block .)
    INT             reduce using rule 33 (statement -> if_block .)
    $end            reduce using rule 33 (statement -> if_block .)
    }               reduce using rule 33 (statement -> if_block .)
    RETURN          reduce using rule 33 (statement -> if_block .)


state 16

    (34) statement -> while_block .

    IF              reduce using rule 34 (statement -> while_block .)
    WHILE           reduce using rule 34 (statement -> while_block .)
    FOR             reduce using rule 34 (statement -> while_block .)
    PRINT           reduce using rule 34 (statement -> while_block .)
    READ            reduce using rule 34 (statement -> while_block .)
    STRING          reduce using rule 34 (statement -> while_block .)
    NEW             reduce using rule 34 (statement -> while_block .)
    THIS            reduce using rule 34 (statement -> while_block .)
    ID              reduce using rule 34 (statement -> while_block .)
    $               reduce using rule 34 (statement -> while_block .)
    (               reduce using rule 34 (statement -> while_block .)
    FLOAT           reduce using rule 34 (statement -> while_block .)
    INT             reduce using rule 34 (statement -> while_block .)
    $end            reduce using rule 34 (statement -> while_block .)
    }               reduce using rule 34 (statement -> while_block .)
    RETURN          reduce using rule 34 (statement -> while_block .)


state 17

    (35) statement -> for_block .

    IF              reduce using rule 35 (statement -> for_block .)
    WHILE           reduce using rule 35 (statement -> for_block .)
    FOR             reduce using rule 35 (statement -> for_block .)
    PRINT           reduce using rule 35 (statement -> for_block .)
    READ            reduce using rule 35 (statement -> for_block .)
    STRING          reduce using rule 35 (statement -> for_block .)
    NEW             reduce using rule 35 (statement -> for_block .)
    THIS            reduce using rule 35 (statement -> for_block .)
    ID              reduce using rule 35 (statement -> for_block .)
    $               reduce using rule 35 (statement -> for_block .)
    (               reduce using rule 35 (statement -> for_block .)
    FLOAT           reduce using rule 35 (statement -> for_block .)
    INT             reduce using rule 35 (statement -> for_block .)
    $end            reduce using rule 35 (statement -> for_block .)
    }               reduce using rule 35 (statement -> for_block .)
    RETURN          reduce using rule 35 (statement -> for_block .)


state 18

    (36) statement -> print_stmt .

    IF              reduce using rule 36 (statement -> print_stmt .)
    WHILE           reduce using rule 36 (statement -> print_stmt .)
    FOR             reduce using rule 36 (statement -> print_stmt .)
    PRINT           reduce using rule 36 (statement -> print_stmt .)
    READ            reduce using rule 36 (statement -> print_stmt .)
    STRING          reduce using rule 36 (statement -> print_stmt .)
    NEW             reduce using rule 36 (statement -> print_stmt .)
    THIS            reduce using rule 36 (statement -> print_stmt .)
    ID              reduce using rule 36 (statement -> print_stmt .)
    $               reduce using rule 36 (statement -> print_stmt .)
    (               reduce using rule 36 (statement -> print_stmt .)
    FLOAT           reduce using rule 36 (statement -> print_stmt .)
    INT             reduce using rule 36 (statement -> print_stmt .)
    $end            reduce using rule 36 (statement -> print_stmt .)
    }               reduce using rule 36 (statement -> print_stmt .)
    RETURN          reduce using rule 36 (statement -> print_stmt .)


state 19

    (37) statement -> expr .

    IF              reduce using rule 37 (statement -> expr .)
    WHILE           reduce using rule 37 (statement -> expr .)
    FOR             reduce using rule 37 (statement -> expr .)
    PRINT           reduce using rule 37 (statement -> expr .)
    READ            reduce using rule 37 (statement -> expr .)
    STRING          reduce using rule 37 (statement -> expr .)
    NEW             reduce using rule 37 (statement -> expr .)
    THIS            reduce using rule 37 (statement -> expr .)
    ID              reduce using rule 37 (statement -> expr .)
    $               reduce using rule 37 (statement -> expr .)
    (               reduce using rule 37 (statement -> expr .)
    FLOAT           reduce using rule 37 (statement -> expr .)
    INT             reduce using rule 37 (statement -> expr .)
    $end            reduce using rule 37 (statement -> expr .)
    }               reduce using rule 37 (statement -> expr .)
    RETURN          reduce using rule 37 (statement -> expr .)


state 20

    (44) if_block -> IF . ( exp exp_evaluation ) block
    (45) if_block -> IF . ( exp exp_evaluation ) block after_if_block ELSE block

    (               shift and go to state 57


state 21

    (74) factor -> ( . math_or )
    (76) math_or -> . math_and math_or_alt
    (79) math_and -> . math_comp math_and_alt
    (82) math_comp -> . math_exp math_comp_alt
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (97) stack_call -> . ID . stack_method

    (               shift and go to state 21
    ID              shift and go to state 59
    FLOAT           shift and go to state 48
    INT             shift and go to state 49
    THIS            shift and go to state 41

    math_or                        shift and go to state 58
    math_and                       shift and go to state 33
    math_comp                      shift and go to state 37
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    prop                           shift and go to state 60
    stack_call                     shift and go to state 50

state 22

    (54) expr -> exp . ;

    ;               shift and go to state 61


state 23

    (46) while_block -> WHILE . ( leave_breadcrumb exp exp_evaluation ) block

    (               shift and go to state 62


state 24

    (47) for_block -> FOR . number FOR_TO number SKIP number block
    (52) number -> . FLOAT empty
    (53) number -> . INT

    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    number                         shift and go to state 63

state 25

    (72) factor -> number .

    *               reduce using rule 72 (factor -> number .)
    /               reduce using rule 72 (factor -> number .)
    +               reduce using rule 72 (factor -> number .)
    -               reduce using rule 72 (factor -> number .)
    <               reduce using rule 72 (factor -> number .)
    >               reduce using rule 72 (factor -> number .)
    EQ              reduce using rule 72 (factor -> number .)
    NE              reduce using rule 72 (factor -> number .)
    LE              reduce using rule 72 (factor -> number .)
    GE              reduce using rule 72 (factor -> number .)
    AND             reduce using rule 72 (factor -> number .)
    OR              reduce using rule 72 (factor -> number .)
    ;               reduce using rule 72 (factor -> number .)
    )               reduce using rule 72 (factor -> number .)
    ,               reduce using rule 72 (factor -> number .)


state 26

    (48) print_stmt -> PRINT . ( exp ) ;

    (               shift and go to state 64


state 27

    (55) exp -> read .

    ;               reduce using rule 55 (exp -> read .)
    )               reduce using rule 55 (exp -> read .)
    ,               reduce using rule 55 (exp -> read .)


state 28

    (56) exp -> math_or .

    ;               reduce using rule 56 (exp -> math_or .)
    )               reduce using rule 56 (exp -> math_or .)
    ,               reduce using rule 56 (exp -> math_or .)


state 29

    (57) exp -> assign .

    ;               reduce using rule 57 (exp -> assign .)
    )               reduce using rule 57 (exp -> assign .)
    ,               reduce using rule 57 (exp -> assign .)


state 30

    (58) exp -> string .

    ;               reduce using rule 58 (exp -> string .)
    )               reduce using rule 58 (exp -> string .)
    ,               reduce using rule 58 (exp -> string .)


state 31

    (59) exp -> new .

    ;               reduce using rule 59 (exp -> new .)
    )               reduce using rule 59 (exp -> new .)
    ,               reduce using rule 59 (exp -> new .)


state 32

    (61) read -> READ . ( )

    (               shift and go to state 65


state 33

    (76) math_or -> math_and . math_or_alt
    (77) math_or_alt -> . OR math_and new_quad math_or_alt
    (78) math_or_alt -> . empty
    (101) empty -> .

    OR              shift and go to state 67
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    math_or_alt                    shift and go to state 66
    empty                          shift and go to state 68

state 34

    (38) assign -> var . = exp

    =               shift and go to state 69


state 35

    (60) string -> STRING .

    ;               reduce using rule 60 (string -> STRING .)
    )               reduce using rule 60 (string -> STRING .)
    ,               reduce using rule 60 (string -> STRING .)


state 36

    (3) new -> NEW . constructor_call
    (40) constructor_call -> . ID ( args )

    ID              shift and go to state 71

    constructor_call               shift and go to state 70

state 37

    (79) math_and -> math_comp . math_and_alt
    (80) math_and_alt -> . AND math_comp new_quad math_and_alt
    (81) math_and_alt -> . empty
    (101) empty -> .

    AND             shift and go to state 73
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    math_and_alt                   shift and go to state 72
    empty                          shift and go to state 74

state 38

    (5) var -> prop .
    (91) call -> prop . ( args )

    =               reduce using rule 5 (var -> prop .)
    (               shift and go to state 75


state 39

    (6) var -> declaration .

    =               reduce using rule 6 (var -> declaration .)


state 40

    (82) math_comp -> math_exp . math_comp_alt
    (83) math_comp_alt -> . comparison_op math_exp new_quad
    (84) math_comp_alt -> . empty
    (85) comparison_op -> . <
    (86) comparison_op -> . >
    (87) comparison_op -> . EQ
    (88) comparison_op -> . NE
    (89) comparison_op -> . LE
    (90) comparison_op -> . GE
    (101) empty -> .

    <               shift and go to state 79
    >               shift and go to state 80
    EQ              shift and go to state 81
    NE              shift and go to state 82
    LE              shift and go to state 83
    GE              shift and go to state 84
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    math_comp_alt                  shift and go to state 76
    comparison_op                  shift and go to state 77
    empty                          shift and go to state 78

state 41

    (41) prop -> THIS . . ID

    .               shift and go to state 85


state 42

    (42) prop -> ID . . ID
    (43) prop -> ID .
    (75) id -> ID .
    (97) stack_call -> ID . . stack_method

    .               shift and go to state 86
    (               reduce using rule 43 (prop -> ID .)
    =               reduce using rule 43 (prop -> ID .)
    *               reduce using rule 75 (id -> ID .)
    /               reduce using rule 75 (id -> ID .)
    +               reduce using rule 75 (id -> ID .)
    -               reduce using rule 75 (id -> ID .)
    <               reduce using rule 75 (id -> ID .)
    >               reduce using rule 75 (id -> ID .)
    EQ              reduce using rule 75 (id -> ID .)
    NE              reduce using rule 75 (id -> ID .)
    LE              reduce using rule 75 (id -> ID .)
    GE              reduce using rule 75 (id -> ID .)
    AND             reduce using rule 75 (id -> ID .)
    OR              reduce using rule 75 (id -> ID .)
    ;               reduce using rule 75 (id -> ID .)
    )               reduce using rule 75 (id -> ID .)
    ,               reduce using rule 75 (id -> ID .)


state 43

    (2) declaration -> $ . attr
    (4) attr -> . ID : type

    ID              shift and go to state 88

    attr                           shift and go to state 87

state 44

    (62) math_exp -> term . math_exp_alt
    (63) math_exp_alt -> . + term new_quad math_exp_alt
    (64) math_exp_alt -> . - term new_quad math_exp_alt
    (65) math_exp_alt -> . empty
    (101) empty -> .

    +               shift and go to state 90
    -               shift and go to state 91
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    math_exp_alt                   shift and go to state 89
    empty                          shift and go to state 92

state 45

    (66) term -> factor . term_alt
    (67) term_alt -> . * factor new_quad term_alt
    (68) term_alt -> . / factor new_quad term_alt
    (69) term_alt -> . empty
    (101) empty -> .

    *               shift and go to state 94
    /               shift and go to state 95
    +               reduce using rule 101 (empty -> .)
    -               reduce using rule 101 (empty -> .)
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    term_alt                       shift and go to state 93
    empty                          shift and go to state 96

state 46

    (71) factor -> id .

    *               reduce using rule 71 (factor -> id .)
    /               reduce using rule 71 (factor -> id .)
    +               reduce using rule 71 (factor -> id .)
    -               reduce using rule 71 (factor -> id .)
    <               reduce using rule 71 (factor -> id .)
    >               reduce using rule 71 (factor -> id .)
    EQ              reduce using rule 71 (factor -> id .)
    NE              reduce using rule 71 (factor -> id .)
    LE              reduce using rule 71 (factor -> id .)
    GE              reduce using rule 71 (factor -> id .)
    AND             reduce using rule 71 (factor -> id .)
    OR              reduce using rule 71 (factor -> id .)
    ;               reduce using rule 71 (factor -> id .)
    )               reduce using rule 71 (factor -> id .)
    ,               reduce using rule 71 (factor -> id .)


state 47

    (73) factor -> call .

    *               reduce using rule 73 (factor -> call .)
    /               reduce using rule 73 (factor -> call .)
    +               reduce using rule 73 (factor -> call .)
    -               reduce using rule 73 (factor -> call .)
    <               reduce using rule 73 (factor -> call .)
    >               reduce using rule 73 (factor -> call .)
    EQ              reduce using rule 73 (factor -> call .)
    NE              reduce using rule 73 (factor -> call .)
    LE              reduce using rule 73 (factor -> call .)
    GE              reduce using rule 73 (factor -> call .)
    AND             reduce using rule 73 (factor -> call .)
    OR              reduce using rule 73 (factor -> call .)
    ;               reduce using rule 73 (factor -> call .)
    )               reduce using rule 73 (factor -> call .)
    ,               reduce using rule 73 (factor -> call .)


state 48

    (52) number -> FLOAT . empty
    (101) empty -> .

    *               reduce using rule 101 (empty -> .)
    /               reduce using rule 101 (empty -> .)
    +               reduce using rule 101 (empty -> .)
    -               reduce using rule 101 (empty -> .)
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    FOR_TO          reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)
    SKIP            reduce using rule 101 (empty -> .)
    {               reduce using rule 101 (empty -> .)

    empty                          shift and go to state 97

state 49

    (53) number -> INT .

    *               reduce using rule 53 (number -> INT .)
    /               reduce using rule 53 (number -> INT .)
    +               reduce using rule 53 (number -> INT .)
    -               reduce using rule 53 (number -> INT .)
    <               reduce using rule 53 (number -> INT .)
    >               reduce using rule 53 (number -> INT .)
    EQ              reduce using rule 53 (number -> INT .)
    NE              reduce using rule 53 (number -> INT .)
    LE              reduce using rule 53 (number -> INT .)
    GE              reduce using rule 53 (number -> INT .)
    AND             reduce using rule 53 (number -> INT .)
    OR              reduce using rule 53 (number -> INT .)
    ;               reduce using rule 53 (number -> INT .)
    )               reduce using rule 53 (number -> INT .)
    FOR_TO          reduce using rule 53 (number -> INT .)
    ,               reduce using rule 53 (number -> INT .)
    SKIP            reduce using rule 53 (number -> INT .)
    {               reduce using rule 53 (number -> INT .)


state 50

    (92) call -> stack_call .

    *               reduce using rule 92 (call -> stack_call .)
    /               reduce using rule 92 (call -> stack_call .)
    +               reduce using rule 92 (call -> stack_call .)
    -               reduce using rule 92 (call -> stack_call .)
    <               reduce using rule 92 (call -> stack_call .)
    >               reduce using rule 92 (call -> stack_call .)
    EQ              reduce using rule 92 (call -> stack_call .)
    NE              reduce using rule 92 (call -> stack_call .)
    LE              reduce using rule 92 (call -> stack_call .)
    GE              reduce using rule 92 (call -> stack_call .)
    AND             reduce using rule 92 (call -> stack_call .)
    OR              reduce using rule 92 (call -> stack_call .)
    ;               reduce using rule 92 (call -> stack_call .)
    )               reduce using rule 92 (call -> stack_call .)
    ,               reduce using rule 92 (call -> stack_call .)


state 51

    (22) functions -> function functions .

    IF              reduce using rule 22 (functions -> function functions .)
    WHILE           reduce using rule 22 (functions -> function functions .)
    FOR             reduce using rule 22 (functions -> function functions .)
    PRINT           reduce using rule 22 (functions -> function functions .)
    READ            reduce using rule 22 (functions -> function functions .)
    STRING          reduce using rule 22 (functions -> function functions .)
    NEW             reduce using rule 22 (functions -> function functions .)
    THIS            reduce using rule 22 (functions -> function functions .)
    ID              reduce using rule 22 (functions -> function functions .)
    $               reduce using rule 22 (functions -> function functions .)
    (               reduce using rule 22 (functions -> function functions .)
    FLOAT           reduce using rule 22 (functions -> function functions .)
    INT             reduce using rule 22 (functions -> function functions .)
    $end            reduce using rule 22 (functions -> function functions .)
    }               reduce using rule 22 (functions -> function functions .)


state 52

    (24) function -> # ID . neg_lookup : return_type params scope_function func_block
    (106) neg_lookup -> . empty
    (101) empty -> .

    :               reduce using rule 101 (empty -> .)

    neg_lookup                     shift and go to state 98
    empty                          shift and go to state 99

state 53

    (17) class -> @ ID inheritance . class_attribute scope_class store_attributes class_block
    (21) class_attribute -> . ( attrs )

    (               shift and go to state 101

    class_attribute                shift and go to state 100

state 54

    (18) inheritance -> < . ID check_class >

    ID              shift and go to state 102


state 55

    (19) inheritance -> empty .

    (               reduce using rule 19 (inheritance -> empty .)


state 56

    (31) statements -> statement statements .

    $end            reduce using rule 31 (statements -> statement statements .)
    }               reduce using rule 31 (statements -> statement statements .)
    RETURN          reduce using rule 31 (statements -> statement statements .)


state 57

    (44) if_block -> IF ( . exp exp_evaluation ) block
    (45) if_block -> IF ( . exp exp_evaluation ) block after_if_block ELSE block
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    exp                            shift and go to state 103
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 58

    (74) factor -> ( math_or . )

    )               shift and go to state 104


state 59

    (75) id -> ID .
    (42) prop -> ID . . ID
    (43) prop -> ID .
    (97) stack_call -> ID . . stack_method

    *               reduce using rule 75 (id -> ID .)
    /               reduce using rule 75 (id -> ID .)
    +               reduce using rule 75 (id -> ID .)
    -               reduce using rule 75 (id -> ID .)
    <               reduce using rule 75 (id -> ID .)
    >               reduce using rule 75 (id -> ID .)
    EQ              reduce using rule 75 (id -> ID .)
    NE              reduce using rule 75 (id -> ID .)
    LE              reduce using rule 75 (id -> ID .)
    GE              reduce using rule 75 (id -> ID .)
    AND             reduce using rule 75 (id -> ID .)
    OR              reduce using rule 75 (id -> ID .)
    )               reduce using rule 75 (id -> ID .)
    ;               reduce using rule 75 (id -> ID .)
    ,               reduce using rule 75 (id -> ID .)
    .               shift and go to state 86
    (               reduce using rule 43 (prop -> ID .)


state 60

    (91) call -> prop . ( args )

    (               shift and go to state 75


state 61

    (54) expr -> exp ; .

    IF              reduce using rule 54 (expr -> exp ; .)
    WHILE           reduce using rule 54 (expr -> exp ; .)
    FOR             reduce using rule 54 (expr -> exp ; .)
    PRINT           reduce using rule 54 (expr -> exp ; .)
    READ            reduce using rule 54 (expr -> exp ; .)
    STRING          reduce using rule 54 (expr -> exp ; .)
    NEW             reduce using rule 54 (expr -> exp ; .)
    THIS            reduce using rule 54 (expr -> exp ; .)
    ID              reduce using rule 54 (expr -> exp ; .)
    $               reduce using rule 54 (expr -> exp ; .)
    (               reduce using rule 54 (expr -> exp ; .)
    FLOAT           reduce using rule 54 (expr -> exp ; .)
    INT             reduce using rule 54 (expr -> exp ; .)
    $end            reduce using rule 54 (expr -> exp ; .)
    }               reduce using rule 54 (expr -> exp ; .)
    RETURN          reduce using rule 54 (expr -> exp ; .)


state 62

    (46) while_block -> WHILE ( . leave_breadcrumb exp exp_evaluation ) block
    (110) leave_breadcrumb -> . empty
    (101) empty -> .

    READ            reduce using rule 101 (empty -> .)
    STRING          reduce using rule 101 (empty -> .)
    NEW             reduce using rule 101 (empty -> .)
    THIS            reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    $               reduce using rule 101 (empty -> .)
    (               reduce using rule 101 (empty -> .)
    FLOAT           reduce using rule 101 (empty -> .)
    INT             reduce using rule 101 (empty -> .)

    leave_breadcrumb               shift and go to state 105
    empty                          shift and go to state 106

state 63

    (47) for_block -> FOR number . FOR_TO number SKIP number block

    FOR_TO          shift and go to state 107


state 64

    (48) print_stmt -> PRINT ( . exp ) ;
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    exp                            shift and go to state 108
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 65

    (61) read -> READ ( . )

    )               shift and go to state 109


state 66

    (76) math_or -> math_and math_or_alt .

    ;               reduce using rule 76 (math_or -> math_and math_or_alt .)
    )               reduce using rule 76 (math_or -> math_and math_or_alt .)
    ,               reduce using rule 76 (math_or -> math_and math_or_alt .)


state 67

    (77) math_or_alt -> OR . math_and new_quad math_or_alt
    (79) math_and -> . math_comp math_and_alt
    (82) math_comp -> . math_exp math_comp_alt
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (97) stack_call -> . ID . stack_method

    (               shift and go to state 21
    ID              shift and go to state 59
    FLOAT           shift and go to state 48
    INT             shift and go to state 49
    THIS            shift and go to state 41

    math_and                       shift and go to state 110
    math_comp                      shift and go to state 37
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    prop                           shift and go to state 60
    stack_call                     shift and go to state 50

state 68

    (78) math_or_alt -> empty .

    ;               reduce using rule 78 (math_or_alt -> empty .)
    )               reduce using rule 78 (math_or_alt -> empty .)
    ,               reduce using rule 78 (math_or_alt -> empty .)


state 69

    (38) assign -> var = . exp
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    var                            shift and go to state 34
    exp                            shift and go to state 111
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 70

    (3) new -> NEW constructor_call .

    ;               reduce using rule 3 (new -> NEW constructor_call .)
    )               reduce using rule 3 (new -> NEW constructor_call .)
    ,               reduce using rule 3 (new -> NEW constructor_call .)


state 71

    (40) constructor_call -> ID . ( args )

    (               shift and go to state 112


state 72

    (79) math_and -> math_comp math_and_alt .

    OR              reduce using rule 79 (math_and -> math_comp math_and_alt .)
    ;               reduce using rule 79 (math_and -> math_comp math_and_alt .)
    )               reduce using rule 79 (math_and -> math_comp math_and_alt .)
    ,               reduce using rule 79 (math_and -> math_comp math_and_alt .)


state 73

    (80) math_and_alt -> AND . math_comp new_quad math_and_alt
    (82) math_comp -> . math_exp math_comp_alt
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (97) stack_call -> . ID . stack_method

    (               shift and go to state 21
    ID              shift and go to state 59
    FLOAT           shift and go to state 48
    INT             shift and go to state 49
    THIS            shift and go to state 41

    math_comp                      shift and go to state 113
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    prop                           shift and go to state 60
    stack_call                     shift and go to state 50

state 74

    (81) math_and_alt -> empty .

    OR              reduce using rule 81 (math_and_alt -> empty .)
    ;               reduce using rule 81 (math_and_alt -> empty .)
    )               reduce using rule 81 (math_and_alt -> empty .)
    ,               reduce using rule 81 (math_and_alt -> empty .)


state 75

    (91) call -> prop ( . args )
    (93) args -> . exp args_aux
    (94) args -> . empty
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (101) empty -> .
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    )               reduce using rule 101 (empty -> .)
    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    prop                           shift and go to state 38
    args                           shift and go to state 114
    exp                            shift and go to state 115
    empty                          shift and go to state 116
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 76

    (82) math_comp -> math_exp math_comp_alt .

    AND             reduce using rule 82 (math_comp -> math_exp math_comp_alt .)
    OR              reduce using rule 82 (math_comp -> math_exp math_comp_alt .)
    ;               reduce using rule 82 (math_comp -> math_exp math_comp_alt .)
    )               reduce using rule 82 (math_comp -> math_exp math_comp_alt .)
    ,               reduce using rule 82 (math_comp -> math_exp math_comp_alt .)


state 77

    (83) math_comp_alt -> comparison_op . math_exp new_quad
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (97) stack_call -> . ID . stack_method

    (               shift and go to state 21
    ID              shift and go to state 59
    FLOAT           shift and go to state 48
    INT             shift and go to state 49
    THIS            shift and go to state 41

    math_exp                       shift and go to state 117
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    prop                           shift and go to state 60
    stack_call                     shift and go to state 50

state 78

    (84) math_comp_alt -> empty .

    AND             reduce using rule 84 (math_comp_alt -> empty .)
    OR              reduce using rule 84 (math_comp_alt -> empty .)
    ;               reduce using rule 84 (math_comp_alt -> empty .)
    )               reduce using rule 84 (math_comp_alt -> empty .)
    ,               reduce using rule 84 (math_comp_alt -> empty .)


state 79

    (85) comparison_op -> < .

    (               reduce using rule 85 (comparison_op -> < .)
    ID              reduce using rule 85 (comparison_op -> < .)
    FLOAT           reduce using rule 85 (comparison_op -> < .)
    INT             reduce using rule 85 (comparison_op -> < .)
    THIS            reduce using rule 85 (comparison_op -> < .)


state 80

    (86) comparison_op -> > .

    (               reduce using rule 86 (comparison_op -> > .)
    ID              reduce using rule 86 (comparison_op -> > .)
    FLOAT           reduce using rule 86 (comparison_op -> > .)
    INT             reduce using rule 86 (comparison_op -> > .)
    THIS            reduce using rule 86 (comparison_op -> > .)


state 81

    (87) comparison_op -> EQ .

    (               reduce using rule 87 (comparison_op -> EQ .)
    ID              reduce using rule 87 (comparison_op -> EQ .)
    FLOAT           reduce using rule 87 (comparison_op -> EQ .)
    INT             reduce using rule 87 (comparison_op -> EQ .)
    THIS            reduce using rule 87 (comparison_op -> EQ .)


state 82

    (88) comparison_op -> NE .

    (               reduce using rule 88 (comparison_op -> NE .)
    ID              reduce using rule 88 (comparison_op -> NE .)
    FLOAT           reduce using rule 88 (comparison_op -> NE .)
    INT             reduce using rule 88 (comparison_op -> NE .)
    THIS            reduce using rule 88 (comparison_op -> NE .)


state 83

    (89) comparison_op -> LE .

    (               reduce using rule 89 (comparison_op -> LE .)
    ID              reduce using rule 89 (comparison_op -> LE .)
    FLOAT           reduce using rule 89 (comparison_op -> LE .)
    INT             reduce using rule 89 (comparison_op -> LE .)
    THIS            reduce using rule 89 (comparison_op -> LE .)


state 84

    (90) comparison_op -> GE .

    (               reduce using rule 90 (comparison_op -> GE .)
    ID              reduce using rule 90 (comparison_op -> GE .)
    FLOAT           reduce using rule 90 (comparison_op -> GE .)
    INT             reduce using rule 90 (comparison_op -> GE .)
    THIS            reduce using rule 90 (comparison_op -> GE .)


state 85

    (41) prop -> THIS . . ID

    ID              shift and go to state 118


state 86

    (42) prop -> ID . . ID
    (97) stack_call -> ID . . stack_method
    (98) stack_method -> . POP ( )
    (99) stack_method -> . PUSH ( id )
    (100) stack_method -> . PEEK ( )

    ID              shift and go to state 119
    POP             shift and go to state 121
    PUSH            shift and go to state 122
    PEEK            shift and go to state 123

    stack_method                   shift and go to state 120

state 87

    (2) declaration -> $ attr .

    =               reduce using rule 2 (declaration -> $ attr .)


state 88

    (4) attr -> ID . : type

    :               shift and go to state 124


state 89

    (62) math_exp -> term math_exp_alt .

    <               reduce using rule 62 (math_exp -> term math_exp_alt .)
    >               reduce using rule 62 (math_exp -> term math_exp_alt .)
    EQ              reduce using rule 62 (math_exp -> term math_exp_alt .)
    NE              reduce using rule 62 (math_exp -> term math_exp_alt .)
    LE              reduce using rule 62 (math_exp -> term math_exp_alt .)
    GE              reduce using rule 62 (math_exp -> term math_exp_alt .)
    AND             reduce using rule 62 (math_exp -> term math_exp_alt .)
    OR              reduce using rule 62 (math_exp -> term math_exp_alt .)
    ;               reduce using rule 62 (math_exp -> term math_exp_alt .)
    )               reduce using rule 62 (math_exp -> term math_exp_alt .)
    ,               reduce using rule 62 (math_exp -> term math_exp_alt .)


state 90

    (63) math_exp_alt -> + . term new_quad math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (97) stack_call -> . ID . stack_method

    (               shift and go to state 21
    ID              shift and go to state 59
    FLOAT           shift and go to state 48
    INT             shift and go to state 49
    THIS            shift and go to state 41

    term                           shift and go to state 125
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    prop                           shift and go to state 60
    stack_call                     shift and go to state 50

state 91

    (64) math_exp_alt -> - . term new_quad math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (97) stack_call -> . ID . stack_method

    (               shift and go to state 21
    ID              shift and go to state 59
    FLOAT           shift and go to state 48
    INT             shift and go to state 49
    THIS            shift and go to state 41

    term                           shift and go to state 126
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    prop                           shift and go to state 60
    stack_call                     shift and go to state 50

state 92

    (65) math_exp_alt -> empty .

    <               reduce using rule 65 (math_exp_alt -> empty .)
    >               reduce using rule 65 (math_exp_alt -> empty .)
    EQ              reduce using rule 65 (math_exp_alt -> empty .)
    NE              reduce using rule 65 (math_exp_alt -> empty .)
    LE              reduce using rule 65 (math_exp_alt -> empty .)
    GE              reduce using rule 65 (math_exp_alt -> empty .)
    AND             reduce using rule 65 (math_exp_alt -> empty .)
    OR              reduce using rule 65 (math_exp_alt -> empty .)
    ;               reduce using rule 65 (math_exp_alt -> empty .)
    )               reduce using rule 65 (math_exp_alt -> empty .)
    ,               reduce using rule 65 (math_exp_alt -> empty .)


state 93

    (66) term -> factor term_alt .

    +               reduce using rule 66 (term -> factor term_alt .)
    -               reduce using rule 66 (term -> factor term_alt .)
    <               reduce using rule 66 (term -> factor term_alt .)
    >               reduce using rule 66 (term -> factor term_alt .)
    EQ              reduce using rule 66 (term -> factor term_alt .)
    NE              reduce using rule 66 (term -> factor term_alt .)
    LE              reduce using rule 66 (term -> factor term_alt .)
    GE              reduce using rule 66 (term -> factor term_alt .)
    AND             reduce using rule 66 (term -> factor term_alt .)
    OR              reduce using rule 66 (term -> factor term_alt .)
    ;               reduce using rule 66 (term -> factor term_alt .)
    )               reduce using rule 66 (term -> factor term_alt .)
    ,               reduce using rule 66 (term -> factor term_alt .)


state 94

    (67) term_alt -> * . factor new_quad term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (97) stack_call -> . ID . stack_method

    (               shift and go to state 21
    ID              shift and go to state 59
    FLOAT           shift and go to state 48
    INT             shift and go to state 49
    THIS            shift and go to state 41

    factor                         shift and go to state 127
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    prop                           shift and go to state 60
    stack_call                     shift and go to state 50

state 95

    (68) term_alt -> / . factor new_quad term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (97) stack_call -> . ID . stack_method

    (               shift and go to state 21
    ID              shift and go to state 59
    FLOAT           shift and go to state 48
    INT             shift and go to state 49
    THIS            shift and go to state 41

    factor                         shift and go to state 128
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    prop                           shift and go to state 60
    stack_call                     shift and go to state 50

state 96

    (69) term_alt -> empty .

    +               reduce using rule 69 (term_alt -> empty .)
    -               reduce using rule 69 (term_alt -> empty .)
    <               reduce using rule 69 (term_alt -> empty .)
    >               reduce using rule 69 (term_alt -> empty .)
    EQ              reduce using rule 69 (term_alt -> empty .)
    NE              reduce using rule 69 (term_alt -> empty .)
    LE              reduce using rule 69 (term_alt -> empty .)
    GE              reduce using rule 69 (term_alt -> empty .)
    AND             reduce using rule 69 (term_alt -> empty .)
    OR              reduce using rule 69 (term_alt -> empty .)
    ;               reduce using rule 69 (term_alt -> empty .)
    )               reduce using rule 69 (term_alt -> empty .)
    ,               reduce using rule 69 (term_alt -> empty .)


state 97

    (52) number -> FLOAT empty .

    *               reduce using rule 52 (number -> FLOAT empty .)
    /               reduce using rule 52 (number -> FLOAT empty .)
    +               reduce using rule 52 (number -> FLOAT empty .)
    -               reduce using rule 52 (number -> FLOAT empty .)
    <               reduce using rule 52 (number -> FLOAT empty .)
    >               reduce using rule 52 (number -> FLOAT empty .)
    EQ              reduce using rule 52 (number -> FLOAT empty .)
    NE              reduce using rule 52 (number -> FLOAT empty .)
    LE              reduce using rule 52 (number -> FLOAT empty .)
    GE              reduce using rule 52 (number -> FLOAT empty .)
    AND             reduce using rule 52 (number -> FLOAT empty .)
    OR              reduce using rule 52 (number -> FLOAT empty .)
    ;               reduce using rule 52 (number -> FLOAT empty .)
    )               reduce using rule 52 (number -> FLOAT empty .)
    FOR_TO          reduce using rule 52 (number -> FLOAT empty .)
    ,               reduce using rule 52 (number -> FLOAT empty .)
    SKIP            reduce using rule 52 (number -> FLOAT empty .)
    {               reduce using rule 52 (number -> FLOAT empty .)


state 98

    (24) function -> # ID neg_lookup . : return_type params scope_function func_block

    :               shift and go to state 129


state 99

    (106) neg_lookup -> empty .

    :               reduce using rule 106 (neg_lookup -> empty .)


state 100

    (17) class -> @ ID inheritance class_attribute . scope_class store_attributes class_block
    (102) scope_class -> . empty
    (101) empty -> .

    {               reduce using rule 101 (empty -> .)

    scope_class                    shift and go to state 130
    empty                          shift and go to state 131

state 101

    (21) class_attribute -> ( . attrs )
    (26) attrs -> . attr attrs_alt
    (27) attrs -> . empty
    (4) attr -> . ID : type
    (101) empty -> .

    ID              shift and go to state 88
    )               reduce using rule 101 (empty -> .)

    attrs                          shift and go to state 132
    attr                           shift and go to state 133
    empty                          shift and go to state 134

state 102

    (18) inheritance -> < ID . check_class >
    (105) check_class -> . empty
    (101) empty -> .

    >               reduce using rule 101 (empty -> .)

    check_class                    shift and go to state 135
    empty                          shift and go to state 136

state 103

    (44) if_block -> IF ( exp . exp_evaluation ) block
    (45) if_block -> IF ( exp . exp_evaluation ) block after_if_block ELSE block
    (108) exp_evaluation -> . empty
    (101) empty -> .

    )               reduce using rule 101 (empty -> .)

    exp_evaluation                 shift and go to state 137
    empty                          shift and go to state 138

state 104

    (74) factor -> ( math_or ) .

    *               reduce using rule 74 (factor -> ( math_or ) .)
    /               reduce using rule 74 (factor -> ( math_or ) .)
    +               reduce using rule 74 (factor -> ( math_or ) .)
    -               reduce using rule 74 (factor -> ( math_or ) .)
    <               reduce using rule 74 (factor -> ( math_or ) .)
    >               reduce using rule 74 (factor -> ( math_or ) .)
    EQ              reduce using rule 74 (factor -> ( math_or ) .)
    NE              reduce using rule 74 (factor -> ( math_or ) .)
    LE              reduce using rule 74 (factor -> ( math_or ) .)
    GE              reduce using rule 74 (factor -> ( math_or ) .)
    AND             reduce using rule 74 (factor -> ( math_or ) .)
    OR              reduce using rule 74 (factor -> ( math_or ) .)
    ;               reduce using rule 74 (factor -> ( math_or ) .)
    )               reduce using rule 74 (factor -> ( math_or ) .)
    ,               reduce using rule 74 (factor -> ( math_or ) .)


state 105

    (46) while_block -> WHILE ( leave_breadcrumb . exp exp_evaluation ) block
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    exp                            shift and go to state 139
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 106

    (110) leave_breadcrumb -> empty .

    READ            reduce using rule 110 (leave_breadcrumb -> empty .)
    STRING          reduce using rule 110 (leave_breadcrumb -> empty .)
    NEW             reduce using rule 110 (leave_breadcrumb -> empty .)
    THIS            reduce using rule 110 (leave_breadcrumb -> empty .)
    ID              reduce using rule 110 (leave_breadcrumb -> empty .)
    $               reduce using rule 110 (leave_breadcrumb -> empty .)
    (               reduce using rule 110 (leave_breadcrumb -> empty .)
    FLOAT           reduce using rule 110 (leave_breadcrumb -> empty .)
    INT             reduce using rule 110 (leave_breadcrumb -> empty .)


state 107

    (47) for_block -> FOR number FOR_TO . number SKIP number block
    (52) number -> . FLOAT empty
    (53) number -> . INT

    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    number                         shift and go to state 140

state 108

    (48) print_stmt -> PRINT ( exp . ) ;

    )               shift and go to state 141


state 109

    (61) read -> READ ( ) .

    ;               reduce using rule 61 (read -> READ ( ) .)
    )               reduce using rule 61 (read -> READ ( ) .)
    ,               reduce using rule 61 (read -> READ ( ) .)


state 110

    (77) math_or_alt -> OR math_and . new_quad math_or_alt
    (70) new_quad -> . empty
    (101) empty -> .

    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    new_quad                       shift and go to state 142
    empty                          shift and go to state 143

state 111

    (38) assign -> var = exp .

    ;               reduce using rule 38 (assign -> var = exp .)
    )               reduce using rule 38 (assign -> var = exp .)
    ,               reduce using rule 38 (assign -> var = exp .)


state 112

    (40) constructor_call -> ID ( . args )
    (93) args -> . exp args_aux
    (94) args -> . empty
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (101) empty -> .
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    )               reduce using rule 101 (empty -> .)
    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    args                           shift and go to state 144
    exp                            shift and go to state 115
    empty                          shift and go to state 116
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 113

    (80) math_and_alt -> AND math_comp . new_quad math_and_alt
    (70) new_quad -> . empty
    (101) empty -> .

    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    new_quad                       shift and go to state 145
    empty                          shift and go to state 143

state 114

    (91) call -> prop ( args . )

    )               shift and go to state 146


state 115

    (93) args -> exp . args_aux
    (95) args_aux -> . , exp args_aux
    (96) args_aux -> . empty
    (101) empty -> .

    ,               shift and go to state 148
    )               reduce using rule 101 (empty -> .)

    args_aux                       shift and go to state 147
    empty                          shift and go to state 149

state 116

    (94) args -> empty .

    )               reduce using rule 94 (args -> empty .)


state 117

    (83) math_comp_alt -> comparison_op math_exp . new_quad
    (70) new_quad -> . empty
    (101) empty -> .

    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    new_quad                       shift and go to state 150
    empty                          shift and go to state 143

state 118

    (41) prop -> THIS . ID .

    (               reduce using rule 41 (prop -> THIS . ID .)
    =               reduce using rule 41 (prop -> THIS . ID .)


state 119

    (42) prop -> ID . ID .

    (               reduce using rule 42 (prop -> ID . ID .)
    =               reduce using rule 42 (prop -> ID . ID .)


state 120

    (97) stack_call -> ID . stack_method .

    *               reduce using rule 97 (stack_call -> ID . stack_method .)
    /               reduce using rule 97 (stack_call -> ID . stack_method .)
    +               reduce using rule 97 (stack_call -> ID . stack_method .)
    -               reduce using rule 97 (stack_call -> ID . stack_method .)
    <               reduce using rule 97 (stack_call -> ID . stack_method .)
    >               reduce using rule 97 (stack_call -> ID . stack_method .)
    EQ              reduce using rule 97 (stack_call -> ID . stack_method .)
    NE              reduce using rule 97 (stack_call -> ID . stack_method .)
    LE              reduce using rule 97 (stack_call -> ID . stack_method .)
    GE              reduce using rule 97 (stack_call -> ID . stack_method .)
    AND             reduce using rule 97 (stack_call -> ID . stack_method .)
    OR              reduce using rule 97 (stack_call -> ID . stack_method .)
    ;               reduce using rule 97 (stack_call -> ID . stack_method .)
    )               reduce using rule 97 (stack_call -> ID . stack_method .)
    ,               reduce using rule 97 (stack_call -> ID . stack_method .)


state 121

    (98) stack_method -> POP . ( )

    (               shift and go to state 151


state 122

    (99) stack_method -> PUSH . ( id )

    (               shift and go to state 152


state 123

    (100) stack_method -> PEEK . ( )

    (               shift and go to state 153


state 124

    (4) attr -> ID : . type
    (7) type -> . INT_TYPE
    (8) type -> . FLOAT_TYPE
    (9) type -> . STRING_TYPE
    (10) type -> . BOOLEAN_TYPE
    (11) type -> . STACK
    (12) type -> . ID check_class

    INT_TYPE        shift and go to state 156
    FLOAT_TYPE      shift and go to state 157
    STRING_TYPE     shift and go to state 158
    BOOLEAN_TYPE    shift and go to state 159
    STACK           shift and go to state 160
    ID              shift and go to state 154

    type                           shift and go to state 155

state 125

    (63) math_exp_alt -> + term . new_quad math_exp_alt
    (70) new_quad -> . empty
    (101) empty -> .

    +               reduce using rule 101 (empty -> .)
    -               reduce using rule 101 (empty -> .)
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    new_quad                       shift and go to state 161
    empty                          shift and go to state 143

state 126

    (64) math_exp_alt -> - term . new_quad math_exp_alt
    (70) new_quad -> . empty
    (101) empty -> .

    +               reduce using rule 101 (empty -> .)
    -               reduce using rule 101 (empty -> .)
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    new_quad                       shift and go to state 162
    empty                          shift and go to state 143

state 127

    (67) term_alt -> * factor . new_quad term_alt
    (70) new_quad -> . empty
    (101) empty -> .

    *               reduce using rule 101 (empty -> .)
    /               reduce using rule 101 (empty -> .)
    +               reduce using rule 101 (empty -> .)
    -               reduce using rule 101 (empty -> .)
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    new_quad                       shift and go to state 163
    empty                          shift and go to state 143

state 128

    (68) term_alt -> / factor . new_quad term_alt
    (70) new_quad -> . empty
    (101) empty -> .

    *               reduce using rule 101 (empty -> .)
    /               reduce using rule 101 (empty -> .)
    +               reduce using rule 101 (empty -> .)
    -               reduce using rule 101 (empty -> .)
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    new_quad                       shift and go to state 164
    empty                          shift and go to state 143

state 129

    (24) function -> # ID neg_lookup : . return_type params scope_function func_block
    (13) return_type -> . VOID
    (14) return_type -> . type
    (7) type -> . INT_TYPE
    (8) type -> . FLOAT_TYPE
    (9) type -> . STRING_TYPE
    (10) type -> . BOOLEAN_TYPE
    (11) type -> . STACK
    (12) type -> . ID check_class

    VOID            shift and go to state 166
    INT_TYPE        shift and go to state 156
    FLOAT_TYPE      shift and go to state 157
    STRING_TYPE     shift and go to state 158
    BOOLEAN_TYPE    shift and go to state 159
    STACK           shift and go to state 160
    ID              shift and go to state 154

    return_type                    shift and go to state 165
    type                           shift and go to state 167

state 130

    (17) class -> @ ID inheritance class_attribute scope_class . store_attributes class_block
    (107) store_attributes -> . empty
    (101) empty -> .

    {               reduce using rule 101 (empty -> .)

    store_attributes               shift and go to state 168
    empty                          shift and go to state 169

state 131

    (102) scope_class -> empty .

    {               reduce using rule 102 (scope_class -> empty .)


state 132

    (21) class_attribute -> ( attrs . )

    )               shift and go to state 170


state 133

    (26) attrs -> attr . attrs_alt
    (28) attrs_alt -> . , attr attrs_alt
    (29) attrs_alt -> . empty
    (101) empty -> .

    ,               shift and go to state 172
    )               reduce using rule 101 (empty -> .)

    attrs_alt                      shift and go to state 171
    empty                          shift and go to state 173

state 134

    (27) attrs -> empty .

    )               reduce using rule 27 (attrs -> empty .)


state 135

    (18) inheritance -> < ID check_class . >

    >               shift and go to state 174


state 136

    (105) check_class -> empty .

    >               reduce using rule 105 (check_class -> empty .)
    =               reduce using rule 105 (check_class -> empty .)
    ,               reduce using rule 105 (check_class -> empty .)
    )               reduce using rule 105 (check_class -> empty .)
    (               reduce using rule 105 (check_class -> empty .)


state 137

    (44) if_block -> IF ( exp exp_evaluation . ) block
    (45) if_block -> IF ( exp exp_evaluation . ) block after_if_block ELSE block

    )               shift and go to state 175


state 138

    (108) exp_evaluation -> empty .

    )               reduce using rule 108 (exp_evaluation -> empty .)


state 139

    (46) while_block -> WHILE ( leave_breadcrumb exp . exp_evaluation ) block
    (108) exp_evaluation -> . empty
    (101) empty -> .

    )               reduce using rule 101 (empty -> .)

    exp_evaluation                 shift and go to state 176
    empty                          shift and go to state 138

state 140

    (47) for_block -> FOR number FOR_TO number . SKIP number block

    SKIP            shift and go to state 177


state 141

    (48) print_stmt -> PRINT ( exp ) . ;

    ;               shift and go to state 178


state 142

    (77) math_or_alt -> OR math_and new_quad . math_or_alt
    (77) math_or_alt -> . OR math_and new_quad math_or_alt
    (78) math_or_alt -> . empty
    (101) empty -> .

    OR              shift and go to state 67
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    math_or_alt                    shift and go to state 179
    empty                          shift and go to state 68

state 143

    (70) new_quad -> empty .

    OR              reduce using rule 70 (new_quad -> empty .)
    ;               reduce using rule 70 (new_quad -> empty .)
    )               reduce using rule 70 (new_quad -> empty .)
    ,               reduce using rule 70 (new_quad -> empty .)
    AND             reduce using rule 70 (new_quad -> empty .)
    +               reduce using rule 70 (new_quad -> empty .)
    -               reduce using rule 70 (new_quad -> empty .)
    <               reduce using rule 70 (new_quad -> empty .)
    >               reduce using rule 70 (new_quad -> empty .)
    EQ              reduce using rule 70 (new_quad -> empty .)
    NE              reduce using rule 70 (new_quad -> empty .)
    LE              reduce using rule 70 (new_quad -> empty .)
    GE              reduce using rule 70 (new_quad -> empty .)
    *               reduce using rule 70 (new_quad -> empty .)
    /               reduce using rule 70 (new_quad -> empty .)


state 144

    (40) constructor_call -> ID ( args . )

    )               shift and go to state 180


state 145

    (80) math_and_alt -> AND math_comp new_quad . math_and_alt
    (80) math_and_alt -> . AND math_comp new_quad math_and_alt
    (81) math_and_alt -> . empty
    (101) empty -> .

    AND             shift and go to state 73
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    math_and_alt                   shift and go to state 181
    empty                          shift and go to state 74

state 146

    (91) call -> prop ( args ) .

    *               reduce using rule 91 (call -> prop ( args ) .)
    /               reduce using rule 91 (call -> prop ( args ) .)
    +               reduce using rule 91 (call -> prop ( args ) .)
    -               reduce using rule 91 (call -> prop ( args ) .)
    <               reduce using rule 91 (call -> prop ( args ) .)
    >               reduce using rule 91 (call -> prop ( args ) .)
    EQ              reduce using rule 91 (call -> prop ( args ) .)
    NE              reduce using rule 91 (call -> prop ( args ) .)
    LE              reduce using rule 91 (call -> prop ( args ) .)
    GE              reduce using rule 91 (call -> prop ( args ) .)
    AND             reduce using rule 91 (call -> prop ( args ) .)
    OR              reduce using rule 91 (call -> prop ( args ) .)
    ;               reduce using rule 91 (call -> prop ( args ) .)
    )               reduce using rule 91 (call -> prop ( args ) .)
    ,               reduce using rule 91 (call -> prop ( args ) .)


state 147

    (93) args -> exp args_aux .

    )               reduce using rule 93 (args -> exp args_aux .)


state 148

    (95) args_aux -> , . exp args_aux
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    exp                            shift and go to state 182
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 149

    (96) args_aux -> empty .

    )               reduce using rule 96 (args_aux -> empty .)


state 150

    (83) math_comp_alt -> comparison_op math_exp new_quad .

    AND             reduce using rule 83 (math_comp_alt -> comparison_op math_exp new_quad .)
    OR              reduce using rule 83 (math_comp_alt -> comparison_op math_exp new_quad .)
    ;               reduce using rule 83 (math_comp_alt -> comparison_op math_exp new_quad .)
    )               reduce using rule 83 (math_comp_alt -> comparison_op math_exp new_quad .)
    ,               reduce using rule 83 (math_comp_alt -> comparison_op math_exp new_quad .)


state 151

    (98) stack_method -> POP ( . )

    )               shift and go to state 183


state 152

    (99) stack_method -> PUSH ( . id )
    (75) id -> . ID

    ID              shift and go to state 185

    id                             shift and go to state 184

state 153

    (100) stack_method -> PEEK ( . )

    )               shift and go to state 186


state 154

    (12) type -> ID . check_class
    (105) check_class -> . empty
    (101) empty -> .

    =               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    (               reduce using rule 101 (empty -> .)

    check_class                    shift and go to state 187
    empty                          shift and go to state 136

state 155

    (4) attr -> ID : type .

    =               reduce using rule 4 (attr -> ID : type .)
    ,               reduce using rule 4 (attr -> ID : type .)
    )               reduce using rule 4 (attr -> ID : type .)


state 156

    (7) type -> INT_TYPE .

    =               reduce using rule 7 (type -> INT_TYPE .)
    ,               reduce using rule 7 (type -> INT_TYPE .)
    )               reduce using rule 7 (type -> INT_TYPE .)
    (               reduce using rule 7 (type -> INT_TYPE .)


state 157

    (8) type -> FLOAT_TYPE .

    =               reduce using rule 8 (type -> FLOAT_TYPE .)
    ,               reduce using rule 8 (type -> FLOAT_TYPE .)
    )               reduce using rule 8 (type -> FLOAT_TYPE .)
    (               reduce using rule 8 (type -> FLOAT_TYPE .)


state 158

    (9) type -> STRING_TYPE .

    =               reduce using rule 9 (type -> STRING_TYPE .)
    ,               reduce using rule 9 (type -> STRING_TYPE .)
    )               reduce using rule 9 (type -> STRING_TYPE .)
    (               reduce using rule 9 (type -> STRING_TYPE .)


state 159

    (10) type -> BOOLEAN_TYPE .

    =               reduce using rule 10 (type -> BOOLEAN_TYPE .)
    ,               reduce using rule 10 (type -> BOOLEAN_TYPE .)
    )               reduce using rule 10 (type -> BOOLEAN_TYPE .)
    (               reduce using rule 10 (type -> BOOLEAN_TYPE .)


state 160

    (11) type -> STACK .

    =               reduce using rule 11 (type -> STACK .)
    ,               reduce using rule 11 (type -> STACK .)
    )               reduce using rule 11 (type -> STACK .)
    (               reduce using rule 11 (type -> STACK .)


state 161

    (63) math_exp_alt -> + term new_quad . math_exp_alt
    (63) math_exp_alt -> . + term new_quad math_exp_alt
    (64) math_exp_alt -> . - term new_quad math_exp_alt
    (65) math_exp_alt -> . empty
    (101) empty -> .

    +               shift and go to state 90
    -               shift and go to state 91
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    math_exp_alt                   shift and go to state 188
    empty                          shift and go to state 92

state 162

    (64) math_exp_alt -> - term new_quad . math_exp_alt
    (63) math_exp_alt -> . + term new_quad math_exp_alt
    (64) math_exp_alt -> . - term new_quad math_exp_alt
    (65) math_exp_alt -> . empty
    (101) empty -> .

    +               shift and go to state 90
    -               shift and go to state 91
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    math_exp_alt                   shift and go to state 189
    empty                          shift and go to state 92

state 163

    (67) term_alt -> * factor new_quad . term_alt
    (67) term_alt -> . * factor new_quad term_alt
    (68) term_alt -> . / factor new_quad term_alt
    (69) term_alt -> . empty
    (101) empty -> .

    *               shift and go to state 94
    /               shift and go to state 95
    +               reduce using rule 101 (empty -> .)
    -               reduce using rule 101 (empty -> .)
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    term_alt                       shift and go to state 190
    empty                          shift and go to state 96

state 164

    (68) term_alt -> / factor new_quad . term_alt
    (67) term_alt -> . * factor new_quad term_alt
    (68) term_alt -> . / factor new_quad term_alt
    (69) term_alt -> . empty
    (101) empty -> .

    *               shift and go to state 94
    /               shift and go to state 95
    +               reduce using rule 101 (empty -> .)
    -               reduce using rule 101 (empty -> .)
    <               reduce using rule 101 (empty -> .)
    >               reduce using rule 101 (empty -> .)
    EQ              reduce using rule 101 (empty -> .)
    NE              reduce using rule 101 (empty -> .)
    LE              reduce using rule 101 (empty -> .)
    GE              reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    ;               reduce using rule 101 (empty -> .)
    )               reduce using rule 101 (empty -> .)
    ,               reduce using rule 101 (empty -> .)

    term_alt                       shift and go to state 191
    empty                          shift and go to state 96

state 165

    (24) function -> # ID neg_lookup : return_type . params scope_function func_block
    (25) params -> . ( attrs )

    (               shift and go to state 193

    params                         shift and go to state 192

state 166

    (13) return_type -> VOID .

    (               reduce using rule 13 (return_type -> VOID .)


state 167

    (14) return_type -> type .

    (               reduce using rule 14 (return_type -> type .)


state 168

    (17) class -> @ ID inheritance class_attribute scope_class store_attributes . class_block
    (20) class_block -> . { functions }

    {               shift and go to state 195

    class_block                    shift and go to state 194

state 169

    (107) store_attributes -> empty .

    {               reduce using rule 107 (store_attributes -> empty .)


state 170

    (21) class_attribute -> ( attrs ) .

    {               reduce using rule 21 (class_attribute -> ( attrs ) .)


state 171

    (26) attrs -> attr attrs_alt .

    )               reduce using rule 26 (attrs -> attr attrs_alt .)


state 172

    (28) attrs_alt -> , . attr attrs_alt
    (4) attr -> . ID : type

    ID              shift and go to state 88

    attr                           shift and go to state 196

state 173

    (29) attrs_alt -> empty .

    )               reduce using rule 29 (attrs_alt -> empty .)


state 174

    (18) inheritance -> < ID check_class > .

    (               reduce using rule 18 (inheritance -> < ID check_class > .)


state 175

    (44) if_block -> IF ( exp exp_evaluation ) . block
    (45) if_block -> IF ( exp exp_evaluation ) . block after_if_block ELSE block
    (51) block -> . { statements }

    {               shift and go to state 198

    block                          shift and go to state 197

state 176

    (46) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation . ) block

    )               shift and go to state 199


state 177

    (47) for_block -> FOR number FOR_TO number SKIP . number block
    (52) number -> . FLOAT empty
    (53) number -> . INT

    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    number                         shift and go to state 200

state 178

    (48) print_stmt -> PRINT ( exp ) ; .

    IF              reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    WHILE           reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    FOR             reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    PRINT           reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    READ            reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    STRING          reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    NEW             reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    THIS            reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    ID              reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    $               reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    (               reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    FLOAT           reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    INT             reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    $end            reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    }               reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)
    RETURN          reduce using rule 48 (print_stmt -> PRINT ( exp ) ; .)


state 179

    (77) math_or_alt -> OR math_and new_quad math_or_alt .

    ;               reduce using rule 77 (math_or_alt -> OR math_and new_quad math_or_alt .)
    )               reduce using rule 77 (math_or_alt -> OR math_and new_quad math_or_alt .)
    ,               reduce using rule 77 (math_or_alt -> OR math_and new_quad math_or_alt .)


state 180

    (40) constructor_call -> ID ( args ) .

    ;               reduce using rule 40 (constructor_call -> ID ( args ) .)
    )               reduce using rule 40 (constructor_call -> ID ( args ) .)
    ,               reduce using rule 40 (constructor_call -> ID ( args ) .)


state 181

    (80) math_and_alt -> AND math_comp new_quad math_and_alt .

    OR              reduce using rule 80 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ;               reduce using rule 80 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    )               reduce using rule 80 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ,               reduce using rule 80 (math_and_alt -> AND math_comp new_quad math_and_alt .)


state 182

    (95) args_aux -> , exp . args_aux
    (95) args_aux -> . , exp args_aux
    (96) args_aux -> . empty
    (101) empty -> .

    ,               shift and go to state 148
    )               reduce using rule 101 (empty -> .)

    args_aux                       shift and go to state 201
    empty                          shift and go to state 149

state 183

    (98) stack_method -> POP ( ) .

    *               reduce using rule 98 (stack_method -> POP ( ) .)
    /               reduce using rule 98 (stack_method -> POP ( ) .)
    +               reduce using rule 98 (stack_method -> POP ( ) .)
    -               reduce using rule 98 (stack_method -> POP ( ) .)
    <               reduce using rule 98 (stack_method -> POP ( ) .)
    >               reduce using rule 98 (stack_method -> POP ( ) .)
    EQ              reduce using rule 98 (stack_method -> POP ( ) .)
    NE              reduce using rule 98 (stack_method -> POP ( ) .)
    LE              reduce using rule 98 (stack_method -> POP ( ) .)
    GE              reduce using rule 98 (stack_method -> POP ( ) .)
    AND             reduce using rule 98 (stack_method -> POP ( ) .)
    OR              reduce using rule 98 (stack_method -> POP ( ) .)
    ;               reduce using rule 98 (stack_method -> POP ( ) .)
    )               reduce using rule 98 (stack_method -> POP ( ) .)
    ,               reduce using rule 98 (stack_method -> POP ( ) .)


state 184

    (99) stack_method -> PUSH ( id . )

    )               shift and go to state 202


state 185

    (75) id -> ID .

    )               reduce using rule 75 (id -> ID .)


state 186

    (100) stack_method -> PEEK ( ) .

    *               reduce using rule 100 (stack_method -> PEEK ( ) .)
    /               reduce using rule 100 (stack_method -> PEEK ( ) .)
    +               reduce using rule 100 (stack_method -> PEEK ( ) .)
    -               reduce using rule 100 (stack_method -> PEEK ( ) .)
    <               reduce using rule 100 (stack_method -> PEEK ( ) .)
    >               reduce using rule 100 (stack_method -> PEEK ( ) .)
    EQ              reduce using rule 100 (stack_method -> PEEK ( ) .)
    NE              reduce using rule 100 (stack_method -> PEEK ( ) .)
    LE              reduce using rule 100 (stack_method -> PEEK ( ) .)
    GE              reduce using rule 100 (stack_method -> PEEK ( ) .)
    AND             reduce using rule 100 (stack_method -> PEEK ( ) .)
    OR              reduce using rule 100 (stack_method -> PEEK ( ) .)
    ;               reduce using rule 100 (stack_method -> PEEK ( ) .)
    )               reduce using rule 100 (stack_method -> PEEK ( ) .)
    ,               reduce using rule 100 (stack_method -> PEEK ( ) .)


state 187

    (12) type -> ID check_class .

    =               reduce using rule 12 (type -> ID check_class .)
    ,               reduce using rule 12 (type -> ID check_class .)
    )               reduce using rule 12 (type -> ID check_class .)
    (               reduce using rule 12 (type -> ID check_class .)


state 188

    (63) math_exp_alt -> + term new_quad math_exp_alt .

    <               reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    >               reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    EQ              reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    NE              reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    LE              reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    GE              reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    AND             reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    OR              reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    ;               reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    )               reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)
    ,               reduce using rule 63 (math_exp_alt -> + term new_quad math_exp_alt .)


state 189

    (64) math_exp_alt -> - term new_quad math_exp_alt .

    <               reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    >               reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    EQ              reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    NE              reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    LE              reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    GE              reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    AND             reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    OR              reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    ;               reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    )               reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)
    ,               reduce using rule 64 (math_exp_alt -> - term new_quad math_exp_alt .)


state 190

    (67) term_alt -> * factor new_quad term_alt .

    +               reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    -               reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    <               reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    >               reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    EQ              reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    NE              reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    LE              reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    GE              reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    AND             reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    OR              reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    ;               reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    )               reduce using rule 67 (term_alt -> * factor new_quad term_alt .)
    ,               reduce using rule 67 (term_alt -> * factor new_quad term_alt .)


state 191

    (68) term_alt -> / factor new_quad term_alt .

    +               reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    -               reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    <               reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    >               reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    EQ              reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    NE              reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    LE              reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    GE              reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    AND             reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    OR              reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    ;               reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    )               reduce using rule 68 (term_alt -> / factor new_quad term_alt .)
    ,               reduce using rule 68 (term_alt -> / factor new_quad term_alt .)


state 192

    (24) function -> # ID neg_lookup : return_type params . scope_function func_block
    (103) scope_function -> . empty
    (101) empty -> .

    {               reduce using rule 101 (empty -> .)

    scope_function                 shift and go to state 203
    empty                          shift and go to state 204

state 193

    (25) params -> ( . attrs )
    (26) attrs -> . attr attrs_alt
    (27) attrs -> . empty
    (4) attr -> . ID : type
    (101) empty -> .

    ID              shift and go to state 88
    )               reduce using rule 101 (empty -> .)

    attrs                          shift and go to state 205
    attr                           shift and go to state 133
    empty                          shift and go to state 134

state 194

    (17) class -> @ ID inheritance class_attribute scope_class store_attributes class_block .

    @               reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    #               reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    IF              reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    WHILE           reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    FOR             reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    PRINT           reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    READ            reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    STRING          reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    NEW             reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    THIS            reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    ID              reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    $               reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    (               reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    FLOAT           reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    INT             reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)
    $end            reduce using rule 17 (class -> @ ID inheritance class_attribute scope_class store_attributes class_block .)


state 195

    (20) class_block -> { . functions }
    (22) functions -> . function functions
    (23) functions -> . empty
    (24) function -> . # ID neg_lookup : return_type params scope_function func_block
    (101) empty -> .

    #               shift and go to state 9
    }               reduce using rule 101 (empty -> .)

    functions                      shift and go to state 206
    function                       shift and go to state 7
    empty                          shift and go to state 8

state 196

    (28) attrs_alt -> , attr . attrs_alt
    (28) attrs_alt -> . , attr attrs_alt
    (29) attrs_alt -> . empty
    (101) empty -> .

    ,               shift and go to state 172
    )               reduce using rule 101 (empty -> .)

    attrs_alt                      shift and go to state 207
    empty                          shift and go to state 173

state 197

    (44) if_block -> IF ( exp exp_evaluation ) block .
    (45) if_block -> IF ( exp exp_evaluation ) block . after_if_block ELSE block
    (109) after_if_block -> . empty
    (101) empty -> .

    IF              reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    WHILE           reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    FOR             reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    PRINT           reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    READ            reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    STRING          reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    NEW             reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    THIS            reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    ID              reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    $               reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    (               reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    FLOAT           reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    INT             reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    $end            reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    }               reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    RETURN          reduce using rule 44 (if_block -> IF ( exp exp_evaluation ) block .)
    ELSE            reduce using rule 101 (empty -> .)

    after_if_block                 shift and go to state 208
    empty                          shift and go to state 209

state 198

    (51) block -> { . statements }
    (31) statements -> . statement statements
    (32) statements -> . empty
    (33) statement -> . if_block
    (34) statement -> . while_block
    (35) statement -> . for_block
    (36) statement -> . print_stmt
    (37) statement -> . expr
    (101) empty -> .
    (44) if_block -> . IF ( exp exp_evaluation ) block
    (45) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (46) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (47) for_block -> . FOR number FOR_TO number SKIP number block
    (48) print_stmt -> . PRINT ( exp ) ;
    (54) expr -> . exp ;
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    }               reduce using rule 101 (empty -> .)
    IF              shift and go to state 20
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    PRINT           shift and go to state 26
    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    statements                     shift and go to state 210
    statement                      shift and go to state 13
    empty                          shift and go to state 14
    if_block                       shift and go to state 15
    while_block                    shift and go to state 16
    for_block                      shift and go to state 17
    print_stmt                     shift and go to state 18
    expr                           shift and go to state 19
    exp                            shift and go to state 22
    number                         shift and go to state 25
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 199

    (46) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) . block
    (51) block -> . { statements }

    {               shift and go to state 198

    block                          shift and go to state 211

state 200

    (47) for_block -> FOR number FOR_TO number SKIP number . block
    (51) block -> . { statements }

    {               shift and go to state 198

    block                          shift and go to state 212

state 201

    (95) args_aux -> , exp args_aux .

    )               reduce using rule 95 (args_aux -> , exp args_aux .)


state 202

    (99) stack_method -> PUSH ( id ) .

    *               reduce using rule 99 (stack_method -> PUSH ( id ) .)
    /               reduce using rule 99 (stack_method -> PUSH ( id ) .)
    +               reduce using rule 99 (stack_method -> PUSH ( id ) .)
    -               reduce using rule 99 (stack_method -> PUSH ( id ) .)
    <               reduce using rule 99 (stack_method -> PUSH ( id ) .)
    >               reduce using rule 99 (stack_method -> PUSH ( id ) .)
    EQ              reduce using rule 99 (stack_method -> PUSH ( id ) .)
    NE              reduce using rule 99 (stack_method -> PUSH ( id ) .)
    LE              reduce using rule 99 (stack_method -> PUSH ( id ) .)
    GE              reduce using rule 99 (stack_method -> PUSH ( id ) .)
    AND             reduce using rule 99 (stack_method -> PUSH ( id ) .)
    OR              reduce using rule 99 (stack_method -> PUSH ( id ) .)
    ;               reduce using rule 99 (stack_method -> PUSH ( id ) .)
    )               reduce using rule 99 (stack_method -> PUSH ( id ) .)
    ,               reduce using rule 99 (stack_method -> PUSH ( id ) .)


state 203

    (24) function -> # ID neg_lookup : return_type params scope_function . func_block
    (30) func_block -> . { statements return }

    {               shift and go to state 214

    func_block                     shift and go to state 213

state 204

    (103) scope_function -> empty .

    {               reduce using rule 103 (scope_function -> empty .)


state 205

    (25) params -> ( attrs . )

    )               shift and go to state 215


state 206

    (20) class_block -> { functions . }

    }               shift and go to state 216


state 207

    (28) attrs_alt -> , attr attrs_alt .

    )               reduce using rule 28 (attrs_alt -> , attr attrs_alt .)


state 208

    (45) if_block -> IF ( exp exp_evaluation ) block after_if_block . ELSE block

    ELSE            shift and go to state 217


state 209

    (109) after_if_block -> empty .

    ELSE            reduce using rule 109 (after_if_block -> empty .)


state 210

    (51) block -> { statements . }

    }               shift and go to state 218


state 211

    (46) while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .

    IF              reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    WHILE           reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    FOR             reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    PRINT           reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    READ            reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    STRING          reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    NEW             reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    THIS            reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    ID              reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    $               reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    (               reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    FLOAT           reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    INT             reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    $end            reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    }               reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)
    RETURN          reduce using rule 46 (while_block -> WHILE ( leave_breadcrumb exp exp_evaluation ) block .)


state 212

    (47) for_block -> FOR number FOR_TO number SKIP number block .

    IF              reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    WHILE           reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    FOR             reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    PRINT           reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    READ            reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    STRING          reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    NEW             reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    THIS            reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    ID              reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    $               reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    (               reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    FLOAT           reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    INT             reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    $end            reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    }               reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)
    RETURN          reduce using rule 47 (for_block -> FOR number FOR_TO number SKIP number block .)


state 213

    (24) function -> # ID neg_lookup : return_type params scope_function func_block .

    #               reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    IF              reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    WHILE           reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FOR             reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    PRINT           reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    READ            reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    STRING          reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    NEW             reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    THIS            reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    ID              reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $               reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    (               reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FLOAT           reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    INT             reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $end            reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    }               reduce using rule 24 (function -> # ID neg_lookup : return_type params scope_function func_block .)


state 214

    (30) func_block -> { . statements return }
    (31) statements -> . statement statements
    (32) statements -> . empty
    (33) statement -> . if_block
    (34) statement -> . while_block
    (35) statement -> . for_block
    (36) statement -> . print_stmt
    (37) statement -> . expr
    (101) empty -> .
    (44) if_block -> . IF ( exp exp_evaluation ) block
    (45) if_block -> . IF ( exp exp_evaluation ) block after_if_block ELSE block
    (46) while_block -> . WHILE ( leave_breadcrumb exp exp_evaluation ) block
    (47) for_block -> . FOR number FOR_TO number SKIP number block
    (48) print_stmt -> . PRINT ( exp ) ;
    (54) expr -> . exp ;
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    RETURN          reduce using rule 101 (empty -> .)
    }               reduce using rule 101 (empty -> .)
    IF              shift and go to state 20
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    PRINT           shift and go to state 26
    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    statements                     shift and go to state 219
    statement                      shift and go to state 13
    empty                          shift and go to state 14
    if_block                       shift and go to state 15
    while_block                    shift and go to state 16
    for_block                      shift and go to state 17
    print_stmt                     shift and go to state 18
    expr                           shift and go to state 19
    exp                            shift and go to state 22
    number                         shift and go to state 25
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 215

    (25) params -> ( attrs ) .

    {               reduce using rule 25 (params -> ( attrs ) .)


state 216

    (20) class_block -> { functions } .

    @               reduce using rule 20 (class_block -> { functions } .)
    #               reduce using rule 20 (class_block -> { functions } .)
    IF              reduce using rule 20 (class_block -> { functions } .)
    WHILE           reduce using rule 20 (class_block -> { functions } .)
    FOR             reduce using rule 20 (class_block -> { functions } .)
    PRINT           reduce using rule 20 (class_block -> { functions } .)
    READ            reduce using rule 20 (class_block -> { functions } .)
    STRING          reduce using rule 20 (class_block -> { functions } .)
    NEW             reduce using rule 20 (class_block -> { functions } .)
    THIS            reduce using rule 20 (class_block -> { functions } .)
    ID              reduce using rule 20 (class_block -> { functions } .)
    $               reduce using rule 20 (class_block -> { functions } .)
    (               reduce using rule 20 (class_block -> { functions } .)
    FLOAT           reduce using rule 20 (class_block -> { functions } .)
    INT             reduce using rule 20 (class_block -> { functions } .)
    $end            reduce using rule 20 (class_block -> { functions } .)


state 217

    (45) if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE . block
    (51) block -> . { statements }

    {               shift and go to state 198

    block                          shift and go to state 220

state 218

    (51) block -> { statements } .

    ELSE            reduce using rule 51 (block -> { statements } .)
    IF              reduce using rule 51 (block -> { statements } .)
    WHILE           reduce using rule 51 (block -> { statements } .)
    FOR             reduce using rule 51 (block -> { statements } .)
    PRINT           reduce using rule 51 (block -> { statements } .)
    READ            reduce using rule 51 (block -> { statements } .)
    STRING          reduce using rule 51 (block -> { statements } .)
    NEW             reduce using rule 51 (block -> { statements } .)
    THIS            reduce using rule 51 (block -> { statements } .)
    ID              reduce using rule 51 (block -> { statements } .)
    $               reduce using rule 51 (block -> { statements } .)
    (               reduce using rule 51 (block -> { statements } .)
    FLOAT           reduce using rule 51 (block -> { statements } .)
    INT             reduce using rule 51 (block -> { statements } .)
    $end            reduce using rule 51 (block -> { statements } .)
    }               reduce using rule 51 (block -> { statements } .)
    RETURN          reduce using rule 51 (block -> { statements } .)


state 219

    (30) func_block -> { statements . return }
    (49) return -> . RETURN exp ;
    (50) return -> . empty
    (101) empty -> .

    RETURN          shift and go to state 222
    }               reduce using rule 101 (empty -> .)

    return                         shift and go to state 221
    empty                          shift and go to state 223

state 220

    (45) if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .

    IF              reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    WHILE           reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    FOR             reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    PRINT           reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    READ            reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    STRING          reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    NEW             reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    THIS            reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    ID              reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    $               reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    (               reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    FLOAT           reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    INT             reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    $end            reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    }               reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)
    RETURN          reduce using rule 45 (if_block -> IF ( exp exp_evaluation ) block after_if_block ELSE block .)


state 221

    (30) func_block -> { statements return . }

    }               shift and go to state 224


state 222

    (49) return -> RETURN . exp ;
    (55) exp -> . read
    (56) exp -> . math_or
    (57) exp -> . assign
    (58) exp -> . string
    (59) exp -> . new
    (61) read -> . READ ( )
    (76) math_or -> . math_and math_or_alt
    (38) assign -> . var = exp
    (60) string -> . STRING
    (3) new -> . NEW constructor_call
    (79) math_and -> . math_comp math_and_alt
    (5) var -> . prop
    (6) var -> . declaration
    (82) math_comp -> . math_exp math_comp_alt
    (41) prop -> . THIS . ID
    (42) prop -> . ID . ID
    (43) prop -> . ID
    (2) declaration -> . $ attr
    (62) math_exp -> . term math_exp_alt
    (66) term -> . factor term_alt
    (71) factor -> . id
    (72) factor -> . number
    (73) factor -> . call
    (74) factor -> . ( math_or )
    (75) id -> . ID
    (52) number -> . FLOAT empty
    (53) number -> . INT
    (91) call -> . prop ( args )
    (92) call -> . stack_call
    (97) stack_call -> . ID . stack_method

    READ            shift and go to state 32
    STRING          shift and go to state 35
    NEW             shift and go to state 36
    THIS            shift and go to state 41
    ID              shift and go to state 42
    $               shift and go to state 43
    (               shift and go to state 21
    FLOAT           shift and go to state 48
    INT             shift and go to state 49

    exp                            shift and go to state 225
    read                           shift and go to state 27
    math_or                        shift and go to state 28
    assign                         shift and go to state 29
    string                         shift and go to state 30
    new                            shift and go to state 31
    math_and                       shift and go to state 33
    var                            shift and go to state 34
    math_comp                      shift and go to state 37
    prop                           shift and go to state 38
    declaration                    shift and go to state 39
    math_exp                       shift and go to state 40
    term                           shift and go to state 44
    factor                         shift and go to state 45
    id                             shift and go to state 46
    number                         shift and go to state 25
    call                           shift and go to state 47
    stack_call                     shift and go to state 50

state 223

    (50) return -> empty .

    }               reduce using rule 50 (return -> empty .)


state 224

    (30) func_block -> { statements return } .

    #               reduce using rule 30 (func_block -> { statements return } .)
    IF              reduce using rule 30 (func_block -> { statements return } .)
    WHILE           reduce using rule 30 (func_block -> { statements return } .)
    FOR             reduce using rule 30 (func_block -> { statements return } .)
    PRINT           reduce using rule 30 (func_block -> { statements return } .)
    READ            reduce using rule 30 (func_block -> { statements return } .)
    STRING          reduce using rule 30 (func_block -> { statements return } .)
    NEW             reduce using rule 30 (func_block -> { statements return } .)
    THIS            reduce using rule 30 (func_block -> { statements return } .)
    ID              reduce using rule 30 (func_block -> { statements return } .)
    $               reduce using rule 30 (func_block -> { statements return } .)
    (               reduce using rule 30 (func_block -> { statements return } .)
    FLOAT           reduce using rule 30 (func_block -> { statements return } .)
    INT             reduce using rule 30 (func_block -> { statements return } .)
    $end            reduce using rule 30 (func_block -> { statements return } .)
    }               reduce using rule 30 (func_block -> { statements return } .)


state 225

    (49) return -> RETURN exp . ;

    ;               shift and go to state 226


state 226

    (49) return -> RETURN exp ; .

    }               reduce using rule 49 (return -> RETURN exp ; .)

