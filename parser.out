Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> classes functions vars statements
Rule 2     vars -> var vars
Rule 3     vars -> empty
Rule 4     var -> $ attr init ;
Rule 5     attr -> ID : type
Rule 6     init -> = exp
Rule 7     init -> = NEW constructor_call
Rule 8     init -> empty
Rule 9     type -> INT_TYPE
Rule 10    type -> FLOAT_TYPE
Rule 11    type -> STRING_TYPE
Rule 12    type -> BOOLEAN_TYPE
Rule 13    type -> STACK
Rule 14    type -> ID check_class
Rule 15    return_type -> VOID
Rule 16    return_type -> type
Rule 17    classes -> class classes
Rule 18    classes -> empty
Rule 19    class -> @ ID inheritance scope_class class_block
Rule 20    inheritance -> < ID check_class >
Rule 21    inheritance -> empty
Rule 22    class_block -> { vars constructor functions }
Rule 23    constructor -> ~ ID params scope_constructor func_block
Rule 24    constructor -> empty
Rule 25    functions -> function functions
Rule 26    functions -> empty
Rule 27    function -> # ID neg_lookup : return_type params scope_function func_block
Rule 28    params -> ( attrs )
Rule 29    attrs -> attr attrs_alt
Rule 30    attrs -> empty
Rule 31    attrs_alt -> , attr attrs_alt
Rule 32    attrs_alt -> empty
Rule 33    func_block -> { vars statements return }
Rule 34    statements -> statement
Rule 35    statements -> empty
Rule 36    statement -> if_block
Rule 37    statement -> while_block
Rule 38    statement -> for_block
Rule 39    statement -> print_stmt
Rule 40    statement -> expr
Rule 41    assign -> prop = exp
Rule 42    constructor_call -> ID ( args )
Rule 43    prop -> THIS . ID
Rule 44    prop -> ID . ID
Rule 45    prop -> ID
Rule 46    if_block -> IF ( exp ) block
Rule 47    if_block -> IF ( exp ) block ELSE block
Rule 48    while_block -> WHILE ( exp ) block
Rule 49    for_block -> FOR number FOR_TO number SKIP number block
Rule 50    print_stmt -> PRINT ( exp ) ;
Rule 51    return -> RETURN exp ;
Rule 52    return -> empty
Rule 53    block -> { statements }
Rule 54    number -> FLOAT
Rule 55    number -> INT
Rule 56    expr -> exp ;
Rule 57    exp -> read
Rule 58    exp -> math_or
Rule 59    exp -> assign
Rule 60    exp -> string
Rule 61    string -> STRING
Rule 62    read -> READ ( read_type )
Rule 63    read_type -> INT_TYPE
Rule 64    read_type -> FLOAT_TYPE
Rule 65    read_type -> STRING_TYPE
Rule 66    math_exp -> term math_exp_alt
Rule 67    math_exp_alt -> + term new_quad math_exp_alt
Rule 68    math_exp_alt -> - term new_quad math_exp_alt
Rule 69    math_exp_alt -> empty
Rule 70    term -> factor term_alt
Rule 71    term_alt -> * factor new_quad term_alt
Rule 72    term_alt -> / factor new_quad term_alt
Rule 73    term_alt -> empty
Rule 74    new_quad -> empty
Rule 75    factor -> id
Rule 76    factor -> number
Rule 77    factor -> call
Rule 78    factor -> ( math_or )
Rule 79    id -> ID
Rule 80    math_or -> math_and math_or_alt
Rule 81    math_or_alt -> OR math_and new_quad math_or_alt
Rule 82    math_or_alt -> empty
Rule 83    math_and -> math_comp math_and_alt
Rule 84    math_and_alt -> AND math_comp new_quad math_and_alt
Rule 85    math_and_alt -> empty
Rule 86    math_comp -> math_exp math_comp_alt
Rule 87    math_comp_alt -> comparison_op math_exp new_quad
Rule 88    math_comp_alt -> empty
Rule 89    comparison_op -> <
Rule 90    comparison_op -> >
Rule 91    comparison_op -> EQ
Rule 92    comparison_op -> NE
Rule 93    comparison_op -> LE
Rule 94    comparison_op -> GE
Rule 95    call -> prop ( args )
Rule 96    call -> stack_call
Rule 97    args -> exp args_aux
Rule 98    args -> empty
Rule 99    args_aux -> , exp args_aux
Rule 100   args_aux -> empty
Rule 101   stack_call -> ID . stack_method
Rule 102   stack_method -> POP ( )
Rule 103   stack_method -> PUSH ( id )
Rule 104   stack_method -> PEEK ( )
Rule 105   empty -> <empty>
Rule 106   scope_class -> empty
Rule 107   scope_function -> empty
Rule 108   scope_constructor -> empty
Rule 109   check_class -> empty
Rule 110   neg_lookup -> empty

Terminals, with rules where they appear

#                    : 27
$                    : 4
(                    : 28 42 46 47 48 50 62 78 95 102 103 104
)                    : 28 42 46 47 48 50 62 78 95 102 103 104
*                    : 71
+                    : 67
,                    : 31 99
-                    : 68
.                    : 43 44 101
/                    : 72
:                    : 5 27
;                    : 4 50 51 56
<                    : 20 89
=                    : 6 7 41
>                    : 20 90
@                    : 19
AND                  : 84
BOOLEAN_TYPE         : 12
ELSE                 : 47
EQ                   : 91
FLOAT                : 54
FLOAT_TYPE           : 10 64
FOR                  : 49
FOR_TO               : 49
GE                   : 94
ID                   : 5 14 19 20 23 27 42 43 44 44 45 79 101
IF                   : 46 47
INT                  : 55
INT_TYPE             : 9 63
LE                   : 93
NE                   : 92
NEW                  : 7
OR                   : 81
PEEK                 : 104
POP                  : 102
PRINT                : 50
PUSH                 : 103
READ                 : 62
RETURN               : 51
SKIP                 : 49
STACK                : 13
STRING               : 61
STRING_TYPE          : 11 65
THIS                 : 43
VOID                 : 15
WHILE                : 48
error                : 
{                    : 22 33 53
}                    : 22 33 53
~                    : 23

Nonterminals, with rules where they appear

args                 : 42 95
args_aux             : 97 99
assign               : 59
attr                 : 4 29 31
attrs                : 28
attrs_alt            : 29 31
block                : 46 47 47 48 49
call                 : 77
check_class          : 14 20
class                : 17
class_block          : 19
classes              : 1 17
comparison_op        : 87
constructor          : 22
constructor_call     : 7
empty                : 3 8 18 21 24 26 30 32 35 52 69 73 74 82 85 88 98 100 106 107 108 109 110
exp                  : 6 41 46 47 48 50 51 56 97 99
expr                 : 40
factor               : 70 71 72
for_block            : 38
func_block           : 23 27
function             : 25
functions            : 1 22 25
id                   : 75 103
if_block             : 36
inheritance          : 19
init                 : 4
math_and             : 80 81
math_and_alt         : 83 84
math_comp            : 83 84
math_comp_alt        : 86
math_exp             : 86 87
math_exp_alt         : 66 67 68
math_or              : 58 78
math_or_alt          : 80 81
neg_lookup           : 27
new_quad             : 67 68 71 72 81 84 87
number               : 49 49 49 76
params               : 23 27
print_stmt           : 39
program              : 0
prop                 : 41 95
read                 : 57
read_type            : 62
return               : 33
return_type          : 27
scope_class          : 19
scope_constructor    : 23
scope_function       : 27
stack_call           : 96
stack_method         : 101
statement            : 34
statements           : 1 33 53
string               : 60
term                 : 66 67 68
term_alt             : 70 71 72
type                 : 5 16
var                  : 2
vars                 : 1 2 22 33
while_block          : 37

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . classes functions vars statements
    (17) classes -> . class classes
    (18) classes -> . empty
    (19) class -> . @ ID inheritance scope_class class_block
    (105) empty -> .

    @               shift and go to state 2
    #               reduce using rule 105 (empty -> .)
    $               reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    STRING          reduce using rule 105 (empty -> .)
    THIS            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    $end            reduce using rule 105 (empty -> .)

    program                        shift and go to state 1
    classes                        shift and go to state 3
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (19) class -> @ . ID inheritance scope_class class_block

    ID              shift and go to state 6


state 3

    (1) program -> classes . functions vars statements
    (25) functions -> . function functions
    (26) functions -> . empty
    (27) function -> . # ID neg_lookup : return_type params scope_function func_block
    (105) empty -> .

    #               shift and go to state 9
    $               reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    STRING          reduce using rule 105 (empty -> .)
    THIS            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    $end            reduce using rule 105 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 8
    empty                          shift and go to state 10

state 4

    (17) classes -> class . classes
    (17) classes -> . class classes
    (18) classes -> . empty
    (19) class -> . @ ID inheritance scope_class class_block
    (105) empty -> .

    @               shift and go to state 2
    #               reduce using rule 105 (empty -> .)
    $               reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    STRING          reduce using rule 105 (empty -> .)
    THIS            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    $end            reduce using rule 105 (empty -> .)

    classes                        shift and go to state 11
    class                          shift and go to state 4
    empty                          shift and go to state 5

state 5

    (18) classes -> empty .

    #               reduce using rule 18 (classes -> empty .)
    $               reduce using rule 18 (classes -> empty .)
    IF              reduce using rule 18 (classes -> empty .)
    WHILE           reduce using rule 18 (classes -> empty .)
    FOR             reduce using rule 18 (classes -> empty .)
    PRINT           reduce using rule 18 (classes -> empty .)
    READ            reduce using rule 18 (classes -> empty .)
    STRING          reduce using rule 18 (classes -> empty .)
    THIS            reduce using rule 18 (classes -> empty .)
    ID              reduce using rule 18 (classes -> empty .)
    (               reduce using rule 18 (classes -> empty .)
    FLOAT           reduce using rule 18 (classes -> empty .)
    INT             reduce using rule 18 (classes -> empty .)
    $end            reduce using rule 18 (classes -> empty .)


state 6

    (19) class -> @ ID . inheritance scope_class class_block
    (20) inheritance -> . < ID check_class >
    (21) inheritance -> . empty
    (105) empty -> .

    <               shift and go to state 13
    {               reduce using rule 105 (empty -> .)

    empty                          shift and go to state 14
    inheritance                    shift and go to state 12

state 7

    (25) functions -> function . functions
    (25) functions -> . function functions
    (26) functions -> . empty
    (27) function -> . # ID neg_lookup : return_type params scope_function func_block
    (105) empty -> .

    #               shift and go to state 9
    $               reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    STRING          reduce using rule 105 (empty -> .)
    THIS            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    $end            reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 15
    empty                          shift and go to state 10

state 8

    (1) program -> classes functions . vars statements
    (2) vars -> . var vars
    (3) vars -> . empty
    (4) var -> . $ attr init ;
    (105) empty -> .

    $               shift and go to state 16
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    STRING          reduce using rule 105 (empty -> .)
    THIS            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    $end            reduce using rule 105 (empty -> .)

    vars                           shift and go to state 17
    var                            shift and go to state 18
    empty                          shift and go to state 19

state 9

    (27) function -> # . ID neg_lookup : return_type params scope_function func_block

    ID              shift and go to state 20


state 10

    (26) functions -> empty .

    $               reduce using rule 26 (functions -> empty .)
    IF              reduce using rule 26 (functions -> empty .)
    WHILE           reduce using rule 26 (functions -> empty .)
    FOR             reduce using rule 26 (functions -> empty .)
    PRINT           reduce using rule 26 (functions -> empty .)
    READ            reduce using rule 26 (functions -> empty .)
    STRING          reduce using rule 26 (functions -> empty .)
    THIS            reduce using rule 26 (functions -> empty .)
    ID              reduce using rule 26 (functions -> empty .)
    (               reduce using rule 26 (functions -> empty .)
    FLOAT           reduce using rule 26 (functions -> empty .)
    INT             reduce using rule 26 (functions -> empty .)
    $end            reduce using rule 26 (functions -> empty .)
    }               reduce using rule 26 (functions -> empty .)


state 11

    (17) classes -> class classes .

    #               reduce using rule 17 (classes -> class classes .)
    $               reduce using rule 17 (classes -> class classes .)
    IF              reduce using rule 17 (classes -> class classes .)
    WHILE           reduce using rule 17 (classes -> class classes .)
    FOR             reduce using rule 17 (classes -> class classes .)
    PRINT           reduce using rule 17 (classes -> class classes .)
    READ            reduce using rule 17 (classes -> class classes .)
    STRING          reduce using rule 17 (classes -> class classes .)
    THIS            reduce using rule 17 (classes -> class classes .)
    ID              reduce using rule 17 (classes -> class classes .)
    (               reduce using rule 17 (classes -> class classes .)
    FLOAT           reduce using rule 17 (classes -> class classes .)
    INT             reduce using rule 17 (classes -> class classes .)
    $end            reduce using rule 17 (classes -> class classes .)


state 12

    (19) class -> @ ID inheritance . scope_class class_block
    (106) scope_class -> . empty
    (105) empty -> .

    {               reduce using rule 105 (empty -> .)

    scope_class                    shift and go to state 21
    empty                          shift and go to state 22

state 13

    (20) inheritance -> < . ID check_class >

    ID              shift and go to state 23


state 14

    (21) inheritance -> empty .

    {               reduce using rule 21 (inheritance -> empty .)


state 15

    (25) functions -> function functions .

    $               reduce using rule 25 (functions -> function functions .)
    IF              reduce using rule 25 (functions -> function functions .)
    WHILE           reduce using rule 25 (functions -> function functions .)
    FOR             reduce using rule 25 (functions -> function functions .)
    PRINT           reduce using rule 25 (functions -> function functions .)
    READ            reduce using rule 25 (functions -> function functions .)
    STRING          reduce using rule 25 (functions -> function functions .)
    THIS            reduce using rule 25 (functions -> function functions .)
    ID              reduce using rule 25 (functions -> function functions .)
    (               reduce using rule 25 (functions -> function functions .)
    FLOAT           reduce using rule 25 (functions -> function functions .)
    INT             reduce using rule 25 (functions -> function functions .)
    $end            reduce using rule 25 (functions -> function functions .)
    }               reduce using rule 25 (functions -> function functions .)


state 16

    (4) var -> $ . attr init ;
    (5) attr -> . ID : type

    ID              shift and go to state 24

    attr                           shift and go to state 25

state 17

    (1) program -> classes functions vars . statements
    (34) statements -> . statement
    (35) statements -> . empty
    (36) statement -> . if_block
    (37) statement -> . while_block
    (38) statement -> . for_block
    (39) statement -> . print_stmt
    (40) statement -> . expr
    (105) empty -> .
    (46) if_block -> . IF ( exp ) block
    (47) if_block -> . IF ( exp ) block ELSE block
    (48) while_block -> . WHILE ( exp ) block
    (49) for_block -> . FOR number FOR_TO number SKIP number block
    (50) print_stmt -> . PRINT ( exp ) ;
    (56) expr -> . exp ;
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    $end            reduce using rule 105 (empty -> .)
    IF              shift and go to state 51
    WHILE           shift and go to state 32
    FOR             shift and go to state 47
    PRINT           shift and go to state 34
    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    for_block                      shift and go to state 27
    statements                     shift and go to state 29
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    string                         shift and go to state 46
    math_exp                       shift and go to state 37
    prop                           shift and go to state 39
    read                           shift and go to state 40
    call                           shift and go to state 41
    statement                      shift and go to state 42
    factor                         shift and go to state 49
    empty                          shift and go to state 44
    math_and                       shift and go to state 45
    print_stmt                     shift and go to state 48
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    expr                           shift and go to state 54
    if_block                       shift and go to state 55
    while_block                    shift and go to state 57
    exp                            shift and go to state 58
    assign                         shift and go to state 59

state 18

    (2) vars -> var . vars
    (2) vars -> . var vars
    (3) vars -> . empty
    (4) var -> . $ attr init ;
    (105) empty -> .

    $               shift and go to state 16
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    STRING          reduce using rule 105 (empty -> .)
    THIS            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    $end            reduce using rule 105 (empty -> .)
    ~               reduce using rule 105 (empty -> .)
    #               reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    var                            shift and go to state 18
    empty                          shift and go to state 19
    vars                           shift and go to state 60

state 19

    (3) vars -> empty .

    ~               reduce using rule 3 (vars -> empty .)
    #               reduce using rule 3 (vars -> empty .)
    }               reduce using rule 3 (vars -> empty .)
    IF              reduce using rule 3 (vars -> empty .)
    WHILE           reduce using rule 3 (vars -> empty .)
    FOR             reduce using rule 3 (vars -> empty .)
    PRINT           reduce using rule 3 (vars -> empty .)
    READ            reduce using rule 3 (vars -> empty .)
    STRING          reduce using rule 3 (vars -> empty .)
    THIS            reduce using rule 3 (vars -> empty .)
    ID              reduce using rule 3 (vars -> empty .)
    (               reduce using rule 3 (vars -> empty .)
    FLOAT           reduce using rule 3 (vars -> empty .)
    INT             reduce using rule 3 (vars -> empty .)
    $end            reduce using rule 3 (vars -> empty .)
    RETURN          reduce using rule 3 (vars -> empty .)


state 20

    (27) function -> # ID . neg_lookup : return_type params scope_function func_block
    (110) neg_lookup -> . empty
    (105) empty -> .

    :               reduce using rule 105 (empty -> .)

    neg_lookup                     shift and go to state 61
    empty                          shift and go to state 62

state 21

    (19) class -> @ ID inheritance scope_class . class_block
    (22) class_block -> . { vars constructor functions }

    {               shift and go to state 64

    class_block                    shift and go to state 63

state 22

    (106) scope_class -> empty .

    {               reduce using rule 106 (scope_class -> empty .)


state 23

    (20) inheritance -> < ID . check_class >
    (109) check_class -> . empty
    (105) empty -> .

    >               reduce using rule 105 (empty -> .)

    empty                          shift and go to state 65
    check_class                    shift and go to state 66

state 24

    (5) attr -> ID . : type

    :               shift and go to state 67


state 25

    (4) var -> $ attr . init ;
    (6) init -> . = exp
    (7) init -> . = NEW constructor_call
    (8) init -> . empty
    (105) empty -> .

    =               shift and go to state 69
    ;               reduce using rule 105 (empty -> .)

    init                           shift and go to state 68
    empty                          shift and go to state 70

state 26

    (58) exp -> math_or .

    ,               reduce using rule 58 (exp -> math_or .)
    )               reduce using rule 58 (exp -> math_or .)
    ;               reduce using rule 58 (exp -> math_or .)


state 27

    (38) statement -> for_block .

    }               reduce using rule 38 (statement -> for_block .)
    $end            reduce using rule 38 (statement -> for_block .)
    RETURN          reduce using rule 38 (statement -> for_block .)


state 28

    (54) number -> FLOAT .

    FOR_TO          reduce using rule 54 (number -> FLOAT .)
    *               reduce using rule 54 (number -> FLOAT .)
    /               reduce using rule 54 (number -> FLOAT .)
    +               reduce using rule 54 (number -> FLOAT .)
    -               reduce using rule 54 (number -> FLOAT .)
    <               reduce using rule 54 (number -> FLOAT .)
    >               reduce using rule 54 (number -> FLOAT .)
    EQ              reduce using rule 54 (number -> FLOAT .)
    NE              reduce using rule 54 (number -> FLOAT .)
    LE              reduce using rule 54 (number -> FLOAT .)
    GE              reduce using rule 54 (number -> FLOAT .)
    AND             reduce using rule 54 (number -> FLOAT .)
    OR              reduce using rule 54 (number -> FLOAT .)
    ;               reduce using rule 54 (number -> FLOAT .)
    )               reduce using rule 54 (number -> FLOAT .)
    ,               reduce using rule 54 (number -> FLOAT .)
    SKIP            reduce using rule 54 (number -> FLOAT .)
    {               reduce using rule 54 (number -> FLOAT .)


state 29

    (1) program -> classes functions vars statements .

    $end            reduce using rule 1 (program -> classes functions vars statements .)


state 30

    (62) read -> READ . ( read_type )

    (               shift and go to state 71


state 31

    (76) factor -> number .

    *               reduce using rule 76 (factor -> number .)
    /               reduce using rule 76 (factor -> number .)
    +               reduce using rule 76 (factor -> number .)
    -               reduce using rule 76 (factor -> number .)
    AND             reduce using rule 76 (factor -> number .)
    OR              reduce using rule 76 (factor -> number .)
    ;               reduce using rule 76 (factor -> number .)
    )               reduce using rule 76 (factor -> number .)
    ,               reduce using rule 76 (factor -> number .)
    <               reduce using rule 76 (factor -> number .)
    >               reduce using rule 76 (factor -> number .)
    EQ              reduce using rule 76 (factor -> number .)
    NE              reduce using rule 76 (factor -> number .)
    LE              reduce using rule 76 (factor -> number .)
    GE              reduce using rule 76 (factor -> number .)


state 32

    (48) while_block -> WHILE . ( exp ) block

    (               shift and go to state 72


state 33

    (61) string -> STRING .

    )               reduce using rule 61 (string -> STRING .)
    ;               reduce using rule 61 (string -> STRING .)
    ,               reduce using rule 61 (string -> STRING .)


state 34

    (50) print_stmt -> PRINT . ( exp ) ;

    (               shift and go to state 73


state 35

    (96) call -> stack_call .

    *               reduce using rule 96 (call -> stack_call .)
    /               reduce using rule 96 (call -> stack_call .)
    +               reduce using rule 96 (call -> stack_call .)
    -               reduce using rule 96 (call -> stack_call .)
    <               reduce using rule 96 (call -> stack_call .)
    >               reduce using rule 96 (call -> stack_call .)
    EQ              reduce using rule 96 (call -> stack_call .)
    NE              reduce using rule 96 (call -> stack_call .)
    LE              reduce using rule 96 (call -> stack_call .)
    GE              reduce using rule 96 (call -> stack_call .)
    AND             reduce using rule 96 (call -> stack_call .)
    OR              reduce using rule 96 (call -> stack_call .)
    ,               reduce using rule 96 (call -> stack_call .)
    )               reduce using rule 96 (call -> stack_call .)
    ;               reduce using rule 96 (call -> stack_call .)


state 36

    (75) factor -> id .

    *               reduce using rule 75 (factor -> id .)
    /               reduce using rule 75 (factor -> id .)
    +               reduce using rule 75 (factor -> id .)
    -               reduce using rule 75 (factor -> id .)
    AND             reduce using rule 75 (factor -> id .)
    OR              reduce using rule 75 (factor -> id .)
    ;               reduce using rule 75 (factor -> id .)
    )               reduce using rule 75 (factor -> id .)
    ,               reduce using rule 75 (factor -> id .)
    <               reduce using rule 75 (factor -> id .)
    >               reduce using rule 75 (factor -> id .)
    EQ              reduce using rule 75 (factor -> id .)
    NE              reduce using rule 75 (factor -> id .)
    LE              reduce using rule 75 (factor -> id .)
    GE              reduce using rule 75 (factor -> id .)


state 37

    (86) math_comp -> math_exp . math_comp_alt
    (87) math_comp_alt -> . comparison_op math_exp new_quad
    (88) math_comp_alt -> . empty
    (89) comparison_op -> . <
    (90) comparison_op -> . >
    (91) comparison_op -> . EQ
    (92) comparison_op -> . NE
    (93) comparison_op -> . LE
    (94) comparison_op -> . GE
    (105) empty -> .

    <               shift and go to state 80
    >               shift and go to state 82
    EQ              shift and go to state 79
    NE              shift and go to state 76
    LE              shift and go to state 75
    GE              shift and go to state 78
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    math_comp_alt                  shift and go to state 77
    comparison_op                  shift and go to state 74
    empty                          shift and go to state 81

state 38

    (78) factor -> ( . math_or )
    (80) math_or -> . math_and math_or_alt
    (83) math_and -> . math_comp math_and_alt
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (101) stack_call -> . ID . stack_method

    (               shift and go to state 38
    ID              shift and go to state 85
    FLOAT           shift and go to state 28
    INT             shift and go to state 56
    THIS            shift and go to state 53

    math_or                        shift and go to state 83
    term                           shift and go to state 52
    math_and                       shift and go to state 45
    math_comp                      shift and go to state 43
    number                         shift and go to state 31
    prop                           shift and go to state 84
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    stack_call                     shift and go to state 35
    id                             shift and go to state 36

state 39

    (41) assign -> prop . = exp
    (95) call -> prop . ( args )

    =               shift and go to state 87
    (               shift and go to state 86


state 40

    (57) exp -> read .

    ,               reduce using rule 57 (exp -> read .)
    )               reduce using rule 57 (exp -> read .)
    ;               reduce using rule 57 (exp -> read .)


state 41

    (77) factor -> call .

    *               reduce using rule 77 (factor -> call .)
    /               reduce using rule 77 (factor -> call .)
    +               reduce using rule 77 (factor -> call .)
    -               reduce using rule 77 (factor -> call .)
    AND             reduce using rule 77 (factor -> call .)
    OR              reduce using rule 77 (factor -> call .)
    ;               reduce using rule 77 (factor -> call .)
    )               reduce using rule 77 (factor -> call .)
    ,               reduce using rule 77 (factor -> call .)
    <               reduce using rule 77 (factor -> call .)
    >               reduce using rule 77 (factor -> call .)
    EQ              reduce using rule 77 (factor -> call .)
    NE              reduce using rule 77 (factor -> call .)
    LE              reduce using rule 77 (factor -> call .)
    GE              reduce using rule 77 (factor -> call .)


state 42

    (34) statements -> statement .

    RETURN          reduce using rule 34 (statements -> statement .)
    }               reduce using rule 34 (statements -> statement .)
    $end            reduce using rule 34 (statements -> statement .)


state 43

    (83) math_and -> math_comp . math_and_alt
    (84) math_and_alt -> . AND math_comp new_quad math_and_alt
    (85) math_and_alt -> . empty
    (105) empty -> .

    AND             shift and go to state 88
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    math_and_alt                   shift and go to state 89
    empty                          shift and go to state 90

state 44

    (35) statements -> empty .

    RETURN          reduce using rule 35 (statements -> empty .)
    }               reduce using rule 35 (statements -> empty .)
    $end            reduce using rule 35 (statements -> empty .)


state 45

    (80) math_or -> math_and . math_or_alt
    (81) math_or_alt -> . OR math_and new_quad math_or_alt
    (82) math_or_alt -> . empty
    (105) empty -> .

    OR              shift and go to state 93
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    math_or_alt                    shift and go to state 91
    empty                          shift and go to state 92

state 46

    (60) exp -> string .

    ,               reduce using rule 60 (exp -> string .)
    )               reduce using rule 60 (exp -> string .)
    ;               reduce using rule 60 (exp -> string .)


state 47

    (49) for_block -> FOR . number FOR_TO number SKIP number block
    (54) number -> . FLOAT
    (55) number -> . INT

    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    number                         shift and go to state 94

state 48

    (39) statement -> print_stmt .

    }               reduce using rule 39 (statement -> print_stmt .)
    $end            reduce using rule 39 (statement -> print_stmt .)
    RETURN          reduce using rule 39 (statement -> print_stmt .)


state 49

    (70) term -> factor . term_alt
    (71) term_alt -> . * factor new_quad term_alt
    (72) term_alt -> . / factor new_quad term_alt
    (73) term_alt -> . empty
    (105) empty -> .

    *               shift and go to state 96
    /               shift and go to state 97
    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    empty                          shift and go to state 98
    term_alt                       shift and go to state 95

state 50

    (44) prop -> ID . . ID
    (45) prop -> ID .
    (79) id -> ID .
    (101) stack_call -> ID . . stack_method

    .               shift and go to state 99
    =               reduce using rule 45 (prop -> ID .)
    (               reduce using rule 45 (prop -> ID .)
    *               reduce using rule 79 (id -> ID .)
    /               reduce using rule 79 (id -> ID .)
    +               reduce using rule 79 (id -> ID .)
    -               reduce using rule 79 (id -> ID .)
    <               reduce using rule 79 (id -> ID .)
    >               reduce using rule 79 (id -> ID .)
    EQ              reduce using rule 79 (id -> ID .)
    NE              reduce using rule 79 (id -> ID .)
    LE              reduce using rule 79 (id -> ID .)
    GE              reduce using rule 79 (id -> ID .)
    AND             reduce using rule 79 (id -> ID .)
    OR              reduce using rule 79 (id -> ID .)
    )               reduce using rule 79 (id -> ID .)
    ,               reduce using rule 79 (id -> ID .)
    ;               reduce using rule 79 (id -> ID .)


state 51

    (46) if_block -> IF . ( exp ) block
    (47) if_block -> IF . ( exp ) block ELSE block

    (               shift and go to state 100


state 52

    (66) math_exp -> term . math_exp_alt
    (67) math_exp_alt -> . + term new_quad math_exp_alt
    (68) math_exp_alt -> . - term new_quad math_exp_alt
    (69) math_exp_alt -> . empty
    (105) empty -> .

    +               shift and go to state 103
    -               shift and go to state 102
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    math_exp_alt                   shift and go to state 101
    empty                          shift and go to state 104

state 53

    (43) prop -> THIS . . ID

    .               shift and go to state 105


state 54

    (40) statement -> expr .

    }               reduce using rule 40 (statement -> expr .)
    $end            reduce using rule 40 (statement -> expr .)
    RETURN          reduce using rule 40 (statement -> expr .)


state 55

    (36) statement -> if_block .

    }               reduce using rule 36 (statement -> if_block .)
    $end            reduce using rule 36 (statement -> if_block .)
    RETURN          reduce using rule 36 (statement -> if_block .)


state 56

    (55) number -> INT .

    FOR_TO          reduce using rule 55 (number -> INT .)
    *               reduce using rule 55 (number -> INT .)
    /               reduce using rule 55 (number -> INT .)
    +               reduce using rule 55 (number -> INT .)
    -               reduce using rule 55 (number -> INT .)
    <               reduce using rule 55 (number -> INT .)
    >               reduce using rule 55 (number -> INT .)
    EQ              reduce using rule 55 (number -> INT .)
    NE              reduce using rule 55 (number -> INT .)
    LE              reduce using rule 55 (number -> INT .)
    GE              reduce using rule 55 (number -> INT .)
    AND             reduce using rule 55 (number -> INT .)
    OR              reduce using rule 55 (number -> INT .)
    ;               reduce using rule 55 (number -> INT .)
    )               reduce using rule 55 (number -> INT .)
    ,               reduce using rule 55 (number -> INT .)
    SKIP            reduce using rule 55 (number -> INT .)
    {               reduce using rule 55 (number -> INT .)


state 57

    (37) statement -> while_block .

    }               reduce using rule 37 (statement -> while_block .)
    $end            reduce using rule 37 (statement -> while_block .)
    RETURN          reduce using rule 37 (statement -> while_block .)


state 58

    (56) expr -> exp . ;

    ;               shift and go to state 106


state 59

    (59) exp -> assign .

    ,               reduce using rule 59 (exp -> assign .)
    )               reduce using rule 59 (exp -> assign .)
    ;               reduce using rule 59 (exp -> assign .)


state 60

    (2) vars -> var vars .

    ~               reduce using rule 2 (vars -> var vars .)
    #               reduce using rule 2 (vars -> var vars .)
    }               reduce using rule 2 (vars -> var vars .)
    IF              reduce using rule 2 (vars -> var vars .)
    WHILE           reduce using rule 2 (vars -> var vars .)
    FOR             reduce using rule 2 (vars -> var vars .)
    PRINT           reduce using rule 2 (vars -> var vars .)
    READ            reduce using rule 2 (vars -> var vars .)
    STRING          reduce using rule 2 (vars -> var vars .)
    THIS            reduce using rule 2 (vars -> var vars .)
    ID              reduce using rule 2 (vars -> var vars .)
    (               reduce using rule 2 (vars -> var vars .)
    FLOAT           reduce using rule 2 (vars -> var vars .)
    INT             reduce using rule 2 (vars -> var vars .)
    $end            reduce using rule 2 (vars -> var vars .)
    RETURN          reduce using rule 2 (vars -> var vars .)


state 61

    (27) function -> # ID neg_lookup . : return_type params scope_function func_block

    :               shift and go to state 107


state 62

    (110) neg_lookup -> empty .

    :               reduce using rule 110 (neg_lookup -> empty .)


state 63

    (19) class -> @ ID inheritance scope_class class_block .

    @               reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    #               reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    $               reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    IF              reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    WHILE           reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    FOR             reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    PRINT           reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    READ            reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    STRING          reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    THIS            reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    ID              reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    (               reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    FLOAT           reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    INT             reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)
    $end            reduce using rule 19 (class -> @ ID inheritance scope_class class_block .)


state 64

    (22) class_block -> { . vars constructor functions }
    (2) vars -> . var vars
    (3) vars -> . empty
    (4) var -> . $ attr init ;
    (105) empty -> .

    $               shift and go to state 16
    ~               reduce using rule 105 (empty -> .)
    #               reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)

    vars                           shift and go to state 108
    var                            shift and go to state 18
    empty                          shift and go to state 19

state 65

    (109) check_class -> empty .

    =               reduce using rule 109 (check_class -> empty .)
    ;               reduce using rule 109 (check_class -> empty .)
    ,               reduce using rule 109 (check_class -> empty .)
    )               reduce using rule 109 (check_class -> empty .)
    (               reduce using rule 109 (check_class -> empty .)
    >               reduce using rule 109 (check_class -> empty .)


state 66

    (20) inheritance -> < ID check_class . >

    >               shift and go to state 109


state 67

    (5) attr -> ID : . type
    (9) type -> . INT_TYPE
    (10) type -> . FLOAT_TYPE
    (11) type -> . STRING_TYPE
    (12) type -> . BOOLEAN_TYPE
    (13) type -> . STACK
    (14) type -> . ID check_class

    INT_TYPE        shift and go to state 114
    FLOAT_TYPE      shift and go to state 110
    STRING_TYPE     shift and go to state 112
    BOOLEAN_TYPE    shift and go to state 111
    STACK           shift and go to state 113
    ID              shift and go to state 116

    type                           shift and go to state 115

state 68

    (4) var -> $ attr init . ;

    ;               shift and go to state 117


state 69

    (6) init -> = . exp
    (7) init -> = . NEW constructor_call
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    NEW             shift and go to state 118
    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    prop                           shift and go to state 39
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    math_and                       shift and go to state 45
    string                         shift and go to state 46
    read                           shift and go to state 40
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    exp                            shift and go to state 119
    assign                         shift and go to state 59

state 70

    (8) init -> empty .

    ;               reduce using rule 8 (init -> empty .)


state 71

    (62) read -> READ ( . read_type )
    (63) read_type -> . INT_TYPE
    (64) read_type -> . FLOAT_TYPE
    (65) read_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 122
    FLOAT_TYPE      shift and go to state 120
    STRING_TYPE     shift and go to state 121

    read_type                      shift and go to state 123

state 72

    (48) while_block -> WHILE ( . exp ) block
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    prop                           shift and go to state 39
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    math_and                       shift and go to state 45
    string                         shift and go to state 46
    read                           shift and go to state 40
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    exp                            shift and go to state 124
    assign                         shift and go to state 59

state 73

    (50) print_stmt -> PRINT ( . exp ) ;
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    prop                           shift and go to state 39
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    math_and                       shift and go to state 45
    string                         shift and go to state 46
    read                           shift and go to state 40
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    exp                            shift and go to state 125
    assign                         shift and go to state 59

state 74

    (87) math_comp_alt -> comparison_op . math_exp new_quad
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (101) stack_call -> . ID . stack_method

    (               shift and go to state 38
    ID              shift and go to state 85
    FLOAT           shift and go to state 28
    INT             shift and go to state 56
    THIS            shift and go to state 53

    term                           shift and go to state 52
    number                         shift and go to state 31
    call                           shift and go to state 41
    math_exp                       shift and go to state 126
    factor                         shift and go to state 49
    stack_call                     shift and go to state 35
    prop                           shift and go to state 84
    id                             shift and go to state 36

state 75

    (93) comparison_op -> LE .

    (               reduce using rule 93 (comparison_op -> LE .)
    ID              reduce using rule 93 (comparison_op -> LE .)
    FLOAT           reduce using rule 93 (comparison_op -> LE .)
    INT             reduce using rule 93 (comparison_op -> LE .)
    THIS            reduce using rule 93 (comparison_op -> LE .)


state 76

    (92) comparison_op -> NE .

    (               reduce using rule 92 (comparison_op -> NE .)
    ID              reduce using rule 92 (comparison_op -> NE .)
    FLOAT           reduce using rule 92 (comparison_op -> NE .)
    INT             reduce using rule 92 (comparison_op -> NE .)
    THIS            reduce using rule 92 (comparison_op -> NE .)


state 77

    (86) math_comp -> math_exp math_comp_alt .

    AND             reduce using rule 86 (math_comp -> math_exp math_comp_alt .)
    OR              reduce using rule 86 (math_comp -> math_exp math_comp_alt .)
    ;               reduce using rule 86 (math_comp -> math_exp math_comp_alt .)
    )               reduce using rule 86 (math_comp -> math_exp math_comp_alt .)
    ,               reduce using rule 86 (math_comp -> math_exp math_comp_alt .)


state 78

    (94) comparison_op -> GE .

    (               reduce using rule 94 (comparison_op -> GE .)
    ID              reduce using rule 94 (comparison_op -> GE .)
    FLOAT           reduce using rule 94 (comparison_op -> GE .)
    INT             reduce using rule 94 (comparison_op -> GE .)
    THIS            reduce using rule 94 (comparison_op -> GE .)


state 79

    (91) comparison_op -> EQ .

    (               reduce using rule 91 (comparison_op -> EQ .)
    ID              reduce using rule 91 (comparison_op -> EQ .)
    FLOAT           reduce using rule 91 (comparison_op -> EQ .)
    INT             reduce using rule 91 (comparison_op -> EQ .)
    THIS            reduce using rule 91 (comparison_op -> EQ .)


state 80

    (89) comparison_op -> < .

    (               reduce using rule 89 (comparison_op -> < .)
    ID              reduce using rule 89 (comparison_op -> < .)
    FLOAT           reduce using rule 89 (comparison_op -> < .)
    INT             reduce using rule 89 (comparison_op -> < .)
    THIS            reduce using rule 89 (comparison_op -> < .)


state 81

    (88) math_comp_alt -> empty .

    AND             reduce using rule 88 (math_comp_alt -> empty .)
    OR              reduce using rule 88 (math_comp_alt -> empty .)
    ;               reduce using rule 88 (math_comp_alt -> empty .)
    )               reduce using rule 88 (math_comp_alt -> empty .)
    ,               reduce using rule 88 (math_comp_alt -> empty .)


state 82

    (90) comparison_op -> > .

    (               reduce using rule 90 (comparison_op -> > .)
    ID              reduce using rule 90 (comparison_op -> > .)
    FLOAT           reduce using rule 90 (comparison_op -> > .)
    INT             reduce using rule 90 (comparison_op -> > .)
    THIS            reduce using rule 90 (comparison_op -> > .)


state 83

    (78) factor -> ( math_or . )

    )               shift and go to state 127


state 84

    (95) call -> prop . ( args )

    (               shift and go to state 86


state 85

    (79) id -> ID .
    (44) prop -> ID . . ID
    (45) prop -> ID .
    (101) stack_call -> ID . . stack_method

    *               reduce using rule 79 (id -> ID .)
    /               reduce using rule 79 (id -> ID .)
    +               reduce using rule 79 (id -> ID .)
    -               reduce using rule 79 (id -> ID .)
    <               reduce using rule 79 (id -> ID .)
    >               reduce using rule 79 (id -> ID .)
    EQ              reduce using rule 79 (id -> ID .)
    NE              reduce using rule 79 (id -> ID .)
    LE              reduce using rule 79 (id -> ID .)
    GE              reduce using rule 79 (id -> ID .)
    AND             reduce using rule 79 (id -> ID .)
    OR              reduce using rule 79 (id -> ID .)
    ;               reduce using rule 79 (id -> ID .)
    )               reduce using rule 79 (id -> ID .)
    ,               reduce using rule 79 (id -> ID .)
    .               shift and go to state 99
    (               reduce using rule 45 (prop -> ID .)


state 86

    (95) call -> prop ( . args )
    (97) args -> . exp args_aux
    (98) args -> . empty
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (105) empty -> .
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    )               reduce using rule 105 (empty -> .)
    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    prop                           shift and go to state 39
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    empty                          shift and go to state 128
    math_and                       shift and go to state 45
    string                         shift and go to state 46
    read                           shift and go to state 40
    math_comp                      shift and go to state 43
    args                           shift and go to state 129
    term                           shift and go to state 52
    exp                            shift and go to state 130
    assign                         shift and go to state 59

state 87

    (41) assign -> prop = . exp
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    prop                           shift and go to state 39
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    math_and                       shift and go to state 45
    string                         shift and go to state 46
    read                           shift and go to state 40
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    exp                            shift and go to state 131
    assign                         shift and go to state 59

state 88

    (84) math_and_alt -> AND . math_comp new_quad math_and_alt
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (101) stack_call -> . ID . stack_method

    (               shift and go to state 38
    ID              shift and go to state 85
    FLOAT           shift and go to state 28
    INT             shift and go to state 56
    THIS            shift and go to state 53

    term                           shift and go to state 52
    math_comp                      shift and go to state 132
    number                         shift and go to state 31
    prop                           shift and go to state 84
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    stack_call                     shift and go to state 35
    id                             shift and go to state 36

state 89

    (83) math_and -> math_comp math_and_alt .

    OR              reduce using rule 83 (math_and -> math_comp math_and_alt .)
    ;               reduce using rule 83 (math_and -> math_comp math_and_alt .)
    )               reduce using rule 83 (math_and -> math_comp math_and_alt .)
    ,               reduce using rule 83 (math_and -> math_comp math_and_alt .)


state 90

    (85) math_and_alt -> empty .

    OR              reduce using rule 85 (math_and_alt -> empty .)
    ;               reduce using rule 85 (math_and_alt -> empty .)
    )               reduce using rule 85 (math_and_alt -> empty .)
    ,               reduce using rule 85 (math_and_alt -> empty .)


state 91

    (80) math_or -> math_and math_or_alt .

    ;               reduce using rule 80 (math_or -> math_and math_or_alt .)
    )               reduce using rule 80 (math_or -> math_and math_or_alt .)
    ,               reduce using rule 80 (math_or -> math_and math_or_alt .)


state 92

    (82) math_or_alt -> empty .

    ;               reduce using rule 82 (math_or_alt -> empty .)
    )               reduce using rule 82 (math_or_alt -> empty .)
    ,               reduce using rule 82 (math_or_alt -> empty .)


state 93

    (81) math_or_alt -> OR . math_and new_quad math_or_alt
    (83) math_and -> . math_comp math_and_alt
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (101) stack_call -> . ID . stack_method

    (               shift and go to state 38
    ID              shift and go to state 85
    FLOAT           shift and go to state 28
    INT             shift and go to state 56
    THIS            shift and go to state 53

    term                           shift and go to state 52
    math_comp                      shift and go to state 43
    number                         shift and go to state 31
    prop                           shift and go to state 84
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    math_and                       shift and go to state 133
    stack_call                     shift and go to state 35
    id                             shift and go to state 36

state 94

    (49) for_block -> FOR number . FOR_TO number SKIP number block

    FOR_TO          shift and go to state 134


state 95

    (70) term -> factor term_alt .

    +               reduce using rule 70 (term -> factor term_alt .)
    -               reduce using rule 70 (term -> factor term_alt .)
    <               reduce using rule 70 (term -> factor term_alt .)
    >               reduce using rule 70 (term -> factor term_alt .)
    EQ              reduce using rule 70 (term -> factor term_alt .)
    NE              reduce using rule 70 (term -> factor term_alt .)
    LE              reduce using rule 70 (term -> factor term_alt .)
    GE              reduce using rule 70 (term -> factor term_alt .)
    AND             reduce using rule 70 (term -> factor term_alt .)
    OR              reduce using rule 70 (term -> factor term_alt .)
    ;               reduce using rule 70 (term -> factor term_alt .)
    )               reduce using rule 70 (term -> factor term_alt .)
    ,               reduce using rule 70 (term -> factor term_alt .)


state 96

    (71) term_alt -> * . factor new_quad term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (101) stack_call -> . ID . stack_method

    (               shift and go to state 38
    ID              shift and go to state 85
    FLOAT           shift and go to state 28
    INT             shift and go to state 56
    THIS            shift and go to state 53

    number                         shift and go to state 31
    prop                           shift and go to state 84
    call                           shift and go to state 41
    factor                         shift and go to state 135
    stack_call                     shift and go to state 35
    id                             shift and go to state 36

state 97

    (72) term_alt -> / . factor new_quad term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (101) stack_call -> . ID . stack_method

    (               shift and go to state 38
    ID              shift and go to state 85
    FLOAT           shift and go to state 28
    INT             shift and go to state 56
    THIS            shift and go to state 53

    number                         shift and go to state 31
    prop                           shift and go to state 84
    call                           shift and go to state 41
    factor                         shift and go to state 136
    stack_call                     shift and go to state 35
    id                             shift and go to state 36

state 98

    (73) term_alt -> empty .

    +               reduce using rule 73 (term_alt -> empty .)
    -               reduce using rule 73 (term_alt -> empty .)
    <               reduce using rule 73 (term_alt -> empty .)
    >               reduce using rule 73 (term_alt -> empty .)
    EQ              reduce using rule 73 (term_alt -> empty .)
    NE              reduce using rule 73 (term_alt -> empty .)
    LE              reduce using rule 73 (term_alt -> empty .)
    GE              reduce using rule 73 (term_alt -> empty .)
    AND             reduce using rule 73 (term_alt -> empty .)
    OR              reduce using rule 73 (term_alt -> empty .)
    ;               reduce using rule 73 (term_alt -> empty .)
    )               reduce using rule 73 (term_alt -> empty .)
    ,               reduce using rule 73 (term_alt -> empty .)


state 99

    (44) prop -> ID . . ID
    (101) stack_call -> ID . . stack_method
    (102) stack_method -> . POP ( )
    (103) stack_method -> . PUSH ( id )
    (104) stack_method -> . PEEK ( )

    ID              shift and go to state 141
    POP             shift and go to state 139
    PUSH            shift and go to state 140
    PEEK            shift and go to state 137

    stack_method                   shift and go to state 138

state 100

    (46) if_block -> IF ( . exp ) block
    (47) if_block -> IF ( . exp ) block ELSE block
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    prop                           shift and go to state 39
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    math_and                       shift and go to state 45
    string                         shift and go to state 46
    read                           shift and go to state 40
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    exp                            shift and go to state 142
    assign                         shift and go to state 59

state 101

    (66) math_exp -> term math_exp_alt .

    <               reduce using rule 66 (math_exp -> term math_exp_alt .)
    >               reduce using rule 66 (math_exp -> term math_exp_alt .)
    EQ              reduce using rule 66 (math_exp -> term math_exp_alt .)
    NE              reduce using rule 66 (math_exp -> term math_exp_alt .)
    LE              reduce using rule 66 (math_exp -> term math_exp_alt .)
    GE              reduce using rule 66 (math_exp -> term math_exp_alt .)
    AND             reduce using rule 66 (math_exp -> term math_exp_alt .)
    OR              reduce using rule 66 (math_exp -> term math_exp_alt .)
    ,               reduce using rule 66 (math_exp -> term math_exp_alt .)
    )               reduce using rule 66 (math_exp -> term math_exp_alt .)
    ;               reduce using rule 66 (math_exp -> term math_exp_alt .)


state 102

    (68) math_exp_alt -> - . term new_quad math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (101) stack_call -> . ID . stack_method

    (               shift and go to state 38
    ID              shift and go to state 85
    FLOAT           shift and go to state 28
    INT             shift and go to state 56
    THIS            shift and go to state 53

    term                           shift and go to state 143
    number                         shift and go to state 31
    prop                           shift and go to state 84
    call                           shift and go to state 41
    factor                         shift and go to state 49
    stack_call                     shift and go to state 35
    id                             shift and go to state 36

state 103

    (67) math_exp_alt -> + . term new_quad math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (101) stack_call -> . ID . stack_method

    (               shift and go to state 38
    ID              shift and go to state 85
    FLOAT           shift and go to state 28
    INT             shift and go to state 56
    THIS            shift and go to state 53

    term                           shift and go to state 144
    number                         shift and go to state 31
    prop                           shift and go to state 84
    call                           shift and go to state 41
    factor                         shift and go to state 49
    stack_call                     shift and go to state 35
    id                             shift and go to state 36

state 104

    (69) math_exp_alt -> empty .

    <               reduce using rule 69 (math_exp_alt -> empty .)
    >               reduce using rule 69 (math_exp_alt -> empty .)
    EQ              reduce using rule 69 (math_exp_alt -> empty .)
    NE              reduce using rule 69 (math_exp_alt -> empty .)
    LE              reduce using rule 69 (math_exp_alt -> empty .)
    GE              reduce using rule 69 (math_exp_alt -> empty .)
    AND             reduce using rule 69 (math_exp_alt -> empty .)
    OR              reduce using rule 69 (math_exp_alt -> empty .)
    ;               reduce using rule 69 (math_exp_alt -> empty .)
    )               reduce using rule 69 (math_exp_alt -> empty .)
    ,               reduce using rule 69 (math_exp_alt -> empty .)


state 105

    (43) prop -> THIS . . ID

    ID              shift and go to state 145


state 106

    (56) expr -> exp ; .

    RETURN          reduce using rule 56 (expr -> exp ; .)
    }               reduce using rule 56 (expr -> exp ; .)
    $end            reduce using rule 56 (expr -> exp ; .)


state 107

    (27) function -> # ID neg_lookup : . return_type params scope_function func_block
    (15) return_type -> . VOID
    (16) return_type -> . type
    (9) type -> . INT_TYPE
    (10) type -> . FLOAT_TYPE
    (11) type -> . STRING_TYPE
    (12) type -> . BOOLEAN_TYPE
    (13) type -> . STACK
    (14) type -> . ID check_class

    VOID            shift and go to state 146
    INT_TYPE        shift and go to state 114
    FLOAT_TYPE      shift and go to state 110
    STRING_TYPE     shift and go to state 112
    BOOLEAN_TYPE    shift and go to state 111
    STACK           shift and go to state 113
    ID              shift and go to state 116

    return_type                    shift and go to state 147
    type                           shift and go to state 148

state 108

    (22) class_block -> { vars . constructor functions }
    (23) constructor -> . ~ ID params scope_constructor func_block
    (24) constructor -> . empty
    (105) empty -> .

    ~               shift and go to state 151
    #               reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)

    constructor                    shift and go to state 149
    empty                          shift and go to state 150

state 109

    (20) inheritance -> < ID check_class > .

    {               reduce using rule 20 (inheritance -> < ID check_class > .)


state 110

    (10) type -> FLOAT_TYPE .

    (               reduce using rule 10 (type -> FLOAT_TYPE .)
    =               reduce using rule 10 (type -> FLOAT_TYPE .)
    ;               reduce using rule 10 (type -> FLOAT_TYPE .)
    ,               reduce using rule 10 (type -> FLOAT_TYPE .)
    )               reduce using rule 10 (type -> FLOAT_TYPE .)


state 111

    (12) type -> BOOLEAN_TYPE .

    (               reduce using rule 12 (type -> BOOLEAN_TYPE .)
    =               reduce using rule 12 (type -> BOOLEAN_TYPE .)
    ;               reduce using rule 12 (type -> BOOLEAN_TYPE .)
    ,               reduce using rule 12 (type -> BOOLEAN_TYPE .)
    )               reduce using rule 12 (type -> BOOLEAN_TYPE .)


state 112

    (11) type -> STRING_TYPE .

    (               reduce using rule 11 (type -> STRING_TYPE .)
    =               reduce using rule 11 (type -> STRING_TYPE .)
    ;               reduce using rule 11 (type -> STRING_TYPE .)
    ,               reduce using rule 11 (type -> STRING_TYPE .)
    )               reduce using rule 11 (type -> STRING_TYPE .)


state 113

    (13) type -> STACK .

    (               reduce using rule 13 (type -> STACK .)
    =               reduce using rule 13 (type -> STACK .)
    ;               reduce using rule 13 (type -> STACK .)
    ,               reduce using rule 13 (type -> STACK .)
    )               reduce using rule 13 (type -> STACK .)


state 114

    (9) type -> INT_TYPE .

    (               reduce using rule 9 (type -> INT_TYPE .)
    =               reduce using rule 9 (type -> INT_TYPE .)
    ;               reduce using rule 9 (type -> INT_TYPE .)
    ,               reduce using rule 9 (type -> INT_TYPE .)
    )               reduce using rule 9 (type -> INT_TYPE .)


state 115

    (5) attr -> ID : type .

    ,               reduce using rule 5 (attr -> ID : type .)
    )               reduce using rule 5 (attr -> ID : type .)
    =               reduce using rule 5 (attr -> ID : type .)
    ;               reduce using rule 5 (attr -> ID : type .)


state 116

    (14) type -> ID . check_class
    (109) check_class -> . empty
    (105) empty -> .

    =               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)

    empty                          shift and go to state 65
    check_class                    shift and go to state 152

state 117

    (4) var -> $ attr init ; .

    $               reduce using rule 4 (var -> $ attr init ; .)
    ~               reduce using rule 4 (var -> $ attr init ; .)
    #               reduce using rule 4 (var -> $ attr init ; .)
    }               reduce using rule 4 (var -> $ attr init ; .)
    IF              reduce using rule 4 (var -> $ attr init ; .)
    WHILE           reduce using rule 4 (var -> $ attr init ; .)
    FOR             reduce using rule 4 (var -> $ attr init ; .)
    PRINT           reduce using rule 4 (var -> $ attr init ; .)
    READ            reduce using rule 4 (var -> $ attr init ; .)
    STRING          reduce using rule 4 (var -> $ attr init ; .)
    THIS            reduce using rule 4 (var -> $ attr init ; .)
    ID              reduce using rule 4 (var -> $ attr init ; .)
    (               reduce using rule 4 (var -> $ attr init ; .)
    FLOAT           reduce using rule 4 (var -> $ attr init ; .)
    INT             reduce using rule 4 (var -> $ attr init ; .)
    RETURN          reduce using rule 4 (var -> $ attr init ; .)
    $end            reduce using rule 4 (var -> $ attr init ; .)


state 118

    (7) init -> = NEW . constructor_call
    (42) constructor_call -> . ID ( args )

    ID              shift and go to state 154

    constructor_call               shift and go to state 153

state 119

    (6) init -> = exp .

    ;               reduce using rule 6 (init -> = exp .)


state 120

    (64) read_type -> FLOAT_TYPE .

    )               reduce using rule 64 (read_type -> FLOAT_TYPE .)


state 121

    (65) read_type -> STRING_TYPE .

    )               reduce using rule 65 (read_type -> STRING_TYPE .)


state 122

    (63) read_type -> INT_TYPE .

    )               reduce using rule 63 (read_type -> INT_TYPE .)


state 123

    (62) read -> READ ( read_type . )

    )               shift and go to state 155


state 124

    (48) while_block -> WHILE ( exp . ) block

    )               shift and go to state 156


state 125

    (50) print_stmt -> PRINT ( exp . ) ;

    )               shift and go to state 157


state 126

    (87) math_comp_alt -> comparison_op math_exp . new_quad
    (74) new_quad -> . empty
    (105) empty -> .

    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    new_quad                       shift and go to state 158
    empty                          shift and go to state 159

state 127

    (78) factor -> ( math_or ) .

    *               reduce using rule 78 (factor -> ( math_or ) .)
    /               reduce using rule 78 (factor -> ( math_or ) .)
    +               reduce using rule 78 (factor -> ( math_or ) .)
    -               reduce using rule 78 (factor -> ( math_or ) .)
    AND             reduce using rule 78 (factor -> ( math_or ) .)
    OR              reduce using rule 78 (factor -> ( math_or ) .)
    ;               reduce using rule 78 (factor -> ( math_or ) .)
    )               reduce using rule 78 (factor -> ( math_or ) .)
    ,               reduce using rule 78 (factor -> ( math_or ) .)
    <               reduce using rule 78 (factor -> ( math_or ) .)
    >               reduce using rule 78 (factor -> ( math_or ) .)
    EQ              reduce using rule 78 (factor -> ( math_or ) .)
    NE              reduce using rule 78 (factor -> ( math_or ) .)
    LE              reduce using rule 78 (factor -> ( math_or ) .)
    GE              reduce using rule 78 (factor -> ( math_or ) .)


state 128

    (98) args -> empty .

    )               reduce using rule 98 (args -> empty .)


state 129

    (95) call -> prop ( args . )

    )               shift and go to state 160


state 130

    (97) args -> exp . args_aux
    (99) args_aux -> . , exp args_aux
    (100) args_aux -> . empty
    (105) empty -> .

    ,               shift and go to state 163
    )               reduce using rule 105 (empty -> .)

    args_aux                       shift and go to state 161
    empty                          shift and go to state 162

state 131

    (41) assign -> prop = exp .

    ;               reduce using rule 41 (assign -> prop = exp .)
    ,               reduce using rule 41 (assign -> prop = exp .)
    )               reduce using rule 41 (assign -> prop = exp .)


state 132

    (84) math_and_alt -> AND math_comp . new_quad math_and_alt
    (74) new_quad -> . empty
    (105) empty -> .

    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    new_quad                       shift and go to state 164
    empty                          shift and go to state 159

state 133

    (81) math_or_alt -> OR math_and . new_quad math_or_alt
    (74) new_quad -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    new_quad                       shift and go to state 165
    empty                          shift and go to state 159

state 134

    (49) for_block -> FOR number FOR_TO . number SKIP number block
    (54) number -> . FLOAT
    (55) number -> . INT

    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    number                         shift and go to state 166

state 135

    (71) term_alt -> * factor . new_quad term_alt
    (74) new_quad -> . empty
    (105) empty -> .

    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    new_quad                       shift and go to state 167
    empty                          shift and go to state 159

state 136

    (72) term_alt -> / factor . new_quad term_alt
    (74) new_quad -> . empty
    (105) empty -> .

    *               reduce using rule 105 (empty -> .)
    /               reduce using rule 105 (empty -> .)
    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    new_quad                       shift and go to state 168
    empty                          shift and go to state 159

state 137

    (104) stack_method -> PEEK . ( )

    (               shift and go to state 169


state 138

    (101) stack_call -> ID . stack_method .

    *               reduce using rule 101 (stack_call -> ID . stack_method .)
    /               reduce using rule 101 (stack_call -> ID . stack_method .)
    +               reduce using rule 101 (stack_call -> ID . stack_method .)
    -               reduce using rule 101 (stack_call -> ID . stack_method .)
    <               reduce using rule 101 (stack_call -> ID . stack_method .)
    >               reduce using rule 101 (stack_call -> ID . stack_method .)
    EQ              reduce using rule 101 (stack_call -> ID . stack_method .)
    NE              reduce using rule 101 (stack_call -> ID . stack_method .)
    LE              reduce using rule 101 (stack_call -> ID . stack_method .)
    GE              reduce using rule 101 (stack_call -> ID . stack_method .)
    AND             reduce using rule 101 (stack_call -> ID . stack_method .)
    OR              reduce using rule 101 (stack_call -> ID . stack_method .)
    )               reduce using rule 101 (stack_call -> ID . stack_method .)
    ;               reduce using rule 101 (stack_call -> ID . stack_method .)
    ,               reduce using rule 101 (stack_call -> ID . stack_method .)


state 139

    (102) stack_method -> POP . ( )

    (               shift and go to state 170


state 140

    (103) stack_method -> PUSH . ( id )

    (               shift and go to state 171


state 141

    (44) prop -> ID . ID .

    (               reduce using rule 44 (prop -> ID . ID .)
    =               reduce using rule 44 (prop -> ID . ID .)


state 142

    (46) if_block -> IF ( exp . ) block
    (47) if_block -> IF ( exp . ) block ELSE block

    )               shift and go to state 172


state 143

    (68) math_exp_alt -> - term . new_quad math_exp_alt
    (74) new_quad -> . empty
    (105) empty -> .

    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    new_quad                       shift and go to state 173
    empty                          shift and go to state 159

state 144

    (67) math_exp_alt -> + term . new_quad math_exp_alt
    (74) new_quad -> . empty
    (105) empty -> .

    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    new_quad                       shift and go to state 174
    empty                          shift and go to state 159

state 145

    (43) prop -> THIS . ID .

    (               reduce using rule 43 (prop -> THIS . ID .)
    =               reduce using rule 43 (prop -> THIS . ID .)


state 146

    (15) return_type -> VOID .

    (               reduce using rule 15 (return_type -> VOID .)


state 147

    (27) function -> # ID neg_lookup : return_type . params scope_function func_block
    (28) params -> . ( attrs )

    (               shift and go to state 176

    params                         shift and go to state 175

state 148

    (16) return_type -> type .

    (               reduce using rule 16 (return_type -> type .)


state 149

    (22) class_block -> { vars constructor . functions }
    (25) functions -> . function functions
    (26) functions -> . empty
    (27) function -> . # ID neg_lookup : return_type params scope_function func_block
    (105) empty -> .

    #               shift and go to state 9
    }               reduce using rule 105 (empty -> .)

    function                       shift and go to state 7
    functions                      shift and go to state 177
    empty                          shift and go to state 10

state 150

    (24) constructor -> empty .

    #               reduce using rule 24 (constructor -> empty .)
    }               reduce using rule 24 (constructor -> empty .)


state 151

    (23) constructor -> ~ . ID params scope_constructor func_block

    ID              shift and go to state 178


state 152

    (14) type -> ID check_class .

    (               reduce using rule 14 (type -> ID check_class .)
    =               reduce using rule 14 (type -> ID check_class .)
    ;               reduce using rule 14 (type -> ID check_class .)
    ,               reduce using rule 14 (type -> ID check_class .)
    )               reduce using rule 14 (type -> ID check_class .)


state 153

    (7) init -> = NEW constructor_call .

    ;               reduce using rule 7 (init -> = NEW constructor_call .)


state 154

    (42) constructor_call -> ID . ( args )

    (               shift and go to state 179


state 155

    (62) read -> READ ( read_type ) .

    ,               reduce using rule 62 (read -> READ ( read_type ) .)
    )               reduce using rule 62 (read -> READ ( read_type ) .)
    ;               reduce using rule 62 (read -> READ ( read_type ) .)


state 156

    (48) while_block -> WHILE ( exp ) . block
    (53) block -> . { statements }

    {               shift and go to state 180

    block                          shift and go to state 181

state 157

    (50) print_stmt -> PRINT ( exp ) . ;

    ;               shift and go to state 182


state 158

    (87) math_comp_alt -> comparison_op math_exp new_quad .

    AND             reduce using rule 87 (math_comp_alt -> comparison_op math_exp new_quad .)
    OR              reduce using rule 87 (math_comp_alt -> comparison_op math_exp new_quad .)
    ;               reduce using rule 87 (math_comp_alt -> comparison_op math_exp new_quad .)
    )               reduce using rule 87 (math_comp_alt -> comparison_op math_exp new_quad .)
    ,               reduce using rule 87 (math_comp_alt -> comparison_op math_exp new_quad .)


state 159

    (74) new_quad -> empty .

    +               reduce using rule 74 (new_quad -> empty .)
    -               reduce using rule 74 (new_quad -> empty .)
    <               reduce using rule 74 (new_quad -> empty .)
    >               reduce using rule 74 (new_quad -> empty .)
    EQ              reduce using rule 74 (new_quad -> empty .)
    NE              reduce using rule 74 (new_quad -> empty .)
    LE              reduce using rule 74 (new_quad -> empty .)
    GE              reduce using rule 74 (new_quad -> empty .)
    AND             reduce using rule 74 (new_quad -> empty .)
    OR              reduce using rule 74 (new_quad -> empty .)
    ;               reduce using rule 74 (new_quad -> empty .)
    )               reduce using rule 74 (new_quad -> empty .)
    ,               reduce using rule 74 (new_quad -> empty .)
    *               reduce using rule 74 (new_quad -> empty .)
    /               reduce using rule 74 (new_quad -> empty .)


state 160

    (95) call -> prop ( args ) .

    *               reduce using rule 95 (call -> prop ( args ) .)
    /               reduce using rule 95 (call -> prop ( args ) .)
    +               reduce using rule 95 (call -> prop ( args ) .)
    -               reduce using rule 95 (call -> prop ( args ) .)
    <               reduce using rule 95 (call -> prop ( args ) .)
    >               reduce using rule 95 (call -> prop ( args ) .)
    EQ              reduce using rule 95 (call -> prop ( args ) .)
    NE              reduce using rule 95 (call -> prop ( args ) .)
    LE              reduce using rule 95 (call -> prop ( args ) .)
    GE              reduce using rule 95 (call -> prop ( args ) .)
    AND             reduce using rule 95 (call -> prop ( args ) .)
    OR              reduce using rule 95 (call -> prop ( args ) .)
    ,               reduce using rule 95 (call -> prop ( args ) .)
    )               reduce using rule 95 (call -> prop ( args ) .)
    ;               reduce using rule 95 (call -> prop ( args ) .)


state 161

    (97) args -> exp args_aux .

    )               reduce using rule 97 (args -> exp args_aux .)


state 162

    (100) args_aux -> empty .

    )               reduce using rule 100 (args_aux -> empty .)


state 163

    (99) args_aux -> , . exp args_aux
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    prop                           shift and go to state 39
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    math_and                       shift and go to state 45
    string                         shift and go to state 46
    read                           shift and go to state 40
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    exp                            shift and go to state 183
    assign                         shift and go to state 59

state 164

    (84) math_and_alt -> AND math_comp new_quad . math_and_alt
    (84) math_and_alt -> . AND math_comp new_quad math_and_alt
    (85) math_and_alt -> . empty
    (105) empty -> .

    AND             shift and go to state 88
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    math_and_alt                   shift and go to state 184
    empty                          shift and go to state 90

state 165

    (81) math_or_alt -> OR math_and new_quad . math_or_alt
    (81) math_or_alt -> . OR math_and new_quad math_or_alt
    (82) math_or_alt -> . empty
    (105) empty -> .

    OR              shift and go to state 93
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    math_or_alt                    shift and go to state 185
    empty                          shift and go to state 92

state 166

    (49) for_block -> FOR number FOR_TO number . SKIP number block

    SKIP            shift and go to state 186


state 167

    (71) term_alt -> * factor new_quad . term_alt
    (71) term_alt -> . * factor new_quad term_alt
    (72) term_alt -> . / factor new_quad term_alt
    (73) term_alt -> . empty
    (105) empty -> .

    *               shift and go to state 96
    /               shift and go to state 97
    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    empty                          shift and go to state 98
    term_alt                       shift and go to state 187

state 168

    (72) term_alt -> / factor new_quad . term_alt
    (71) term_alt -> . * factor new_quad term_alt
    (72) term_alt -> . / factor new_quad term_alt
    (73) term_alt -> . empty
    (105) empty -> .

    *               shift and go to state 96
    /               shift and go to state 97
    +               reduce using rule 105 (empty -> .)
    -               reduce using rule 105 (empty -> .)
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    empty                          shift and go to state 98
    term_alt                       shift and go to state 188

state 169

    (104) stack_method -> PEEK ( . )

    )               shift and go to state 189


state 170

    (102) stack_method -> POP ( . )

    )               shift and go to state 190


state 171

    (103) stack_method -> PUSH ( . id )
    (79) id -> . ID

    ID              shift and go to state 192

    id                             shift and go to state 191

state 172

    (46) if_block -> IF ( exp ) . block
    (47) if_block -> IF ( exp ) . block ELSE block
    (53) block -> . { statements }

    {               shift and go to state 180

    block                          shift and go to state 193

state 173

    (68) math_exp_alt -> - term new_quad . math_exp_alt
    (67) math_exp_alt -> . + term new_quad math_exp_alt
    (68) math_exp_alt -> . - term new_quad math_exp_alt
    (69) math_exp_alt -> . empty
    (105) empty -> .

    +               shift and go to state 103
    -               shift and go to state 102
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    math_exp_alt                   shift and go to state 194
    empty                          shift and go to state 104

state 174

    (67) math_exp_alt -> + term new_quad . math_exp_alt
    (67) math_exp_alt -> . + term new_quad math_exp_alt
    (68) math_exp_alt -> . - term new_quad math_exp_alt
    (69) math_exp_alt -> . empty
    (105) empty -> .

    +               shift and go to state 103
    -               shift and go to state 102
    <               reduce using rule 105 (empty -> .)
    >               reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)

    math_exp_alt                   shift and go to state 195
    empty                          shift and go to state 104

state 175

    (27) function -> # ID neg_lookup : return_type params . scope_function func_block
    (107) scope_function -> . empty
    (105) empty -> .

    {               reduce using rule 105 (empty -> .)

    scope_function                 shift and go to state 196
    empty                          shift and go to state 197

state 176

    (28) params -> ( . attrs )
    (29) attrs -> . attr attrs_alt
    (30) attrs -> . empty
    (5) attr -> . ID : type
    (105) empty -> .

    ID              shift and go to state 24
    )               reduce using rule 105 (empty -> .)

    attrs                          shift and go to state 198
    empty                          shift and go to state 199
    attr                           shift and go to state 200

state 177

    (22) class_block -> { vars constructor functions . }

    }               shift and go to state 201


state 178

    (23) constructor -> ~ ID . params scope_constructor func_block
    (28) params -> . ( attrs )

    (               shift and go to state 176

    params                         shift and go to state 202

state 179

    (42) constructor_call -> ID ( . args )
    (97) args -> . exp args_aux
    (98) args -> . empty
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (105) empty -> .
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    )               reduce using rule 105 (empty -> .)
    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    prop                           shift and go to state 39
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    empty                          shift and go to state 128
    math_and                       shift and go to state 45
    string                         shift and go to state 46
    read                           shift and go to state 40
    math_comp                      shift and go to state 43
    args                           shift and go to state 203
    term                           shift and go to state 52
    exp                            shift and go to state 130
    assign                         shift and go to state 59

state 180

    (53) block -> { . statements }
    (34) statements -> . statement
    (35) statements -> . empty
    (36) statement -> . if_block
    (37) statement -> . while_block
    (38) statement -> . for_block
    (39) statement -> . print_stmt
    (40) statement -> . expr
    (105) empty -> .
    (46) if_block -> . IF ( exp ) block
    (47) if_block -> . IF ( exp ) block ELSE block
    (48) while_block -> . WHILE ( exp ) block
    (49) for_block -> . FOR number FOR_TO number SKIP number block
    (50) print_stmt -> . PRINT ( exp ) ;
    (56) expr -> . exp ;
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    }               reduce using rule 105 (empty -> .)
    IF              shift and go to state 51
    WHILE           shift and go to state 32
    FOR             shift and go to state 47
    PRINT           shift and go to state 34
    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    for_block                      shift and go to state 27
    statements                     shift and go to state 204
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    string                         shift and go to state 46
    prop                           shift and go to state 39
    read                           shift and go to state 40
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    empty                          shift and go to state 44
    math_and                       shift and go to state 45
    print_stmt                     shift and go to state 48
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    expr                           shift and go to state 54
    if_block                       shift and go to state 55
    while_block                    shift and go to state 57
    statement                      shift and go to state 42
    exp                            shift and go to state 58
    assign                         shift and go to state 59

state 181

    (48) while_block -> WHILE ( exp ) block .

    $end            reduce using rule 48 (while_block -> WHILE ( exp ) block .)
    RETURN          reduce using rule 48 (while_block -> WHILE ( exp ) block .)
    }               reduce using rule 48 (while_block -> WHILE ( exp ) block .)


state 182

    (50) print_stmt -> PRINT ( exp ) ; .

    }               reduce using rule 50 (print_stmt -> PRINT ( exp ) ; .)
    RETURN          reduce using rule 50 (print_stmt -> PRINT ( exp ) ; .)
    $end            reduce using rule 50 (print_stmt -> PRINT ( exp ) ; .)


state 183

    (99) args_aux -> , exp . args_aux
    (99) args_aux -> . , exp args_aux
    (100) args_aux -> . empty
    (105) empty -> .

    ,               shift and go to state 163
    )               reduce using rule 105 (empty -> .)

    args_aux                       shift and go to state 205
    empty                          shift and go to state 162

state 184

    (84) math_and_alt -> AND math_comp new_quad math_and_alt .

    OR              reduce using rule 84 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ;               reduce using rule 84 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    )               reduce using rule 84 (math_and_alt -> AND math_comp new_quad math_and_alt .)
    ,               reduce using rule 84 (math_and_alt -> AND math_comp new_quad math_and_alt .)


state 185

    (81) math_or_alt -> OR math_and new_quad math_or_alt .

    ;               reduce using rule 81 (math_or_alt -> OR math_and new_quad math_or_alt .)
    )               reduce using rule 81 (math_or_alt -> OR math_and new_quad math_or_alt .)
    ,               reduce using rule 81 (math_or_alt -> OR math_and new_quad math_or_alt .)


state 186

    (49) for_block -> FOR number FOR_TO number SKIP . number block
    (54) number -> . FLOAT
    (55) number -> . INT

    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    number                         shift and go to state 206

state 187

    (71) term_alt -> * factor new_quad term_alt .

    +               reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    -               reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    <               reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    >               reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    EQ              reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    NE              reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    LE              reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    GE              reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    AND             reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    OR              reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    ;               reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    )               reduce using rule 71 (term_alt -> * factor new_quad term_alt .)
    ,               reduce using rule 71 (term_alt -> * factor new_quad term_alt .)


state 188

    (72) term_alt -> / factor new_quad term_alt .

    +               reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    -               reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    <               reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    >               reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    EQ              reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    NE              reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    LE              reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    GE              reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    AND             reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    OR              reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    ;               reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    )               reduce using rule 72 (term_alt -> / factor new_quad term_alt .)
    ,               reduce using rule 72 (term_alt -> / factor new_quad term_alt .)


state 189

    (104) stack_method -> PEEK ( ) .

    *               reduce using rule 104 (stack_method -> PEEK ( ) .)
    /               reduce using rule 104 (stack_method -> PEEK ( ) .)
    +               reduce using rule 104 (stack_method -> PEEK ( ) .)
    -               reduce using rule 104 (stack_method -> PEEK ( ) .)
    <               reduce using rule 104 (stack_method -> PEEK ( ) .)
    >               reduce using rule 104 (stack_method -> PEEK ( ) .)
    EQ              reduce using rule 104 (stack_method -> PEEK ( ) .)
    NE              reduce using rule 104 (stack_method -> PEEK ( ) .)
    LE              reduce using rule 104 (stack_method -> PEEK ( ) .)
    GE              reduce using rule 104 (stack_method -> PEEK ( ) .)
    AND             reduce using rule 104 (stack_method -> PEEK ( ) .)
    OR              reduce using rule 104 (stack_method -> PEEK ( ) .)
    ;               reduce using rule 104 (stack_method -> PEEK ( ) .)
    )               reduce using rule 104 (stack_method -> PEEK ( ) .)
    ,               reduce using rule 104 (stack_method -> PEEK ( ) .)


state 190

    (102) stack_method -> POP ( ) .

    *               reduce using rule 102 (stack_method -> POP ( ) .)
    /               reduce using rule 102 (stack_method -> POP ( ) .)
    +               reduce using rule 102 (stack_method -> POP ( ) .)
    -               reduce using rule 102 (stack_method -> POP ( ) .)
    <               reduce using rule 102 (stack_method -> POP ( ) .)
    >               reduce using rule 102 (stack_method -> POP ( ) .)
    EQ              reduce using rule 102 (stack_method -> POP ( ) .)
    NE              reduce using rule 102 (stack_method -> POP ( ) .)
    LE              reduce using rule 102 (stack_method -> POP ( ) .)
    GE              reduce using rule 102 (stack_method -> POP ( ) .)
    AND             reduce using rule 102 (stack_method -> POP ( ) .)
    OR              reduce using rule 102 (stack_method -> POP ( ) .)
    ;               reduce using rule 102 (stack_method -> POP ( ) .)
    )               reduce using rule 102 (stack_method -> POP ( ) .)
    ,               reduce using rule 102 (stack_method -> POP ( ) .)


state 191

    (103) stack_method -> PUSH ( id . )

    )               shift and go to state 207


state 192

    (79) id -> ID .

    )               reduce using rule 79 (id -> ID .)


state 193

    (46) if_block -> IF ( exp ) block .
    (47) if_block -> IF ( exp ) block . ELSE block

    RETURN          reduce using rule 46 (if_block -> IF ( exp ) block .)
    }               reduce using rule 46 (if_block -> IF ( exp ) block .)
    $end            reduce using rule 46 (if_block -> IF ( exp ) block .)
    ELSE            shift and go to state 208


state 194

    (68) math_exp_alt -> - term new_quad math_exp_alt .

    <               reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    >               reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    EQ              reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    NE              reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    LE              reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    GE              reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    AND             reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    OR              reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    ;               reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    )               reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)
    ,               reduce using rule 68 (math_exp_alt -> - term new_quad math_exp_alt .)


state 195

    (67) math_exp_alt -> + term new_quad math_exp_alt .

    <               reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    >               reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    EQ              reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    NE              reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    LE              reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    GE              reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    AND             reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    OR              reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    ;               reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    )               reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)
    ,               reduce using rule 67 (math_exp_alt -> + term new_quad math_exp_alt .)


state 196

    (27) function -> # ID neg_lookup : return_type params scope_function . func_block
    (33) func_block -> . { vars statements return }

    {               shift and go to state 210

    func_block                     shift and go to state 209

state 197

    (107) scope_function -> empty .

    {               reduce using rule 107 (scope_function -> empty .)


state 198

    (28) params -> ( attrs . )

    )               shift and go to state 211


state 199

    (30) attrs -> empty .

    )               reduce using rule 30 (attrs -> empty .)


state 200

    (29) attrs -> attr . attrs_alt
    (31) attrs_alt -> . , attr attrs_alt
    (32) attrs_alt -> . empty
    (105) empty -> .

    ,               shift and go to state 212
    )               reduce using rule 105 (empty -> .)

    empty                          shift and go to state 213
    attrs_alt                      shift and go to state 214

state 201

    (22) class_block -> { vars constructor functions } .

    @               reduce using rule 22 (class_block -> { vars constructor functions } .)
    #               reduce using rule 22 (class_block -> { vars constructor functions } .)
    $               reduce using rule 22 (class_block -> { vars constructor functions } .)
    IF              reduce using rule 22 (class_block -> { vars constructor functions } .)
    WHILE           reduce using rule 22 (class_block -> { vars constructor functions } .)
    FOR             reduce using rule 22 (class_block -> { vars constructor functions } .)
    PRINT           reduce using rule 22 (class_block -> { vars constructor functions } .)
    READ            reduce using rule 22 (class_block -> { vars constructor functions } .)
    STRING          reduce using rule 22 (class_block -> { vars constructor functions } .)
    THIS            reduce using rule 22 (class_block -> { vars constructor functions } .)
    ID              reduce using rule 22 (class_block -> { vars constructor functions } .)
    (               reduce using rule 22 (class_block -> { vars constructor functions } .)
    FLOAT           reduce using rule 22 (class_block -> { vars constructor functions } .)
    INT             reduce using rule 22 (class_block -> { vars constructor functions } .)
    $end            reduce using rule 22 (class_block -> { vars constructor functions } .)


state 202

    (23) constructor -> ~ ID params . scope_constructor func_block
    (108) scope_constructor -> . empty
    (105) empty -> .

    {               reduce using rule 105 (empty -> .)

    scope_constructor              shift and go to state 215
    empty                          shift and go to state 216

state 203

    (42) constructor_call -> ID ( args . )

    )               shift and go to state 217


state 204

    (53) block -> { statements . }

    }               shift and go to state 218


state 205

    (99) args_aux -> , exp args_aux .

    )               reduce using rule 99 (args_aux -> , exp args_aux .)


state 206

    (49) for_block -> FOR number FOR_TO number SKIP number . block
    (53) block -> . { statements }

    {               shift and go to state 180

    block                          shift and go to state 219

state 207

    (103) stack_method -> PUSH ( id ) .

    *               reduce using rule 103 (stack_method -> PUSH ( id ) .)
    /               reduce using rule 103 (stack_method -> PUSH ( id ) .)
    +               reduce using rule 103 (stack_method -> PUSH ( id ) .)
    -               reduce using rule 103 (stack_method -> PUSH ( id ) .)
    <               reduce using rule 103 (stack_method -> PUSH ( id ) .)
    >               reduce using rule 103 (stack_method -> PUSH ( id ) .)
    EQ              reduce using rule 103 (stack_method -> PUSH ( id ) .)
    NE              reduce using rule 103 (stack_method -> PUSH ( id ) .)
    LE              reduce using rule 103 (stack_method -> PUSH ( id ) .)
    GE              reduce using rule 103 (stack_method -> PUSH ( id ) .)
    AND             reduce using rule 103 (stack_method -> PUSH ( id ) .)
    OR              reduce using rule 103 (stack_method -> PUSH ( id ) .)
    ;               reduce using rule 103 (stack_method -> PUSH ( id ) .)
    )               reduce using rule 103 (stack_method -> PUSH ( id ) .)
    ,               reduce using rule 103 (stack_method -> PUSH ( id ) .)


state 208

    (47) if_block -> IF ( exp ) block ELSE . block
    (53) block -> . { statements }

    {               shift and go to state 180

    block                          shift and go to state 220

state 209

    (27) function -> # ID neg_lookup : return_type params scope_function func_block .

    #               reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $               reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    IF              reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    WHILE           reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FOR             reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    PRINT           reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    READ            reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    STRING          reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    THIS            reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    ID              reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    (               reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    FLOAT           reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    INT             reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    $end            reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)
    }               reduce using rule 27 (function -> # ID neg_lookup : return_type params scope_function func_block .)


state 210

    (33) func_block -> { . vars statements return }
    (2) vars -> . var vars
    (3) vars -> . empty
    (4) var -> . $ attr init ;
    (105) empty -> .

    $               shift and go to state 16
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    STRING          reduce using rule 105 (empty -> .)
    THIS            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)

    vars                           shift and go to state 221
    var                            shift and go to state 18
    empty                          shift and go to state 19

state 211

    (28) params -> ( attrs ) .

    {               reduce using rule 28 (params -> ( attrs ) .)


state 212

    (31) attrs_alt -> , . attr attrs_alt
    (5) attr -> . ID : type

    ID              shift and go to state 24

    attr                           shift and go to state 222

state 213

    (32) attrs_alt -> empty .

    )               reduce using rule 32 (attrs_alt -> empty .)


state 214

    (29) attrs -> attr attrs_alt .

    )               reduce using rule 29 (attrs -> attr attrs_alt .)


state 215

    (23) constructor -> ~ ID params scope_constructor . func_block
    (33) func_block -> . { vars statements return }

    {               shift and go to state 210

    func_block                     shift and go to state 223

state 216

    (108) scope_constructor -> empty .

    {               reduce using rule 108 (scope_constructor -> empty .)


state 217

    (42) constructor_call -> ID ( args ) .

    ;               reduce using rule 42 (constructor_call -> ID ( args ) .)


state 218

    (53) block -> { statements } .

    $end            reduce using rule 53 (block -> { statements } .)
    }               reduce using rule 53 (block -> { statements } .)
    RETURN          reduce using rule 53 (block -> { statements } .)
    ELSE            reduce using rule 53 (block -> { statements } .)


state 219

    (49) for_block -> FOR number FOR_TO number SKIP number block .

    }               reduce using rule 49 (for_block -> FOR number FOR_TO number SKIP number block .)
    $end            reduce using rule 49 (for_block -> FOR number FOR_TO number SKIP number block .)
    RETURN          reduce using rule 49 (for_block -> FOR number FOR_TO number SKIP number block .)


state 220

    (47) if_block -> IF ( exp ) block ELSE block .

    RETURN          reduce using rule 47 (if_block -> IF ( exp ) block ELSE block .)
    }               reduce using rule 47 (if_block -> IF ( exp ) block ELSE block .)
    $end            reduce using rule 47 (if_block -> IF ( exp ) block ELSE block .)


state 221

    (33) func_block -> { vars . statements return }
    (34) statements -> . statement
    (35) statements -> . empty
    (36) statement -> . if_block
    (37) statement -> . while_block
    (38) statement -> . for_block
    (39) statement -> . print_stmt
    (40) statement -> . expr
    (105) empty -> .
    (46) if_block -> . IF ( exp ) block
    (47) if_block -> . IF ( exp ) block ELSE block
    (48) while_block -> . WHILE ( exp ) block
    (49) for_block -> . FOR number FOR_TO number SKIP number block
    (50) print_stmt -> . PRINT ( exp ) ;
    (56) expr -> . exp ;
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    RETURN          reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    IF              shift and go to state 51
    WHILE           shift and go to state 32
    FOR             shift and go to state 47
    PRINT           shift and go to state 34
    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    for_block                      shift and go to state 27
    statements                     shift and go to state 224
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    math_and                       shift and go to state 45
    id                             shift and go to state 36
    string                         shift and go to state 46
    math_exp                       shift and go to state 37
    prop                           shift and go to state 39
    read                           shift and go to state 40
    call                           shift and go to state 41
    statement                      shift and go to state 42
    factor                         shift and go to state 49
    empty                          shift and go to state 44
    print_stmt                     shift and go to state 48
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    expr                           shift and go to state 54
    if_block                       shift and go to state 55
    while_block                    shift and go to state 57
    exp                            shift and go to state 58
    assign                         shift and go to state 59

state 222

    (31) attrs_alt -> , attr . attrs_alt
    (31) attrs_alt -> . , attr attrs_alt
    (32) attrs_alt -> . empty
    (105) empty -> .

    ,               shift and go to state 212
    )               reduce using rule 105 (empty -> .)

    empty                          shift and go to state 213
    attrs_alt                      shift and go to state 225

state 223

    (23) constructor -> ~ ID params scope_constructor func_block .

    #               reduce using rule 23 (constructor -> ~ ID params scope_constructor func_block .)
    }               reduce using rule 23 (constructor -> ~ ID params scope_constructor func_block .)


state 224

    (33) func_block -> { vars statements . return }
    (51) return -> . RETURN exp ;
    (52) return -> . empty
    (105) empty -> .

    RETURN          shift and go to state 227
    }               reduce using rule 105 (empty -> .)

    return                         shift and go to state 226
    empty                          shift and go to state 228

state 225

    (31) attrs_alt -> , attr attrs_alt .

    )               reduce using rule 31 (attrs_alt -> , attr attrs_alt .)


state 226

    (33) func_block -> { vars statements return . }

    }               shift and go to state 229


state 227

    (51) return -> RETURN . exp ;
    (57) exp -> . read
    (58) exp -> . math_or
    (59) exp -> . assign
    (60) exp -> . string
    (62) read -> . READ ( read_type )
    (80) math_or -> . math_and math_or_alt
    (41) assign -> . prop = exp
    (61) string -> . STRING
    (83) math_and -> . math_comp math_and_alt
    (43) prop -> . THIS . ID
    (44) prop -> . ID . ID
    (45) prop -> . ID
    (86) math_comp -> . math_exp math_comp_alt
    (66) math_exp -> . term math_exp_alt
    (70) term -> . factor term_alt
    (75) factor -> . id
    (76) factor -> . number
    (77) factor -> . call
    (78) factor -> . ( math_or )
    (79) id -> . ID
    (54) number -> . FLOAT
    (55) number -> . INT
    (95) call -> . prop ( args )
    (96) call -> . stack_call
    (101) stack_call -> . ID . stack_method

    READ            shift and go to state 30
    STRING          shift and go to state 33
    THIS            shift and go to state 53
    ID              shift and go to state 50
    (               shift and go to state 38
    FLOAT           shift and go to state 28
    INT             shift and go to state 56

    math_or                        shift and go to state 26
    number                         shift and go to state 31
    stack_call                     shift and go to state 35
    id                             shift and go to state 36
    prop                           shift and go to state 39
    call                           shift and go to state 41
    math_exp                       shift and go to state 37
    factor                         shift and go to state 49
    math_and                       shift and go to state 45
    string                         shift and go to state 46
    read                           shift and go to state 40
    math_comp                      shift and go to state 43
    term                           shift and go to state 52
    exp                            shift and go to state 230
    assign                         shift and go to state 59

state 228

    (52) return -> empty .

    }               reduce using rule 52 (return -> empty .)


state 229

    (33) func_block -> { vars statements return } .

    #               reduce using rule 33 (func_block -> { vars statements return } .)
    }               reduce using rule 33 (func_block -> { vars statements return } .)
    $               reduce using rule 33 (func_block -> { vars statements return } .)
    IF              reduce using rule 33 (func_block -> { vars statements return } .)
    WHILE           reduce using rule 33 (func_block -> { vars statements return } .)
    FOR             reduce using rule 33 (func_block -> { vars statements return } .)
    PRINT           reduce using rule 33 (func_block -> { vars statements return } .)
    READ            reduce using rule 33 (func_block -> { vars statements return } .)
    STRING          reduce using rule 33 (func_block -> { vars statements return } .)
    THIS            reduce using rule 33 (func_block -> { vars statements return } .)
    ID              reduce using rule 33 (func_block -> { vars statements return } .)
    (               reduce using rule 33 (func_block -> { vars statements return } .)
    FLOAT           reduce using rule 33 (func_block -> { vars statements return } .)
    INT             reduce using rule 33 (func_block -> { vars statements return } .)
    $end            reduce using rule 33 (func_block -> { vars statements return } .)


state 230

    (51) return -> RETURN exp . ;

    ;               shift and go to state 231


state 231

    (51) return -> RETURN exp ; .

    }               reduce using rule 51 (return -> RETURN exp ; .)

